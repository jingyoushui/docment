解题思路：
示例: [a, b , c, d , e]

解答这类题目, 省略不掉遍历, 因此我们先从遍历方式说起

通常我们遍历子串或者子序列有三种遍历方式

以某个节点为开头的所有子序列: 如 [a]，[a, b]，[ a, b, c] ... 再从以 b 为开头的子序列开始遍历 [b] [b, c]。
根据子序列的长度为标杆，如先遍历出子序列长度为 1 的子序列，在遍历出长度为 2 的 等等。
以子序列的结束节点为基准，先遍历出以某个节点为结束的所有子序列，因为每个节点都可能会是子序列的结束节点，因此要遍历下整个序列，如: 以 b 为结束点的所有子序列: [a , b] [b] 以 c 为结束点的所有子序列: [a, b, c] [b, c] [ c ]。
第一种遍历方式通常用于暴力解法, 第二种遍历方式 leetcode (5. 最长回文子串 ) 中的解法就用到了。

第三种遍历方式 因为可以产生递推关系, 采用动态规划时, 经常通过此种遍历方式, 如 背包问题, 最大公共子串 , 这里的动态规划解法也是以 先遍历出 以某个节点为结束节点的所有子序列 的思路

对于刚接触动态规划的, 我感觉熟悉第三种遍历方式是需要抓住的核心

因为我们通常的惯性思维是以子序列的开头为基准，先遍历出以 a 为开头的所有子序列，再遍历出以 b 为开头的...但是动态规划为了找到不同子序列之间的递推关系，恰恰是以子序列的结束点为基准的，这点开阔了我们的思路。

我在网上看不少解答时，直接阅读其代码，总是感觉很理解很吃力，因为好多没有写清楚，一些遍历到底代表什么意思，看了许久仍不知所以然，下面的代码中摘录了 维基中的解释，感觉比较清楚，供大家理解参考。

代码：
// Kadane算法扫描一次整个数列的所有数值，
// 在每一个扫描点计算以该点数值为结束点的子数列的最大和（正数和）。
// 该子数列由两部分组成：以前一个位置为结束点的最大子数列、该位置的数值。
// 因为该算法用到了“最佳子结构”（以每个位置为终点的最大子数列都是基于其前一位置的最大子数列计算得出, 
// 该算法可看成动态规划的一个例子。
// 状态转移方程：sum[i] = max{sum[i-1]+a[i],a[i]}   
// 其中(sum[i]记录以a[i]为子序列末端的最大序子列连续和)

function  maxSubArray2  ( nums ) {
    if (!nums.length) {
        return;
    };
    // 在每一个扫描点计算以该点数值为结束点的子数列的最大和（正数和）。
    let max_ending_here = nums[0];
    let max_so_far = nums[0];

    for (let i = 1; i < nums.length; i ++ ) {
        // 以每个位置为终点的最大子数列 都是基于其前一位置的最大子数列计算得出,
    
        max_ending_here = Math.max ( nums[i], max_ending_here + nums[i]);
        max_so_far = Math.max ( max_so_far, max_ending_here);
    };
    
    return max_so_far;
};
var maxSubArray = function(nums) {
    let ans = nums[0];
    let sum = 0;
    for(let num of nums) {
        // if(sum > 0) { 可以写成这样
        if(sum + num > num ){
            sum = sum + num;
        } else {
            sum = num;
        }
        ans = Math.max(ans, sum);
    };
    return ans;
};

第二块代码和 第一块代码 思路实现是完全一样的，但是如果第一次看到这类题目，直接阅读 第二块代码，理解起来很难，尤其是 如果改成 if (sum > 0 ) 对于刚接触的这题目的比较不好理解。

## 动态归化

![img](https://pic.leetcode-cn.com/1f95da43d1bdeebdd1213bb804034ddc5f906dc61451cd63f2b5ab5d0eb33b33-%E3%80%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%8D%E9%97%AE%E9%A2%98%E6%80%9D%E8%80%83%E6%96%B9%E5%90%91.png)





```java
public class Solution {

    public String longestPalindrome(String s) {
        // 特判
        int len = s.length();
        if (len < 2) {
            return s;
        }

        int maxLen = 1;
        int begin = 0;

        // dp[i][j] 表示 s[i, j] 是否是回文串
        boolean[][] dp = new boolean[len][len];
        char[] charArray = s.toCharArray();

        for (int i = 0; i < len; i++) {
            dp[i][i] = true;
        }
        for (int j = 1; j < len; j++) {
            for (int i = 0; i < j; i++) {
                if (charArray[i] != charArray[j]) {
                    dp[i][j] = false;
                } else {
                    if (j - i < 3) {
                        dp[i][j] = true;
                    } else {
                        dp[i][j] = dp[i + 1][j - 1];
                    }
                }

                // 只要 dp[i][j] == true 成立，就表示子串 s[i..j] 是回文，此时记录回文长度和起始位置
                if (dp[i][j] && j - i + 1 > maxLen) {
                    maxLen = j - i + 1;
                    begin = i;
                }
            }
        }
        return s.substring(begin, begin + maxLen);
    }
}

作者：liweiwei1419
链接：https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



动态规划用来解决重复子问题，最优子结构，无后效性等问题。

#### 1.重复子问题

![image-20200510132457576](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200510132457576.png)

![image-20200510133105182](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200510133105182.png)

![image-20200510133122228](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200510133122228.png)

![image-20200510133140619](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200510133140619.png)

![image-20200510133156584](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200510133156584.png)

![image-20200510133414291](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200510133414291.png)

![image-20200510133444049](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200510133444049.png)

![image-20200510133500031](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200510133500031.png)

#### 2.最优子结构



#### 3.无后效性

我们在第 1 节向大家介绍过「无后效性」的两层含义：

- 在推导后面阶段的状态的时候，我们只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的。
- 某阶段状态一旦确定，就不受之后阶段的决策影响。

下面我们就通过具体的例子向大家进行说明。

这道问题是经典的「力扣」第 198 题： [打家劫舍](https://leetcode-cn.com/problems/house-robber/) 。题目只问最优值，并没有问最优解，因此绝大多数情况下可以考虑使用「动态规划」的方法。

如果我们直接将问题的问法定义成状态，会发现，当前这个房子「偷」和「不偷」会影响到后面的房子「偷」与「不偷」。

一般的情况是，只要有约束，就可以增加一个维度消除这种约束带来的影响，还是上一节和大家介绍的方法：把「状态」定义得清楚、准确，「状态转移方程」就容易得到了。

##### 第 1 步：设计状态

「状态」这个词可以理解为「记录了求解问题到了哪一个阶段」。

由于当前这一个房屋是否有两种选择：（1）偷；（2）不偷。

`dp[i][0]` 表示：考虑区间 `[0，i]` ，并且下标为 `i` 的这个房间偷，能够偷窃到的最高金额；

`dp[i][1]` 表示：考虑区间 `[0，i]` ，并且下标为 `i` 的这个房间不偷，能够偷窃到的最高金额。

说明：这个定义是 有前缀性质的，即当前的状态值考虑了（或者说综合了）之前的相关的状态值 ，第 2 维保存了当前最优值的决策，这种 通过增加维度，消除后效性的操作在「动态规划」问题里是非常常见的 。

强调：

无后效性的理解：1、后面的决策不会影响到前面的决策； 2、之前的状态怎么来的并不重要。

再联系状态的定义：状态是一个概括的值，这个值是怎么来的，并不记录。因为状态定义更细致，后面的决策才不会影响到前面的决策。

##### 第 2 步：状态转移方程

「状态转移方程」可以理解为「不同阶段之间的联系」。

今天只和昨天的状态相关，依然是分类讨论：

- 下标为 `i` 的房屋不偷：或者是上一间不偷，或者是上一间偷，取二者最大值，即： `dp[i][0] = max(dp[i - 1][0], dp[i - 1][1])` ；
- 下标为 `i` 的房屋偷：只需要从上一间不偷，这一间偷，即： `dp[i][1] = dp[i - 1][0] + nums[i]` 。

##### 第 3 步：考虑初始化

从第 2 天开始，每天的状态值只与前一天有关，因此第 1 天就只好老老实实算了。好在不难判断： `dp[0][0] = 0` 与 `dp[0][1] = nums[0]` ；

这里有一种 **技巧，可以把状态数组多设置一行** ，这样可以减少对第 1 天的初始化，这样的代码把第 1 天的情况考虑了进去，但编码的时候要注意状态数组下标的设置， 请见题解最后的「参考代码 3」。

##### 第 4 步：考虑输出

由于状态值的定义是前缀性质的，因此最后一天的状态值就考虑了之前所有的天数的情况。下标为 `len - 1` 这个房屋可以偷，也可以不偷，取二者最大值。

```java
public class Solution {

    public int rob(int[] nums) {
        int len = nums.length;
        if (len == 0) {
            return 0;
        }
        if (len == 1) {
            return nums[0];
        }

        // dp[i][0]：考虑区间 [0, i] ，并且下标为 i 的这个房屋不偷
        // dp[i][1]：考虑区间 [0, i] ，并且下标为 i 的这个房屋偷
        int[][] dp = new int[len][2];
        dp[0][0] = 0;
        dp[0][1] = nums[0];

        for (int i = 1; i < len; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1]);
            dp[i][1] = dp[i - 1][0] + nums[i];
        }
        return Math.max(dp[len - 1][0], dp[len - 1][1]);
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        // int[] nums = {1, 2, 3, 1};
        // int[] nums = {2, 7, 9, 3, 1};
        int[] nums = {2, 1, 4, 5, 3, 1, 1, 3};
        int res = solution.rob(nums);
        System.out.println(res);
    }
}
```

##### 复杂度分析：

- 时间复杂度：O(N)O(N)，NN 是数组的长度；
- 空间复杂度：O(N)O(N)，状态数组的大小为 2N2N。

参考代码 2：根据方法一：状态数组多设置一行，以避免对极端用例进行讨论。

```java
public class Solution {

    public int rob(int[] nums) {
        int len = nums.length;
        int[][] dp = new int[len + 1][2];

        // 注意：外层循环从 1 到 =len，相对 dp 数组而言，引用到 nums 数组的时候就要 -1
        for (int i = 1; i <= len; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1]);
            dp[i][1] = dp[i - 1][0] + nums[i - 1];
        }
        return Math.max(dp[len][0], dp[len][1]);
    }
}
```

##### 复杂度分析：

- 时间复杂度：O(N)O(N)，NN 是数组的长度；
- 空间复杂度：O(N)O(N)，状态数组的大小为 2(N+1)2(N+1)，记为 O(N)O(N)。

##### 第 5 步：考虑是否可以状态压缩

由于我们只关心最后一个状态值。并且

`dp[i]` 只参考了 `dp[i - 1]` 的值，状态可以压缩，可以使用「滚动数组」完成。

值得说明的是：状态压缩的代码丢失了一定可读性，也会给编码增加一点点难度。

参考代码 3：使用「滚动数组」技巧，将空间优化到常数级别

在编码的时候，需要注意，只要访问到 `dp` 数组的时候，需要对下标 `% 2` ，等价的写法是 `& 1` 。

```java
public class Solution {

    public int rob(int[] nums) {
        int len = nums.length;
        if (len == 0) {
            return 0;
        }
        if (len == 1) {
            return nums[0];
        }

        int[][] dp = new int[2][2];
        dp[0][0] = 0;
        dp[0][1] = nums[0];

        for (int i = 1; i < len; i++) {
            dp[i & 1][0] = Math.max(dp[(i - 1) & 1][0], dp[(i - 1) & 1][1]);
            dp[i & 1][1] = dp[(i - 1) & 1][0] + nums[i];
        }
        return Math.max(dp[(len - 1) & 1][0], dp[(len - 1) & 1][1]);
    }
}
```

复杂度分析：

- 时间复杂度：O(N)O(N)，NN 是数组的长度；
- 空间复杂度：O(1)O(1)，状态数组的大小为 44，常数空间。

总结

「状态」和「状态转移方程」得到以后，这个问题其实就得到了解决，剩下的一些细节的问题在编码的时候只要稍微留意一点就行了。

到这里「重复子问题」、「最优子结构」、「无后效性」我们就都向大家介绍完了。「动态规划」告诉我们可以「自底向上」去考虑一件事情，并且记录下求解问题的中间过程。

「动态规划」问题没有套路，我们只有通过不断地联系，去掌握状态设计的一般方法和技巧，体会上面所说的「动态规划」的基本概念和基本特征。



### 二维数组-状态机

#### [213. 打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)

![image-20200512212948490](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200512212948490.png)

```java
class Solution {
    public int rob(int[] nums) {
        //同样使用dp[i][0]表示第i个不偷时的金额
        //dp[i][1]表示第i个偷时的金额。
        //同时最后一个的时候要考虑第一个有没有偷
        int len = nums.length;
        if(len==0){
            return 0;
        }
        if(len==1){
            return nums[0];
        }
        if(len==2){
            return Math.max(nums[0],nums[1]);
        }

        int[][] dp = new int[len][2];
        //第一个不偷
        dp[0][0] = 0;
        dp[0][1] = 0;
         for (int i = 1; i < len; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1]);
            dp[i][1] = dp[i - 1][0] + nums[i];
        }
        int butou = Math.max(dp[len-1][0],dp[len-1][1]);
         //最后一个不偷
        dp[0][0] = 0;
        dp[0][1] = nums[0];
         for (int i = 1; i < len; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1]);
            dp[i][1] = dp[i - 1][0] + nums[i];
        }
           int tou =dp[len-1][0];

        return Math.max(tou,butou);
    }
}

```

### 一维数组-以该位置为结尾的最值问题

#### 53.最大子序和

给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例:

输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
进阶:

如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。

> ![20200505_41f3e5](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/20200505_41f3e5.png)

```java
class Solution {
    public int maxSubArray(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        int res = nums[0];
        int sum = nums[0];
        for (int i = 1; i < nums.length; i++) {
            if (sum <= 0) {
                sum = nums[i];
            } else {
                sum += nums[i];
            }
            res = res > sum ? res : sum;
        }

        return res;
    }
}
```

#### 523. 连续的子数组和

>给定一个包含非负数的数组和一个目标整数 k，编写一个函数来判断该数组是否含有连续的子数组，其大小至少为 2，总和为 k 的倍数，即总和为 n*k，其中 n 也是一个整数。
>
>示例 1:
>
>输入: [23,2,4,6,7], k = 6
>输出: True
>解释: [2,4] 是一个大小为 2 的子数组，并且和为 6。
>示例 2:
>
>输入: [23,2,6,4,7], k = 6
>输出: True
>解释: [23,2,6,4,7]是大小为 5 的子数组，并且和为 42。
>说明:
>
>数组的长度不会超过10,000。
>你可以认为所有数字总和在 32 位有符号整数范围内。
>
>来源：力扣（LeetCode）
>链接：https://leetcode-cn.com/problems/continuous-subarray-sum
>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

和上一题的基本思路一样，也是计算以nums[i]为结尾的子数组的和，由于以nums[i]为结尾的子数组和会有i个(包括i本身)。初始化辅助数组arr[],长度和nums相等。

以[23,2,4,6,7]为例，初始化数组arr为[0,0,0,0,0]

遍历nums数组，将nums[i]赋值给arr[i],arr[i-1]用来保存从0到i的和。当i=0时候

arr:[23,0,0,0,0]

当i=1时候,将nums[1]=2加到arr中每个元素上

arr:[25,2,0,0,0]

当i=2时候,将nums[2]=4加上

arr:[29,6,4,0,0]

当i=3时候

arr[35,12,10,6,0]

当i=4

arr:[42,19,17,13,7]

每一次都再遍历一遍arr数组，查找里面的元素是否有k的倍数。

```java
class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {
     
        int l = nums.length;
        int[] arr = new int[l];
        for (int i=0;i<l;i++){
            arr[i] = nums[i];
            for(int j=0;j<i;j++){
                arr[j]+=nums[i];
            }
        
            for(int m=0;m<i;m++){
                if(arr[m] ==0&&k==0){
                    return true;
                }
                
                if(k!=0&&arr[m] %k ==0){
                    return true;
                }
            }

        }
        return false;
    }

}
```

![image-20200515211946655](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200515211946655.png)

![image-20200515212501206](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200515212501206.png)

![image-20200515212629806](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200515212629806.png)

```java
public class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {
        int sum = 0;
        HashMap < Integer, Integer > map = new HashMap < > ();
        map.put(0, -1);
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
            if (k != 0)
                sum = sum % k;
            if (map.containsKey(sum)) {
                if (i - map.get(sum) > 1)
                    return true;
            } else
                map.put(sum, i);
        }
        return false;
    }
}

```









#### [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)

![20200506_4421f8](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/20200506_4421f8.png)

思路:

黑色的看成墙，蓝色的看成水，宽度一样，给定一个数组，每个数代表从左到右墙的高度，求出能装多少单位的水。也就是图中蓝色正方形的个数。

![20200506_4095a8](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/20200506_4095a8.png)

![20200506_7ed51c](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/20200506_7ed51c-1588766467351.png)

![20200506_9a0675](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/20200506_9a0675-1588766512907.png)

![20200506_e1756b](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/20200506_e1756b.png)

```java
public int trap(int[] height) {
    int sum = 0;
    int max = getMax(height);//找到最大的高度，以便遍历。
    for (int i = 1; i <= max; i++) {
        boolean isStart = false; //标记是否开始更新 temp
        int temp_sum = 0;
        for (int j = 0; j < height.length; j++) {
            if (isStart && height[j] < i) {
                temp_sum++;
            }
            if (height[j] >= i) {
                sum = sum + temp_sum;
                temp_sum = 0;
                isStart = true;
            }
        }
    }
    return sum;
}
private int getMax(int[] height) {
		int max = 0;
		for (int i = 0; i < height.length; i++) {
			if (height[i] > max) {
				max = height[i];
			}
		}
		return max;
}

```

时间复杂度：如果最大的数是 *m*，个数是 *n*，那么就是 O*(*m*∗*n)。

![20200506_2f46f9](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/20200506_2f46f9.png)

![20200506_dceb2e](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/20200506_dceb2e.png)

![20200506_f4f679](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/20200506_f4f679.png)

![20200506_ba424a](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/20200506_ba424a.png)



```java
public int trap(int[] height) {
    int sum = 0;
    //最两端的列不用考虑，因为一定不会有水。所以下标从 1 到 length - 2
    for (int i = 1; i < height.length - 1; i++) {
        int max_left = 0;
        //找出左边最高
        for (int j = i - 1; j >= 0; j--) {
            if (height[j] > max_left) {
                max_left = height[j];
            }
        }
        int max_right = 0;
        //找出右边最高
        for (int j = i + 1; j < height.length; j++) {
            if (height[j] > max_right) {
                max_right = height[j];
            }
        }
        //找出两端较小的
        int min = Math.min(max_left, max_right);
        //只有较小的一段大于当前列的高度才会有水，其他情况不会有水
        if (min > height[i]) {
            sum = sum + (min - height[i]);
        }
    }
    return sum;
}

```

时间复杂度：O*(*n*²），遍历每一列需要 n*，找出左边最高和右边最高的墙加起来刚好又是一个 n，所以是 n²。

空间复杂度：O(1）

![20200506_71d078](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/20200506_71d078.png)

```java
public int trap(int[] height) {
    int sum = 0;
    int[] max_left = new int[height.length];
    int[] max_right = new int[height.length];
    
    for (int i = 1; i < height.length - 1; i++) {
        max_left[i] = Math.max(max_left[i - 1], height[i - 1]);
    }
    for (int i = height.length - 2; i >= 0; i--) {
        max_right[i] = Math.max(max_right[i + 1], height[i + 1]);
    }
    for (int i = 1; i < height.length - 1; i++) {
        int min = Math.min(max_left[i], max_right[i]);
        if (min > height[i]) {
            sum = sum + (min - height[i]);
        }
    }
    return sum;
}

```

时间复杂度：O(n)。

空间复杂度：O(n)，用来保存每一列左边最高的墙和右边最高的墙。

![20200506_b9796b](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/20200506_b9796b.png)

![20200506_27e5a5](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/20200506_27e5a5.png)

```java
public int trap(int[] height) {
    int sum = 0;
    int max_left = 0;
    int max_right = 0;
    int left = 1;
    int right = height.length - 2; // 加右指针进去
    for (int i = 1; i < height.length - 1; i++) {
        //从左到右更
        if (height[left - 1] < height[right + 1]) {
            max_left = Math.max(max_left, height[left - 1]);
            int min = max_left;
            if (min > height[left]) {
                sum = sum + (min - height[left]);
            }
            left++;
        //从右到左更
        } else {
            max_right = Math.max(max_right, height[right + 1]);
            int min = max_right;
            if (min > height[right]) {
                sum = sum + (min - height[right]);
            }
            right--;
        }
    }
    return sum;
}

```

![20200506_a73601](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/20200506_a73601.png)

![20200506_445bc9](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/20200506_445bc9.png)

```java
public int trap(int[] height) {
    int sum = 0;
    
    int left = 0;
    int right = height.length -1; // 加右指针进去
    int max_left = 0;
    int max_right =0;
    while(left<=right){//前两次循环没有加sum，只是初始化left_max和right_max最大值
        //从左到右更
        if (max_left < max_right) {
            max_left = Math.max(max_left, height[left ]);
            int min = max_left;
            if (min > height[left]) {
                sum = sum + (min - height[left]);
            }
            left++;
        //从右到左更
        } else {
            max_right = Math.max(max_right, height[right ]);
            int min = max_right;
            if (min > height[right]) {
                sum = sum + (min - height[right]);
            }
            right--;
        }
    }
    return sum;
}
```

```java
  public int trap(int[] height) {
      if(height.length<=1){
          return 0;
      }
    int sum = 0;
    
    int left = 1;
    int right = height.length -2; // 加右指针进去
    int max_left = height[0];
    int max_right =height[height.length-1];
    while(left<=right){
        //从左到右更
        if (max_left < max_right) {
            max_left = Math.max(max_left, height[left ]);
            int min = max_left;
            if (min > height[left]) {
                sum = sum + (min - height[left]);
            }
            left++;
        //从右到左更
        } else {
            max_right = Math.max(max_right, height[right ]);
            int min = max_right;
            if (min > height[right]) {
                sum = sum + (min - height[right]);
            }
            right--;
        }
    }
    return sum;
```

![20200506_ff8366](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/20200506_ff8366.png)

![20200506_53f653](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/20200506_53f653.png)



![image-20200506211931907](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200506211931907.png)

![image-20200506211950638](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200506211950638.png)

![image-20200506212012403](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200506212012403.png)

![image-20200506212026296](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200506212026296.png)

```java
public int trap6(int[] height) {
    int sum = 0;
    Stack<Integer> stack = new Stack<>();
    int current = 0;
    while (current < height.length) {
        //如果栈不空并且当前指向的高度大于栈顶高度就一直循环
        while (!stack.empty() && height[current] > height[stack.peek()]) {
            int h = height[stack.peek()]; //取出要出栈的元素
            stack.pop(); //出栈
            if (stack.empty()) { // 栈空就出去
                break; 
            }
            int distance = current - stack.peek() - 1; //两堵墙之前的距离。
            int min = Math.min(height[stack.peek()], height[current]);
            sum = sum + distance * (min - h);
        }
        stack.push(current); //当前指向的墙入栈
        current++; //指针后移
    }
    return sum;
}

```

时间复杂度：虽然 while 循环里套了一个 while 循环，但是考虑到每个元素最多访问两次，入栈一次和出栈一次，所以时间复杂度是 O(n)

空间复杂度：O(n)。栈的空间。

#### [1277. 统计全为 1 的正方形子矩阵](https://leetcode-cn.com/problems/count-square-submatrices-with-all-ones/)

![image-20200506215350271](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200506215350271.png)

![image-20200506215625710](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200506215625710.png)

![image-20200506215646556](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200506215646556.png)

![image-20200506215659684](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200506215659684.png)

```java
class Solution {
    public int countSquares(int[][] matrix) {
        if(matrix.length<1){
            return 0;
        }
        int m = matrix.length;
        int n = matrix[0].length;
        int[][] arr = new int[m][n];
        int ans = 0;
        for(int i = 0;i<m;++i){
            for(int j=0;j<n;++j){
                if(i==0|| j==0){
                    arr[i][j] = matrix[i][j];
                }else if(matrix[i][j] == 0){
                    arr[i][j] =0;
                }else{
                    arr[i][j] = Math.min( Math.min(arr[i][j-1],arr[i-1][j]),arr[i-1][j-1])+1;
                }
                ans += arr[i][j];
            }
        }
        return ans;
       

    }
}
```



```java
class Solution {
    public int countSquares(int[][] matrix) {
        int rows = matrix.length;
        int columns = matrix[0].length;
        int[][] dp = new int[rows][columns];
        int results = 0;
        for (int i = 0; i < rows; i++) {
            if (matrix[i][0] == 1) {
                dp[i][0] = 1;
            }
        }
        for (int j = 0; j < columns; j++) {
            if (matrix[0][j] == 1) {
                dp[0][j] = 1;
            }
        }
        for (int i = 1; i < rows; i++) {
            for (int j = 1; j < columns; j++) {
                if (matrix[i][j] == 1) {
                    dp[i][j] = threeNumbersMin(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1;
                }
            }
        }
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < columns; j++) {
                results += dp[i][j];
            }
        }
        return results;
    }

    private int threeNumbersMin(int i, int j, int k) {
        int temp = Math.min(i, j);
        return Math.min(temp, k);
    }
}
```





#### [1024. 视频拼接](https://leetcode-cn.com/problems/video-stitching/)

![image-20200507195912359](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200507195912359.png)

![image-20200507200116493](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200507200116493.png)

动态规划：

![image-20200507201308217](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200507201308217.png)

贪心

```java
class Solution {
	public int videoStitching(int[][] clips, int T) {
		int right = -1 ,left = 0,ans = 0;
		while(right < T) {
                for(int i = 0 ; i < clips.length; i++) {
                    if(clips[i][0] <= left &&  right<clips[i][1]) {
                        right = clips[i][1];//选出最宽的区间
                    }
                }
                if(right == -1 || right == left){//一开始找不到或者右边仍然等于左边说明断开了
                    return -1;
                }
                ans++;
                left = right;//更新区间左边最小值
        }
        return ans;
    }
}
```

```java
public int videoStitching(int[][] clips, int T) {
    int count = 0;
    for (int time = 0; time < T; ) {
        int max = time;
        //每次选择起始时间小于当前时间点而结束时间最晚的视频
        for (int j = 0; j < clips.length; j++) {
            if (clips[j][0] <= time) {
                max = Math.max(max, clips[j][1]);
            }
        }
        //找不到下一个视频返回-1
        if (max == time) {
            return -1;
        }
        count++;
        time = max;
    }
    return count;
}

```





#### [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

![image-20200510120604489](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200510120604489.png)

动态规划-自底向上

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount+1];
        Arrays.fill(dp,amount+1);
        dp[0] = 0;
        for(int i=1;i<=amount;i++){
            for(int coin:coins){
                if(i>=coin&&dp[i-coin]!=amount+1){
                    dp[i] = Math.min(dp[i],dp[i-coin]+1);
                }
            }
        }
        if(dp[amount]==amount+1){
            dp[amount] = -1;
        }
        return dp[amount];
    }
}
```



```java
public class Solution {
  public int coinChange(int[] coins, int amount) {
    int max = amount + 1;
    int[] dp = new int[amount + 1];
    Arrays.fill(dp, max);
    dp[0] = 0;
    for (int i = 1; i <= amount; i++) {
      for (int j = 0; j < coins.length; j++) {
        if (coins[j] <= i) {
          dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
        }
      }
    }
    return dp[amount] > amount ? -1 : dp[amount];
  }
}
```

贪心算法

![image-20200510122722860](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200510122722860.png)

![image-20200510122740263](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200510122740263.png)



```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        Arrays.sort(coins);
        recursion(coins, amount, 0, coins.length - 1);
        return minCount == Integer.MAX_VALUE ? -1 : minCount;
    }
    int minCount = Integer.MAX_VALUE;
    /**
     * 1、按金额从大到小，从多到少（排序，用余数一步到位）
     * 2、预判低于最优解，终止递归（可以返回最优解，不过提升有限，意义不大）
     * 3、能整除即可返回
     */
    void recursion(int[] coins, int amount, int count, int index) {
        if (index < 0 || count + amount / coins[index] >= minCount) return;
        if (amount % coins[index] == 0) {
            minCount = Math.min(minCount, count + amount / coins[index]);
            return;
        }
        for (int i = amount / coins[index]; i >= 0; i--) {
            recursion(coins, amount - i * coins[index], count + i, index - 1);
        }
    }
}
```

```java
       int ans = Integer.MAX_VALUE;

    public int coinChange(int[] coins, int amount) {
        Arrays.sort(coins);
        coinChange(coins.length-1, coins, 0, amount);
        return ans == Integer.MAX_VALUE ? -1 : ans;
    }

    private void coinChange(int index, int[] coins, int count, int needAmount) {
        if (needAmount == 0) {
            ans = Math.min(count, ans);
            return;
        }
        if (index < 0) {
            return;
        }

        int i = needAmount / coins[index];
        for (int k=i; k>=0 && count+k<ans; k--) {
            coinChange(index-1, coins, count+k, needAmount-k*coins[index]);
        }
    }
```



#### [1027. 最长等差数列](https://leetcode-cn.com/problems/longest-arithmetic-sequence/)

![image-20200512220124187](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200512220124187.png)



```java
class Solution {
    public int longestArithSeqLength(int[] A) {
        int n = A.length;
        if (n < 2) return n;
        int[][] dp = new int[n][n];
        //dp[i][j] means nums[i] nums[j] is two last elements.
        int[] index = new int[20001];//index[i]表示i在A中有没有出现过，出现的位置是哪里，-1为未出现。
        int res = 2;
        Arrays.fill(index, -1);
        for (int i = 0; i < n - 1; i++) {
            Arrays.fill(dp[i], 2);//二维数组全部用2填充
            for (int j = i + 1; j < n; j++) {
                int prev = A[i] * 2 - A[j];//计算出前一个值的大小A[i]-(A[j]-A[i])
                if (prev < 0 || index[prev] == -1) continue;//数列前一个值数组中没有
                dp[i][j] = dp[index[prev]][i] + 1;
                res = Math.max(res, dp[i][j]);
            }
            index[A[i]] = i;
        }
        return res;
    }
}
```



dp[i][j]表示以（A[i],A[j]）结尾的等差子序列的最大长度，即等差序列：....A[i],A[j]

类比最长上升子序列问题:之所以上升子序列的题定义状态是以某一个元素结尾，是因为对一个元素x和一个上升序列Y,判断x能不能添加到Y里，只需要把x和Y当前的末尾元素比较即可；而本题和最长的斐波那契子序列的问题类似，对一个元素x和一个子序列Y，要判断x能不能添加到Y里，必须用到Y的末尾两个的元素来和x比较。

状态转移方程：
dp[i][j]=dp[k][i]+1...k<i且A[i]-A[k]==A[j]-A[i]
//和873题一样，这个地方不用取Math.max(dp[o.get(k)][i]+1,dp[i][j]);我的理解是对于以A[i],A[j]结尾的序列来说，A[k]要么不存在，要是存在一定是固定的一个,即:A[i]-(A[j]-A[i])，所以直接加1即可，不可能更大了

返回值就是所有的以某两个元素结尾的等差序列里的最长的那一个

本题用了一下哈希表来事先记录<A[i],i>，但是并没有使算法的时间复杂度有数量级上的降低，依旧是O(n^3)

```java
class Solution {
    public int longestArithSeqLength(int[] A) {
  int n=A.length;
        HashMap<Integer,ArrayList<Integer>> hashMap=new HashMap<>();
        ArrayList<Integer> temp;
        for(int i=0;i<n;i++){
            if(hashMap.get(A[i])==null){
                temp=new ArrayList<>();
                temp.add(i);
                hashMap.put(A[i],temp);
            }
            else {hashMap.get(A[i]).add(i);}
        }
        int [][] dp=new int[n][n];
        for(int i=0;i<n-1;i++){
            for(int j=i+1;j<n;j++){
                dp[i][j]=2;//初始化
            }
        }
        int max_len=2;
        for(int i=1;i<n-1;i++){
            for(int j=i+1;j<n;j++){
                ArrayList<Integer> o=hashMap.get(A[i]-(A[j]-A[i]));
                if(o!=null) {
                    for(int k=0;k<o.size();k++){
                        if(o.get(k)<i) {dp[i][j]=dp[o.get(k)][i]+1;}
                    }

                }


                max_len=Math.max(max_len,dp[i][j]);
            }
        }
        return max_len;

    }
}

```





#### [10. 正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)

![image-20200513231042964](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200513231042964.png)

![image-20200513230937752](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200513230937752.png)



![image-20200513230952517](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200513230952517.png)

```java
bool isMatch(string s, string p) {
    if (s == "" && p == "") {
        return true;
    }
    unsigned long m = s.length(), n = p.length();
    bool dp[m + 1][n + 1];
    memset(dp, false, sizeof(dp));
    dp[0][0] = true;
    for (int j = 1; j <= n; j++) {
        if ((p[j - 1] == '*') && dp[0][j - 2]) {
            dp[0][j] = true;
        }
    }
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (s[i - 1] == p[j - 1] || p[j - 1] == '.') {
                dp[i][j] = dp[i - 1][j - 1];
            }
            else
                if (p[j - 1] == '*') {
                    if (p[j - 2] == s[i - 1] || p[j - 2] == '.') {  //三者满足其一即可
                        dp[i][j] = dp[i - 1][j] || dp[i][j - 1] || dp[i][j-2];
                    }
                    else
                        dp[i][j] = dp[i][j-2];  //p[j - 2] != s[i - 1]
                }
         }
    }
    return dp[m][n];
}

```

#### [32. 最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)

![image-20200513231534556](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200513231534556.png)

![image-20200513231444024](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200513231444024.png)

![image-20200513231458668](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200513231458668.png)

```c
class Solution {
    public int longestValidParentheses(String s) {
        int[] dp = new int[s.length()];
        int res = 0;
        //Arrays.fill(dp,0);
        for(int i=1;i<s.length();i++){
            if(s.charAt(i)==')'){
                if(s.charAt(i-1)=='('){
                    dp[i] = (i-2>=0? dp[i-2]:0) + 2;
                }else if(i-dp[i-1]-1 >=0 && s.charAt(i-dp[i-1]-1)=='('){
                    dp[i] =(i-dp[i-1]-2 >=0? dp[i-dp[i-1]-2]:0) + dp[i-1] + 2;
                }
            }
            res = Math.max(dp[i],res);
        }
        return res;
    }
}
```

```java
class Solution {
    public int longestValidParentheses(String s) {
        if(s == null) return 0;
        int maxlen = 0;
        int[] dp = new int[s.length()];
        for (int i = 1; i < s.length(); i++){
            if(s.charAt(i) == ')'){
                if(s.charAt(i-1) == '('){
                    dp[i] = (i>=2? dp[i-2]:0) + 2;
                }else if(i - dp[i-1] - 1 >= 0 && s.charAt(i - dp[i-1] - 1) == '('){
                    dp[i] = 2 + dp[i-1] + ((i - dp[i-1] - 2) >= 0? dp[i - dp[i-1] - 2] : 0);
                }
                maxlen = Math.max(maxlen, dp[i]);
            }
        }
        return maxlen;
    }

}
```



### 三维数组-状态机

#### [688. “马”在棋盘上的概率](https://leetcode-cn.com/problems/knight-probability-in-chessboard/)

![image-20200514205545469](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200514205545469.png)

2/8*2/8 = 0.0625

![image-20200514210157910](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200514210157910.png)

![image-20200514210232918](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200514210232918.png)



```java
class Solution {
    public double knightProbability(int N, int K, int r, int c) {
        double[][][] dp = new double[N+4][N+4][K+1];
      for (int i = 0; i < N + 4; i++) {
		for (int j = 0; j < N + 4; j++) {
			if ((i) >= 2 && (i) <= N + 1) {
				if ((j)>= 2 && (j) <= N + 1) {
					dp[i][j][0] = 1;
				}
			}
			else {
				dp[i][j][0] = 0;
			}
		}
	}
        for(int k=1;k<=K;k++){
            for(int i=2;i<N+2;i++){
                for(int j=2;j<N+2;j++){
                    dp[i][j][k] = (dp[i-2][j-1][k-1]+dp[i-2][j+1][k-1]+
                            dp[i-1][j-2][k-1]+dp[i-1][j+2][k-1]+
                            dp[i+1][j-2][k-1]+dp[i+1][j+2][k-1]+
                            dp[i+2][j-1][k-1]+dp[i+2][j+1][k-1])/8.0;
                }
            }
                
        }
        return dp[r + 2][c + 2][K];

    }
}
```

```java
class Solution {
    //记忆化dfs  by:bennu
    double[][][] cache;
    public double knightProbability(int N, int K, int r, int c) {
        cache = new double[N][N][K + 1];
        return jump(N, K, r, c);
    }

    public double jump(int N, int K, int r, int c) {
        if(r < 0 || c < 0 || r >= N || c >= N){
            return 0;
        }
        if(K == 0){
            return 1;
        }
        if(cache[r][c][K] > 0){
            return cache[r][c][K];
        }
        double total = 0;
        total += jump(N, K - 1, r - 2, c - 1);
        total += jump(N, K - 1, r - 2, c + 1);
        total += jump(N, K - 1, r + 2, c - 1);
        total += jump(N, K - 1, r + 2, c + 1);
        total += jump(N, K - 1, r - 1, c - 2);
        total += jump(N, K - 1, r + 1, c - 2);
        total += jump(N, K - 1, r - 1, c + 2);
        total += jump(N, K - 1, r + 1, c + 2);
        total /= 8;
        cache[r][c][K] = total;
        return total;
    }
}
```

```java
class Solution {
int[][] dir = new int[][]{{-1, -2}, {-2, -1}, {-2, 1}, {-1, 2}, {1, -2}, {2, -1}, {2, 1}, {1, 2}};
    double[][][] cache;
    public double knightProbability(int N, int K, int r, int c) {
        cache = new double[N][N][K + 1];
        return dfs(r, c, N, K);
    }
    private double dfs(int r, int c, int N, int K) {
        if (K == 0) return 1;
        if (cache[r][c][K] != 0) return cache[r][c][K];
        double res = 0;
        for (int i = 0; i < 8; i++) {
            int x = dir[i][0] + r;
            int y = dir[i][1] + c;
            if (x < 0 || x >= N || y < 0 || y >= N) continue;
            res += dfs(x, y, N, K - 1) / 8;
        }
        cache[r][c][K] = res;
        return res;
    }
}
```







#### [576. 出界的路径数](https://leetcode-cn.com/problems/out-of-boundary-paths/)

![image-20200514204334066](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200514204334066.png)

![image-20200514204454956](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200514204454956.png)

![image-20200514204718905](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200514204718905.png)

![image-20200514204754757](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200514204754757.png)

```c
class Solution {
    public int findPaths(int m, int n, int N, int p, int q) {
        int MOD = 1000000007;
        if(N==0) return 0;
        long[][][] dp = new long[m+2][n+2][N+1];
        for (int i = 0; i <= m + 1; i++) {//初始化数组左右两列
		    dp[i][0][0] = 1;
		    dp[i][n + 1][0] = 1;
	    }
        for (int i = 0; i <= n + 1; i++) {//初始化数组上下两行
		    dp[0][i][0] = 1;
		    dp[m + 1][i][0] = 1;
	    }
        for (int k = 1; k <= N; k++) {
            for (int i = 1; i <= m; i++) {
                for (int j = 1; j <= n; j++) {
                    dp[i][j][k] = (dp[i - 1][j][k - 1] + dp[i + 1][j][k - 1] + 
                                    dp[i][j - 1][k - 1] + dp[i][j + 1][k - 1]) % MOD;
                }
            }
	    }
        int sum = 0;
        for (int k = 1; k <= N; k++) {
            sum =(int) ((sum + dp[p + 1][q + 1][k]) % MOD);
        }
        return sum;
    }
}

```

记忆化dfs

```java
import java.util.*;
class Solution {
    int [][][] dp;//dp[i][j][k]代表 在(i,j)节点还能走K步的状态下，路径的数目
    int [] dx = {-1,0,1,0};
    int [] dy = {0,1,0,-1};
    int rows,cols;
    int mod = 1000000007;
    public int findPaths(int m, int n, int N, int i, int j) {
        rows = m;
        cols = n;
        dp = new int [m][n][N + 1];
        for(int q = 0 ;q < m ;q++)
            for(int p = 0 ;p < n ;p++)
                for(int k = 0 ;k < N + 1 ;k++){
                    dp[q][p][k] = -1;
                }
        return dfs(i,j,N);
    }
    private int dfs(int x,int y,int k){
        
        if(dp[x][y][k] != -1) return dp[x][y][k];//记忆化搜索
        
        dp[x][y][k] = 0;//给初始每个节点赋初值
        if(k == 0) return dp[x][y][k];//走完步数还没到边界，那么直接返回当前节点走出数量
        for(int i = 0 ;i < 4 ;i++){
            int a = x + dx[i];
            int b = y + dy[i];
            if(a < 0 || a >= rows || b < 0 || b >= cols) dp[x][y][k]++;//当前节点上下左右能走出边界则方案数 + 1
            else dp[x][y][k] += dfs(a,b,k - 1);//不能则继续往下个节点搜索，步数 - 1
            dp[x][y][k] %= mod;
        }
        return dp[x][y][k];
    }
}

```

```java
class Solution {
    int[][][] dp;// dp[i][j][N]表示用K步可以将球从（i,j）位置移出边界的路径数量。
    int mod = (int)Math.pow(10,9) + 7;
    public int findPaths(int m, int n, int N, int i, int j) {
        dp = new int[m][n][N];
        return dfs(m,n,N,i,j);

    }
    int dfs(int m, int n, int N, int i,int j){
        //判断是否出界了，如果出界了就返回1
        if( i < 0 || i >= m || j < 0 || j >= n){
            return 1;
        }
        //如果步数用完了，就返回0
        if(N == 0){
            return 0;
        }
        // 剪枝，如果这一个点计算过了，而且这点的值记录在了dp[i][j][N - 1]中
        if(dp[i][j][N - 1] > 0){
            return dp[i][j][N - 1] - 1;//这里的dp[i][j][N]=dp[i][j][N-1]-1是自己定义的，与实际无关，只是为了实现记忆化
        }
        int ret = 0;
        // dp[i][j][N]就等于下面四个的和，每次有四个方向可以走。
        ret = (ret + dfs(m, n, N - 1, i - 1, j)) % mod;
        ret = (ret + dfs(m, n, N - 1, i + 1, j)) % mod;
        ret = (ret + dfs(m, n, N - 1, i, j - 1)) % mod;
        ret = (ret + dfs(m, n, N - 1, i, j + 1)) % mod;
        dp[i][j][N - 1] = ret + 1;//这里定义dp[i][j][N-1]=dp[i][j][N]+1，因为N是递减的，每一次可能回到(i,j)点，但是N不可能相同。再解释这里为什么要加上一个正数，因为初始值都为0，加上正数之后它一定是大于0的了，这就代表着dp[i][j][N]已经被访问过了，所以这里可以随意加上一个正数。
        return ret;
    }
}
```



### 区间问题



#### [1039. 多边形三角剖分的最低得分](https://leetcode-cn.com/problems/minimum-score-triangulation-of-polygon/)



![image-20200515210357947](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200515210357947.png)

![image-20200515213327419](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200515213327419.png)

```java
//环形的结构
public int minScoreTriangulation(int[] A) {
    if(A==null || A.length<=0) return 0;
    int N=A.length;
    //从 0 ~ N-1 形成一个环
    //    1—3 
    //   /    \
    //  5      1
    //   \    /
    //    1—4
    // dp[left][right] 代表left~right区间形成的环的最小得分值
    int[][] dp=new int[N][N];//这里初始化了数组全部为0
    for (int len=3;len<=N;len++) { //枚举长度,从3开始
        for (int left=0;left<=N-len;left++) { //枚举左端点
            //left+len-1<N
            int right=left+len-1;
            //init
            dp[left][right]=Integer.MAX_VALUE;//这里当找到该长度的区间时候，将它变为最大
            for (int i=left+1;i<right;i++) { //枚举区间内的所有的点(不包括端点)),将环分割成左右两部分
                dp[left][right]=Math.min(dp[left][right],dp[left][i]+dp[i][right]+A[i]*A[left]*A[right]);
            }
            //当i=left+1时，dp[left][i]没有被更改过，还是0
            //当左右节点和中间一个节点，会将环形划分成三个区域，所以dp[left][i]+dp[i][right]+A[i]*A[left]*A[right]
        }
    }
    return dp[0][N-1];
}

```

#### 回文字符串

给定一个字符串，你的任务是计算这个字符串中有多少个回文子串（回文串是一个正读和反读都一样的字符串）。

具有不同开始位置或结束位置的回文串，即使是由相同的字符组成，也会被计为是不同的子串。

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        String str = sc.next();
        int length = str.length();
        char[] c = str.toCharArray();
        int[][] dp = new int[length][length];
        for(int i=0;i<length;i++){
            dp[i][i] = 1;
        }
        int max = length;
        for(int j=1;j<length;j++){
            for(int i=0;i<j;i++){
                if(c[i]==c[j]){
                    if(j-i<=2){
                        dp[i][j] = 1;
                    }else{
                        dp[i][j] = dp[i+1][j-1];
                    }
                }
                max+=dp[i][j];
            }
        }
        System.out.println(max);
         
    }
}
```













## 深度优先搜索



递归方法实现遍历

```java
//先序遍历
public void preOrderRecur(Node head){
    if(head==null){
        return;
    }
    System.out.println(head.value+" ");
    preOrderRecur(head.left);
    preOrderRecur(head.right);
}
//中序遍历
public void inOrderRecur(Node head){
    if(head==null){
        return;
    }
    inOrderRecur(head.left);
    System.out.print(head.value+" ");
    inOrderRecur(head.right);
}

//后序遍历
public void posOrderRecur(Node head){
    if(head==null){
        return;
    }
    posOrderRecur(head.left);
    posOrderRecur(head.right);
    System.out.print(head.value+" ");
}
```





```java
 
    public void theFirstTraversal_Stack(Node root) {  //先序遍历  
        Stack<Node> stack = new Stack<Node>();  
        Node node = root;  
        while (node != null || stack.size() > 0) {  //将所有左孩子压栈  
            if (node != null) {   //压栈之前先访问  
                printNode(node);  //做相关操作
                stack.push(node);  
                node = node.getLeftNode();  
            } else {  
                node = stack.pop();  
                node = node.getRightNode();  
            }  
        }  
    }  
      
    public void theInOrderTraversal_Stack(Node root) {  //中序遍历  
        Stack<Node> stack = new Stack<Node>();  
        Node node = root;  
        while (node != null || stack.size() > 0) {  
            if (node != null) {  
                stack.push(node);   //直接压栈  
                node = node.getLeftNode();  
            } else {  
                node = stack.pop(); //出栈并访问  
                printNode(node);  
                node = node.getRightNode(); 
            }  
        }  
    }  

      
    public void thePostOrderTraversal_Stack(Node root) {   //后序遍历  
        Stack<Node> stack = new Stack<Node>();  
        Stack<Node> output = new Stack<Node>();//构造一个中间栈来存储逆后序遍历的结果  
        Node node = root;  
        while (node != null || stack.size() > 0) {  
            if (node != null) {  
                output.push(node);  
                stack.push(node);                 
                node = node.getRightNode();  
            } else {  
                node = stack.pop();               
                node = node.getLeftNode();
            }  
        }  
        System.out.println(output.size());
        while (output.size() > 0) {
            
            printNode(output.pop());  
        }  
    }

//层次遍历，先将根节点入队，当前节点是队头节点，将其出队并访问，如果当前节点的左节点不为空将左节点入队，如果当前节点的右节点不为空将其入队。所以出队顺序也是从左到右依次出队。
  public void levelIterator(BiTree root)
  {
	  if(root == null)
	  {
		  return ;
	  }
	  LinkedList<BiTree> queue = new LinkedList<BiTree>();
	  BiTree current = null;
	  queue.offer(root);//将根节点入队
	  while(!queue.isEmpty())
	  {
		  current = queue.poll();//出队队头元素并访问
		  System.out.print(current.val +"-->");
		  if(current.left != null)//如果当前节点的左节点不为空入队
		  {
			  queue.offer(current.left);
		  }
		  if(current.right != null)//如果当前节点的右节点不为空，把右节点入队
		  {
			  queue.offer(current.right);
		  }
	  }
	  
  }

//层次遍历，分层输出
public class Solution {
    ArrayList<ArrayList<Integer> > Print(TreeNode pRoot) {
        ArrayList<ArrayList<Integer>> ret = new ArrayList<ArrayList<Integer>>();
        ArrayList<Integer> tmp = new ArrayList<Integer>();
        LinkedList<TreeNode> q = new LinkedList<TreeNode>();
        if(pRoot == null)
            return ret;
        q.add(pRoot);
        int now = 1, next = 0;
        while(!q.isEmpty()) {
            TreeNode t = q.remove();
            now--;
            tmp.add(t.val);
            if(t.left != null) {
                q.add(t.left);
                next++;
            }
            if(t.right != null) {
                q.add(t.right);
                next++;
            }
            if(now == 0) {
                ret.add(new ArrayList<Integer>(tmp));
                tmp.clear();
                now = next;
                next = 0;
            }
        }
        return ret;
    }
             
}

class Solution {

    private List<List<Integer>> result = new ArrayList<>();

    public List<List<Integer>> levelOrder(TreeNode root) {
        visit(root, 0);
        return result;
    }

    private void visit(TreeNode node, int current){
        if (node == null) {
            current--;
            return;
        }
        if (result.size() == current) result.add(new ArrayList<>());
        result.get(current).add(node.val);
        visit(node.left, current + 1);
        visit(node.right, current + 1);
        current--;
        return;
    }

}


// 二维数组转ArrayList
Integer[][] arr = new Integer[3][3];
         for(int i = 0;i < 3;i++){
             for(int j =0;j < 3;j++){
                 arr[i][j] = i;
             }
         }
          
         List<List<Integer>> list = new ArrayList<List<Integer>>();
         for(int i = 0;i < 3;i++){
             list.add((List<Integer>)Arrays.asList(arr[i]));
         }
```

请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。

```java
import java.util.*;
public class Solution {
    public ArrayList<ArrayList<Integer> > Print(TreeNode pRoot) {
           ArrayList<ArrayList<Integer>> aList=new ArrayList<ArrayList<Integer>>();
           if(pRoot==null)
               return aList;
            
           Stack<TreeNode> s1=new Stack<TreeNode>();
           s1.add(pRoot);
           Stack<TreeNode> s2=new Stack<TreeNode>();
           while(!s1.isEmpty()||!s2.isEmpty()){
               if(!s1.isEmpty()){
                   ArrayList<Integer> aList2=new ArrayList<Integer>();
                   while(!s1.isEmpty()){
                       TreeNode p=s1.pop();
                       aList2.add(p.val);
                       if(p.left!=null)
                           s2.add(p.left);
                       if(p.right!=null)
                           s2.add(p.right);
                   }
               aList.add(aList2);
                
               }
               else {
                   ArrayList<Integer> aList2=new ArrayList<Integer>();
                   while(!s2.isEmpty()){
                   
                       TreeNode p=s2.pop();
                       if(p.right!=null)
                           s1.add(p.right);
                       if(p.left!=null)
                           s1.add(p.left);
                       aList2.add(p.val);
                    
                   }
                   aList.add(aList2);
               }
           }
           return aList;
    }
 
}

```



#### [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)

![image-20200529091931846](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200529091931846.png)

递归方法

```java
class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        return helper(root,sum);

    }
    
    public boolean helper(TreeNode root,int sum){
        if(root==null){
            return false;
        }
        if(root.right==null && root.left==null){
            return ((sum-root.val )==0);
        }
        return helper(root.left,sum-root.val) || helper(root.right,sum-root.val);
        
    }
}
```

迭代方法

```java
class Solution {
  public boolean hasPathSum(TreeNode root, int sum) {
    if (root == null)
      return false;

    LinkedList<TreeNode> node_stack = new LinkedList();
    LinkedList<Integer> sum_stack = new LinkedList();
    node_stack.add(root);
    sum_stack.add(sum - root.val);

    TreeNode node;
    int curr_sum;
    while ( !node_stack.isEmpty() ) {
      node = node_stack.pollLast();
      curr_sum = sum_stack.pollLast();
      if ((node.right == null) && (node.left == null) && (curr_sum == 0))
        return true;

      if (node.right != null) {
        node_stack.add(node.right);
        sum_stack.add(curr_sum - node.right.val);
      }
      if (node.left != null) {
        node_stack.add(node.left);
        sum_stack.add(curr_sum - node.left.val);
      }
    }
    return false;
  }
}

```

#### [113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)

![image-20200529145727965](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200529145727965.png)



```java
class Solution {
    public List<List<Integer>> pathSum(TreeNode root, int sum) {
        List<List<Integer>> res = new ArrayList<>();
        helper(root, sum, res, new ArrayList<Integer>());
        return res;
    }

    private void helper(TreeNode root, int sum, List<List<Integer>> res, ArrayList<Integer> tmp) {
        if (root == null) return;
        tmp.add(root.val);
        if (root.left == null && root.right == null && sum - root.val == 0)
             res.add(new ArrayList<>(tmp));
        helper(root.left, sum - root.val, res, tmp);
        helper(root.right, sum - root.val, res, tmp);
        tmp.remove(tmp.size() - 1);//回溯算法
    }
}

```

#### 根据先序和中序构造二叉树

思考：如何才能确定一棵树？
结论：    通过中序遍历和先序遍历可以确定一个树
                通过中序遍历和后续遍历可以确定一个树
                通过先序遍历和后序遍历确定不了一个树。
单独先序遍历：能求解根，但不能求解左子树什么时候结束、右子树什么时候开始。


根据先序和中序结果画树

算法
1.根据前序序列的第一个节点确定根节点

2.根据根节点在中序序列中的位置分割出左右两个子序列

3.对左子树和右子树分别递归方法继续分解

```java
链接：https://www.nowcoder.com/questionTerminal/8a19cbe657394eeaac2f6ea9b0f6fcf6?answerType=1&f=discussion
来源：牛客网

import java.util.Arrays;
public class Solution {
    public TreeNode reConstructBinaryTree(int [] pre,int [] in) {
        if (pre.length == 0 || in.length == 0) {
            return null;
        }
        TreeNode root = new TreeNode(pre[0]);
        // 在中序中找到前序的根
        for (int i = 0; i < in.length; i++) {
            if (in[i] == pre[0]) {
                // 左子树，注意 copyOfRange 函数，左闭右开
                root.left = reConstructBinaryTree(Arrays.copyOfRange(pre, 1, i + 1), Arrays.copyOfRange(in, 0, i));
                // 右子树，注意 copyOfRange 函数，左闭右开
                root.right = reConstructBinaryTree(Arrays.copyOfRange(pre, i + 1, pre.length), Arrays.copyOfRange(in, i + 1, in.length));
                break;
            }
        }
        return root;
    }
}
```







#### 检查平衡树

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isBalanced(TreeNode root) {
        if (root == null)
            return true;
        //拿到节点的左子树和右子树的深度
        int deptLeft = getDept(root.left, 0);
        int deptRight = getDept(root.right, 0);
        //如果相差大于1，那么不是一颗平衡树
        if (Math.abs(deptLeft - deptRight) > 1)
            return false;
        //递归检查这个节点的左子节点和右子节点
        return isBalanced(root.left) && isBalanced(root.right);
    }
    //获取从某个节点开始的深度
    private int getDept(TreeNode root, int dept) {
        if (root == null)
            return dept;
        int deptLeft = getDept(root.left, dept + 1);
        int deptRight = getDept(root.right, dept + 1);
        
        return Math.max(deptLeft, deptRight);
    }
}

```

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isBalanced(TreeNode root) {
          
          return dfs(root);
    }
    private  boolean dfs(TreeNode node){
        if (node == null){
            return true;
        }
        if (Math.abs(depth(node.left)-depth(node.right))>1){
              return false;
        }
       
        return dfs(node.right) && dfs(node.left);
    }
    private int depth(TreeNode node){
          if (node==null)
              return 0;
          return Math.max(depth(node.left),depth(node.right))+1;
    }
}

```



```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    //定义变量减枝
    boolean isBalance = true;
    public boolean isBalanced(TreeNode root) {
        if(root==null){
            return true;
        }
        getDepth(root);
        return isBalance;
    }
    private int getDepth(TreeNode node){
        //如果已经找到不平衡的树枝，不需要递归，直接返回
        if(!isBalance){
            return 0;
        }
        if(node == null){
            return 0;
        }
        int left = getDepth(node.left);
        int rignt = getDepth(node.right);
        //判断左右树枝是否平衡，如果不平衡更新减枝变量
        if(Math.abs(left-rignt)>1){
            isBalance = false;
        }
        return Math.max(left,rignt)+1;
    }
}

```



#### 检查是否是二叉搜索树

利用递归找到左边的最大值，右边的最小值

```java
class Solution {
    public boolean isValidBST(TreeNode root) {
        if (root == null) return true;
        TreeNode maxLeft = root.left, minRight = root.right;
        // 找寻左子树中的最右（数值最大）节点
        while (maxLeft != null && maxLeft.right != null)
            maxLeft = maxLeft.right;
        // 找寻右子树中的最左（数值最小）节点
        while (minRight != null && minRight.left != null)
            minRight = minRight.left;
        // 当前层是否合法
        boolean ret = (maxLeft == null || maxLeft.val < root.val) && (minRight == null || root.val < minRight.val);
        // 进入左子树和右子树并判断是否合法
        return  ret && isValidBST(root.left) && isValidBST(root.right);
    }
}

```

中序遍历，然后加一个o(n)的判断是否为递增数组

```java
public boolean isValidBST(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        helper(root,list);
        for (int i = 0; i < list.size()-1 ; i++) {
            if(list.get(i) >= list.get(i+1)){
                return false;
            }
        }
        return true;
    }
    public void helper(TreeNode root, List<Integer> list){
        if(root != null){
            if(root.left != null){
                helper(root.left,list);
            }
            list.add(root.val);
            if(root.right!= null){
                helper(root.right,list);
            }
        }
    }


```



```java
class Solution {

   private boolean satisify = true;
	
	private TreeNode pre = null;
	
    private TreeNode isValid(TreeNode root) {
        if( root == null) {
            return null;
        }
        TreeNode left = isValid(root.left);
        if(pre != null && pre.val >= root.val) {
        	satisify = false;
        }
        pre = root;
        TreeNode right = isValid(root.right);
        return root;
    }

    public boolean isValidBST(TreeNode root) {
        isValid(root);
        return satisify;
    }
}
```

#### 对称的二叉树

请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。

/*
\* **DFS使用stack**来保存成对的节点

\* 1.**出栈**的时候也是**成对**成对的 ，

1.若都为空，继续；

2.一个为空，返回false;

3.不为空，比较当前值，值不等，返回false；

\* 2.确定入栈顺序，每次**入栈**都是成对**成对**的，如left.left， right.right ;left.rigth,right.left

```java
import java.util.*;
public class Solution {
    boolean isSymmetrical(TreeNode pRoot)
    {
        if(pRoot == null) return true;
        Stack<TreeNode> s = new Stack<>();
        s.push(pRoot.left);
        s.push(pRoot.right);
        while(!s.empty()) {
            TreeNode right = s.pop();//成对取出
            TreeNode left = s.pop();
            if(left == null && right == null) continue;
            if(left == null || right == null) return false;
            if(left.val != right.val) return false;
            //成对插入
            s.push(left.left);
            s.push(right.right);
            s.push(left.right);
            s.push(right.left);
        }
        return true;
    }
}
```



#### 二叉树的下一个结点

给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。



```java
public class Solution {
    TreeLinkNode GetNext(TreeLinkNode node)
    {
        if(node==null) return null;
        if(node.right!=null){    //如果有右子树，则找右子树的最左节点
            node = node.right;
            while(node.left!=null) node = node.left;
            return node;
        }
        while(node.next!=null){ //没右子树，则找第一个当前节点是父节点左孩子的节点
            if(node.next.left==node) return node.next;
            node = node.next;
        }
        return null;   //退到了根节点仍没找到，则返回null
    }
}
```

#### Z字形打印二叉树

```java
import java.util.ArrayList;

/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
import java.util.*;
public class Solution {
    public ArrayList<ArrayList<Integer> > Print(TreeNode pRoot) {
           ArrayList<ArrayList<Integer>> aList=new ArrayList<ArrayList<Integer>>();
           if(pRoot==null)
               return aList;
            
           Stack<TreeNode> s1=new Stack<TreeNode>();
           s1.add(pRoot);
           Stack<TreeNode> s2=new Stack<TreeNode>();
           while(!s1.isEmpty()||!s2.isEmpty()){
               if(!s1.isEmpty()){
                   ArrayList<Integer> aList2=new ArrayList<Integer>();
                   while(!s1.isEmpty()){
                       TreeNode p=s1.pop();
                       aList2.add(p.val);
                       if(p.left!=null)
                           s2.add(p.left);
                       if(p.right!=null)
                           s2.add(p.right);
                   }
               aList.add(aList2);
                
               }
               else {
                   ArrayList<Integer> aList2=new ArrayList<Integer>();
                   while(!s2.isEmpty()){
                   
                       TreeNode p=s2.pop();
                       if(p.right!=null)
                           s1.add(p.right);
                       if(p.left!=null)
                           s1.add(p.left);
                       aList2.add(p.val);
                    
                   }
                   aList.add(aList2);
               }
           }
           return aList;
    }
 
}

```





#### 删除链表中重复的结点

在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1->2->3->3->4->4->5 处理后为 1->2->5

要处理一个很棘手的问题：当头结点重复的时候，删除头结点。（脑壳疼）

```java


public class Solution {
    public ListNode deleteDuplication(ListNode pHead) {
        if (pHead == null || pHead.next == null) {
            return pHead;
        }

        ListNode head = new ListNode(-1); // 新建一个头结点，防止链表中头结点是重复节点被删除。
        ListNode trail = head;

        while (pHead != null) {
            ListNode node = pHead.next;
            boolean flag = false;
            while (node != null && pHead.val == node.val) {
                node = node.next;
                flag = true;
            }
            if (!flag) {
                trail.next = pHead;
                trail = trail.next;
            }
            pHead = node;
        }
        trail.next = null; // 1->2->3->3->3
        return head.next;
    }
}
```









#### [面试题 04.06. 后继者](https://leetcode-cn.com/problems/successor-lcci/)

![image-20200519232535827](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200519232535827.png)

```java
class Solution {
    List<TreeNode> list = new ArrayList<>();
    public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {
        helper(root,list);
        for(int i=0;i<list.size()-1;i++){
            if(list.get(i)==p){
                return list.get(i+1);
            }
        }
        return null;

    }
    private void helper(TreeNode root,List<TreeNode> list){
        if(root!=null){
            if(root.left!=null){
                helper(root.left,list);
            }
            list.add(root);
            if(root.right != null){
                helper(root.right,list);
            }
        }
    }

}
```

如果是有返回值的递归方法，要注意最后的return语句，中间很多return语句是在if里面的，所以需要一个flag作为开关。中间不返回。

```java
class Solution {
    boolean flag = false;
    TreeNode ret;
    public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {
        if(root!=null){
            if(root.left!=null){
                 inorderSuccessor(root.left,p);
            }
            if(root == p){
                flag = true;
               
            }else if(flag){
                ret = root;
                flag = false;
            }
            if(root.right!=null){
                 inorderSuccessor(root.right,p);
            }
        }
        return  ret;
    }
}
```





#### [207. 课程表](https://leetcode-cn.com/problems/course-schedule/)

![image-20200526201528637](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200526201528637.png)

\

![image-20200526202455278](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200526202455278.png)

![img](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/90794a4bf4034a277621d9ca33f2df25c40f7ff0d9d47044396c44d166920a99-Picture1.png)

![img](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/bd2f99fca16bd3a626153945a28ea8a75b151e6404d5525ad30202e19caab05c-Picture2.png)

![img](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/cb061aa43f1fcd9ca23069a5712a58a5ace8636deaaab3e1536d14d173b0cdde-Picture3.png)

![img](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/b907e91e670a0a077154f0b7b2a483f19cd6952f790ed2f1a3bab9ce389ca408-Picture6.png)

```java
class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        //入度，即每门课的前置课程有几个
        int[] indegrees = new int[numCourses];
        //邻接表
        List<List<Integer>> adjacency = new ArrayList<>();
        //记录下次可以访问的节点
        Queue<Integer> queue = new LinkedList<>();
        for(int i = 0; i < numCourses; i++)
            adjacency.add(new ArrayList<>());
        // Get the indegree and adjacency of every course.
        for(int[] cp : prerequisites) {
            indegrees[cp[0]]++;//入度＋＋
            adjacency.get(cp[1]).add(cp[0]);//这个节点相邻的下一个节点
        }
        // Get all the courses with the indegree of 0.
        //把入度为０的课加入队列
        for(int i = 0; i < numCourses; i++)
            if(indegrees[i] == 0) queue.add(i);
        // BFS TopSort.
        
        while(!queue.isEmpty()) {
            int pre = queue.poll();
            numCourses--;
            for(int cur : adjacency.get(pre))//pre这门课结束后可以选择的课程
                if(--indegrees[cur] == 0) queue.add(cur);//如果可选择的课程中减去当前课程的入度之后，入度为０，就可以选择它，将它放到队列中。
        }
        return numCourses == 0;//按照拓扑排序，能否将所有元素走完
    }
}

```

![image-20200526204306957](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200526204306957.png)

```java
class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        List<List<Integer>> adjacency = new ArrayList<>();
        for(int i = 0; i < numCourses; i++)
            adjacency.add(new ArrayList<>());
        int[] flags = new int[numCourses];
        for(int[] cp : prerequisites)
            adjacency.get(cp[1]).add(cp[0]);
        for(int i = 0; i < numCourses; i++)
            if(!dfs(adjacency, flags, i)) return false;
        return true;
    }
    private boolean dfs(List<List<Integer>> adjacency, int[] flags, int i) {
        if(flags[i] == 1) return false;
        if(flags[i] == -1) return true;
        flags[i] = 1;
        for(Integer j : adjacency.get(i))
            if(!dfs(adjacency, flags, j)) return false;
        flags[i] = -1;
        return true;
    }
}

作者：jyd
链接：https://leetcode-cn.com/problems/course-schedule/solution/course-schedule-tuo-bu-pai-xu-bfsdfsliang-chong-fa/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



```java
class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        if(prerequisites==null || prerequisites.length==0) return true;

        //构建图
        Node[] graph=new Node[numCourses];
        for(int[] plan:prerequisites){
            //头插法
            graph[plan[0]]=new Node(plan[1],graph[plan[0]]);
        }
        //判断是否存在环
        int[] visited=new int[numCourses];
        for(int i=0;i<numCourses;i++){
            //未遍历则遍历，如果存在环，则不符合要求
            if(visited[i]!=-1 && !isDAG(i,graph,visited)) return false;
            //遍历完成，以i出发不存在环路，置为访问且无环
            visited[i]=-1;
        }
        return true;
    }

    private boolean isDAG(int start,Node[] graph,int[] visited){
        //置为正在遍历
        visited[start]=1;
        Node temp=graph[start];
        while(temp!=null){
            //之前已经遍历过，无环
            if(visited[temp.val]==-1){
                temp=temp.next;
                continue;
            }
            //存在回路
            if(visited[temp.val]==1 || !isDAG(temp.val,graph,visited)) return false;
            //遍历结束，置为已访问且无环
            visited[temp.val]=-1;
            temp=temp.next;
        }
        return true;
    }


class Node{
    int val;
    Node next;

    Node(int val){
        this.val=val;
    }

    Node(int val,Node next){
        this.val=val;
        this.next=next;
    }
}
}
```

#### [1391. 检查网格中是否存在有效路径](https://leetcode-cn.com/problems/check-if-there-is-a-valid-path-in-a-grid/)



![image-20200527194444250](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200527194444250.png)

![image-20200527194503293](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200527194503293.png)

![image-20200527194524248](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200527194524248.png)



#### [108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)

![image-20200527213822960](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200527213822960.png)

![image-20200527213854356](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200527213854356.png)

```java
class Solution {
  int[] nums;

  public TreeNode helper(int left, int right) {
    if (left > right) return null;

    // always choose left middle node as a root
    int p = (left + right) / 2;

    // inorder traversal: left -> node -> right
    TreeNode root = new TreeNode(nums[p]);
    root.left = helper(left, p - 1);
    root.right = helper(p + 1, right);
    return root;
  }

  public TreeNode sortedArrayToBST(int[] nums) {
    this.nums = nums;
    return helper(0, nums.length - 1);
  }
}

```

#### [109. 有序链表转换二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/)

![image-20200527215026006](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200527215026006.png)

给定列表中的中间元素将会作为二叉搜索树的根，该点左侧的所有元素递归的去构造左子树，同理右侧的元素构造右子树。这必然能够保证最后构造出的二叉搜索树是平衡的。

![image-20200527220235157](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200527220235157.png)

```java
/**
 * Definition for singly-linked list. public class ListNode { int val; ListNode next; ListNode(int
 * x) { val = x; } }
 */
/**
 * Definition for a binary tree node. public class TreeNode { int val; TreeNode left; TreeNode
 * right; TreeNode(int x) { val = x; } }
 */
class Solution {

  private ListNode findMiddleElement(ListNode head) {

  
    ListNode prevPtr = null;
    ListNode slowPtr = head;
    ListNode fastPtr = head;

    while (fastPtr != null && fastPtr.next != null) {
      prevPtr = slowPtr;
      slowPtr = slowPtr.next;
      fastPtr = fastPtr.next.next;
    }

    if (prevPtr != null) {
      prevPtr.next = null;
    }

    return slowPtr;
  }

  public TreeNode sortedListToBST(ListNode head) {

 
    if (head == null) {
      return null;
    }

    ListNode mid = this.findMiddleElement(head);
    TreeNode node = new TreeNode(mid.val);
    if (head == mid) {
      return node;
    }
    node.left = this.sortedListToBST(head);
    node.right = this.sortedListToBST(mid.next);
    return node;
  }
}

作者：LeetCode
链接：https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/solution/you-xu-lian-biao-zhuan-huan-er-cha-sou-suo-shu-by-/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

![image-20200527230946583](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200527230946583.png)



```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    ListNode head;
   int[] nums;
    public TreeNode sortedListToBST(ListNode head) {
        this.head = head;
        ListNode pre = head;
        int n=0;
        while(pre!=null){
            n++;
            pre = pre.next;
        }
        nums = new int[n];
        int i=0;
        while(head!=null){
            nums[i]= head.val;
            head=head.next;
            i++;
        }

        return helper(0,n-1);


        //转换为数组
        
        
    }
    public TreeNode helper(int left,int right){
        if(left>right){
            return null;
        }
        int p = (left+right)/2;
        TreeNode root = new TreeNode(nums[p]);
        root.left=helper(left,p-1);
        root.right = helper(p+1,right);
        return root;
    }
   

}
```

![image-20200527233324403](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200527233324403.png)

![image-20200527233337116](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200527233337116.png)

```java
/**
 * Definition for singly-linked list. public class ListNode { int val; ListNode next; ListNode(int
 * x) { val = x; } }
 */
/**
 * Definition for a binary tree node. public class TreeNode { int val; TreeNode left; TreeNode
 * right; TreeNode(int x) { val = x; } }
 */
class Solution {

  private ListNode head;

  private int findSize(ListNode head) {
    ListNode ptr = head;
    int c = 0;
    while (ptr != null) {
      ptr = ptr.next;  
      c += 1;
    }
    return c;
  }

  private TreeNode convertListToBST(int l, int r) {
    // Invalid case
    if (l > r) {
      return null;
    }

    int mid = (l + r) / 2;

    // First step of simulated inorder traversal. Recursively form
    // the left half
    TreeNode left = this.convertListToBST(l, mid - 1);

    // Once left half is traversed, process the current node
    TreeNode node = new TreeNode(this.head.val);
    node.left = left;

    // Maintain the invariance mentioned in the algorithm
    this.head = this.head.next;

    // Recurse on the right hand side and form BST out of them
    node.right = this.convertListToBST(mid + 1, r);
    return node;
  }

  public TreeNode sortedListToBST(ListNode head) {
    // Get the size of the linked list first
    int size = this.findSize(head);

    this.head = head;

    // Form the BST now that we know the size
    return convertListToBST(0, size - 1);
  }
}

作者：LeetCode
链接：https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/solution/you-xu-lian-biao-zhuan-huan-er-cha-sou-suo-shu-by-/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



#### [743. 网络延迟时间](https://leetcode-cn.com/problems/network-delay-time/)

![image-20200528211617146](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200528211617146.png)

![image-20200528211705082](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200528211705082.png)

```java
class Solution {
    Map<Integer, Integer> dist;
    public int networkDelayTime(int[][] times, int N, int K) {
        Map<Integer, List<int[]>> graph = new HashMap();
        for (int[] edge: times) {
            if (!graph.containsKey(edge[0]))
                graph.put(edge[0], new ArrayList<int[]>());
            graph.get(edge[0]).add(new int[]{edge[2], edge[1]});
        }
        for (int node: graph.keySet()) {
            Collections.sort(graph.get(node), (a, b) -> a[0] - b[0]);
        }
        dist = new HashMap();
        for (int node = 1; node <= N; ++node)
            dist.put(node, Integer.MAX_VALUE);

        dfs(graph, K, 0);
        int ans = 0;
        for (int cand: dist.values()) {
            if (cand == Integer.MAX_VALUE) return -1;
            ans = Math.max(ans, cand);
        }
        return ans;
    }

    public void dfs(Map<Integer, List<int[]>> graph, int node, int elapsed) {
        if (elapsed >= dist.get(node)) return;
        dist.put(node, elapsed);
        if (graph.containsKey(node))
            for (int[] info: graph.get(node))
                dfs(graph, info[1], elapsed + info[0]);
    }
}

```

![image-20200528211744050](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200528211744050.png)

![image-20200528212804300](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200528212804300.png)

```java
class Solution {
    Map<Integer, Integer> dist;//用来存放到每个点的距离
    public int networkDelayTime(int[][] times, int N, int K) {
        //构造图
        Map<Integer, List<int[]>> graph = new HashMap();
        for (int[] edge: times) {
            if (!graph.containsKey(edge[0]))
                graph.put(edge[0], new ArrayList<int[]>());
            graph.get(edge[0]).add(new int[]{edge[1], edge[2]});
        }
        
        dist = new HashMap();
        for (int node = 1; node <= N; ++node)
            dist.put(node, Integer.MAX_VALUE);//初始化距离为最大值
        dist.put(K, 0);
        
        
        boolean[] seen = new boolean[N+1];

        while (true) {
            int candNode = -1;
            int candDist = Integer.MAX_VALUE;
            for (int i = 1; i <= N; ++i) {
                if (!seen[i] && dist.get(i) < candDist) {
                    candDist = dist.get(i);
                    candNode = i;
                }
            }

            if (candNode < 0) break;
            seen[candNode] = true;
            if (graph.containsKey(candNode))
                for (int[] info: graph.get(candNode))
                    dist.put(info[0],
                             Math.min(dist.get(info[0]), dist.get(candNode) + info[1]));
        }

        int ans = 0;
        for (int cand: dist.values()) {
            if (cand == Integer.MAX_VALUE) return -1;
            ans = Math.max(ans, cand);
        }
        return ans;
    }
}
```

堆实现

```java
class Solution {
    public int networkDelayTime(int[][] times, int N, int K) {
        Map<Integer, List<int[]>> graph = new HashMap();
        for (int[] edge: times) {
            if (!graph.containsKey(edge[0]))
                graph.put(edge[0], new ArrayList<int[]>());
            graph.get(edge[0]).add(new int[]{edge[1], edge[2]});
        }
        PriorityQueue<int[]> heap = new PriorityQueue<int[]>(
                (info1, info2) -> info1[0] - info2[0]);
        heap.offer(new int[]{0, K});

        Map<Integer, Integer> dist = new HashMap();

        while (!heap.isEmpty()) {
            int[] info = heap.poll();
            int d = info[0], node = info[1];
            if (dist.containsKey(node)) continue;
            dist.put(node, d);
            if (graph.containsKey(node))
                for (int[] edge: graph.get(node)) {
                    int nei = edge[0], d2 = edge[1];
                    if (!dist.containsKey(nei))
                        heap.offer(new int[]{d+d2, nei});
                }
        }

        if (dist.size() != N) return -1;
        int ans = 0;
        for (int cand: dist.values())
            ans = Math.max(ans, cand);
        return ans;
    }
```

![image-20200528213206806](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200528213206806.png)

#### [114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)



![image-20200528222426314](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200528222426314.png)

```java
class Solution {
    public void flatten(TreeNode root) {
        if(root == null){
            return ;
        }
        //将根节点的左子树变成链表
        flatten(root.left);
        //将根节点的右子树变成链表
        flatten(root.right);
        TreeNode temp = root.right;
        //把树的右边换成左边的链表
        root.right = root.left;
        //记得要将左边置空
        root.left = null;
        //找到树的最右边的节点
        while(root.right != null) root = root.right;
        //把右边的链表接到刚才树的最右边的节点
        root.right = temp;
    }
}
```

解法一
可以发现展开的顺序其实就是二叉树的先序遍历。算法和 94 题中序遍历的 Morris 算法有些神似，我们需要两步完成这道题。

将左子树插入到右子树的地方
将原来的右子树接到左子树的最右边节点
考虑新的右子树的根节点，一直重复上边的过程，直到新的右子树为 null

```java
    1
   / \
  2   5
 / \   \
3   4   6

//将 1 的左子树插入到右子树的地方
    1
     \
      2         5
     / \         \
    3   4         6        
//将原来的右子树接到左子树的最右边节点
    1
     \
      2          
     / \          
    3   4  
         \
          5
           \
            6
            
 //将 2 的左子树插入到右子树的地方
    1
     \
      2          
       \          
        3       4  
                 \
                  5
                   \
                    6   
        
 //将原来的右子树接到左子树的最右边节点
    1
     \
      2          
       \          
        3      
         \
          4  
           \
            5
             \
              6         
  
```

```java
public void flatten(TreeNode root) {
    while (root != null) { 
        //左子树为 null，直接考虑下一个节点
        if (root.left == null) {
            root = root.right;
        } else {
            // 找左子树最右边的节点
            TreeNode pre = root.left;
            while (pre.right != null) {
                pre = pre.right;
            } 
            //将原来的右子树接到左子树的最右边节点
            pre.right = root.right;
            // 将左子树插入到右子树的地方
            root.right = root.left;
            root.left = null;
            // 考虑下一个节点
            root = root.right;
        }
    }
}

```

![image-20200528230251349](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200528230251349.png)

![image-20200528230315360](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200528230315360.png)

```java
private TreeNode pre = null;

public void flatten(TreeNode root) {
    if (root == null)
        return;
    flatten(root.right);
    flatten(root.left);
    root.right = pre;
    root.left = null;
    pre = root;
}
```

```java
public void flatten(TreeNode root) { 
    Stack<TreeNode> toVisit = new Stack<>();
    TreeNode cur = root;
    TreeNode pre = null;

    while (cur != null || !toVisit.isEmpty()) {
        while (cur != null) {
            toVisit.push(cur); // 添加根节点
            cur = cur.right; // 递归添加右节点
        }
        cur = toVisit.peek(); // 已经访问到最右的节点了
        // 在不存在左节点或者右节点已经访问过的情况下，访问根节点
        if (cur.left == null || cur.left == pre) {
            toVisit.pop(); 
            /**************修改的地方***************/
            cur.right = pre;
            cur.left = null;
            /*************************************/
            pre = cur;
            cur = null;
        } else {
            cur = cur.left; // 左节点还没有访问过就先访问左节点
        }
    } 
}
```

![image-20200528233449898](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200528233449898.png)

```java
public static void preOrderStack(TreeNode root) {
    if (root == null) { 
        return;
    }
    Stack<TreeNode> s = new Stack<TreeNode>();
    while (root != null || !s.isEmpty()) {
        while (root != null) {
            System.out.println(root.val);
            s.push(root);
            root = root.left;
        }
        root = s.pop();
        root = root.right;
    }
}
```

还有一种特殊的先序遍历，提前将右孩子保存到栈中，我们利用这种遍历方式就可以防止右孩子的丢失了。由于栈是先进后出，所以我们先将右节点入栈。

```java
public static void preOrderStack(TreeNode root) {
    if (root == null){
        return;
    }
    Stack<TreeNode> s = new Stack<TreeNode>();
    s.push(root);
    while (!s.isEmpty()) {
        TreeNode temp = s.pop();
        System.out.println(temp.val);
        if (temp.right != null){
            s.push(temp.right);
        }
        if (temp.left != null){
            s.push(temp.left);
        }
    }
}
```

![image-20200528233720868](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200528233720868.png)

```java
public void flatten(TreeNode root) { 
    if (root == null){
        return;
    }
    Stack<TreeNode> s = new Stack<TreeNode>();
    s.push(root);
    TreeNode pre = null;
    while (!s.isEmpty()) {
        TreeNode temp = s.pop(); 
        /***********修改的地方*************/
        if(pre!=null){
            pre.right = temp;
            pre.left = null;
        }
        /********************************/
        if (temp.right != null){
            s.push(temp.right);
        }
        if (temp.left != null){
            s.push(temp.left);
        } 
        /***********修改的地方*************/
        pre = temp;
        /********************************/
    }
}
```





#### [面试题 16.19. 水域大小](https://leetcode-cn.com/problems/pond-sizes-lcci/)

![image-20200531003514536](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200531003514536.png)

对整个矩阵进行遍历，每找到一个0值，在它的四周进行搜索，看是否有零值，若有则需要对池塘大小进行更新，并以新找到的0值位置为中心，递归，继续搜索它的四周，为避免重复搜索，每找到一个0值，都将它的值赋为1；

```java
import java.util.Collections;

class Solution {
    int row,col;
    int[][] arr;
      int area ;
    public int[] pondSizes(int[][] land) {
        this.arr = land;
        row = land.length;
        col = land[0].length;
        List<Integer> res = new ArrayList<Integer>();
        for(int i=0;i<row;i++){
            for(int j=0;j<col;j++){
                if(land[i][j]==0){
                     area = 0;
                    helper(i,j);
                    res.add(area);
                }
            }
        }
        Collections.sort(res);
        int[] result = new int[res.size()];
        for(int k=0;k<res.size();k++){
            result[k] = res.get(k);
        }
        return result;
       
    }
    public void helper(int i,int j){
        if(i<0||j<0||i>=row||j>=col){
            return;
        }
        if(arr[i][j]==0){
            arr[i][j]=1;
            area+=1;
            helper(i-1,j-1);
            helper(i-1,j);
            helper(i-1,j+1);
            helper(i,j-1);
            helper(i,j+1);
            helper(i+1,j-1);
            helper(i+1,j);
            helper(i+1,j+1);
        }
    }
}
```



#### [695. 岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/)

![image-20200602152247382](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200602152247382.png)

```java
class Solution {
    int [][] arr;
    int n,m;
      int max;
    public int maxAreaOfIsland(int[][] grid) {
        this.arr = grid;
        this.n = grid.length;
        this.m = grid[0].length;
        int res = 0;
      
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(grid[i][j]==1){
                    max=0;
                    helper(i,j);
                   res = Math.max(res,max) ;
                }
            }
        }
        return res;


    }
    public void helper(int i,int j){
        if(i<0||i>=n||j<0||j>=m){
            return ;
        }
        if(arr[i][j]==0){
           return ;
        }
         arr[i][j] = 0;
         max+=1;
          helper(i,j+1);
          helper(i,j-1);
          helper(i+1,j);
          helper(i-1,j);
        
    }
}
```







#### [1254. 统计封闭岛屿的数目](https://leetcode-cn.com/problems/number-of-closed-islands/)

![image-20200531014310746](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200531014310746.png)

```java
class Solution {
    int[][] arr ;
    int row,col;
    int res=0;
    public int closedIsland(int[][] grid) {
        this.arr = grid;
        this.row = grid.length;
        this.col = grid[0].length;
        for(int i=0;i<row;i++){
            for(int j=0;j<col;j++){
                if(arr[i][j]==0){
                    if(helper(i,j)){
                        res+=1;
                    }
                }
            }
        }
        return res;

    }

    public boolean helper(int i,int j){
        if(i>=row|| i<0 || j>=col||j<0){
            return false;
        }
        if(arr[i][j]==1){
            return true;
        }
        arr[i][j] =1;
        boolean b1 = helper(i-1,j);
        boolean b2 = helper(i+1,j);
        boolean b3 = helper(i,j-1);
        boolean b4 = helper(i,j+1);
         return  b1&&b2&&b3&&b4;
         // return helper(i-1,j)&&helper(i+1,j)&&helper(i,j-1)&& helper(i,j+1);这样写的话有用例不通过。
        return helper(i-1,j)&helper(i+1,j)&helper(i,j-1)& helper(i,j+1);这个可以
    }
}
```

#### [1319. 连通网络的操作次数](https://leetcode-cn.com/problems/number-of-operations-to-make-network-connected/)

![image-20200531130958782](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200531130958782.png)

```java
class Solution {
     int[] tmp;
     List<List<Integer>> list;
    public int makeConnected(int n, int[][] connections) {
        int lean = connections.length;
        if(n>lean+1){
            return -1;
        }
        list = new ArrayList<>();
        for(int j=0;j<n;j++){
            list.add(new ArrayList<>());
        }

        for(int[] arr:connections){
            list.get(arr[0]).add(arr[1]);
            list.get(arr[1]).add(arr[0]);
        }

        tmp =new int[n];
        int liantong = 0;
        for(int i=0;i<n;i++){
            if(tmp[i]==0){
                liantong+=1;
                dfs(i);
            }    
        }
    
        return liantong-1;



    }
    public void dfs(int i){
        if(tmp[i]==1){
            return;
        }
           tmp[i]=1;
        for(int node:list.get(i)){
            dfs(node);
        }

    }
}
// 二维列表
  //记录某个节点可以到达的节点
        List<Integer>[] lists = new List[n];
        for(int[] p : connections){
            if(lists[p[0]] == null){
                lists[p[0]] = new ArrayList<>();
            }
            if(lists[p[1]] == null){
                lists[p[1]] = new ArrayList<>();
            }
            lists[p[0]].add(p[1]);
            lists[p[1]].add(p[0]);
        }

```











## 数组

#### [面试题56 - I. 数组中数字出现的次数](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/)

![image-20200528112012080](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200528112012080.png)

![image-20200528112123121](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200528112123121.png)

```java
class Solution {
    public int[] singleNumbers(int[] nums) {
        int sum = 0;
        int[] res = new int[2];
        for(int num : nums){
            sum ^= num;
        }
        int lowbit = sum & (-sum);
        for(int num : nums){
            if((num & lowbit) == 0){
                res[0] ^= num;
            }else{
                res[1] ^= num;
            }
        }
        return res;
    }
}
```



#### [1343. 大小为 K 且平均值大于等于阈值的子数组数目](https://leetcode-cn.com/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/)



![image-20200531162507225](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200531162507225.png)

解题思路：滑动窗口，从前到后，维护一个长度为k的窗口，当i>=k时，将最前面的元素剔除，再计算窗口内的和

```java
class Solution {
    public int numOfSubarrays(int[] arr, int k, int threshold) {
    
        int n = arr.length;
        if(k>n){
            return 0;
        }
        int res = 0;
        int sum = 0;
        int min = k*threshold;
       for(int i=0;i<n;i++){
           sum+=arr[i];
           if(i+1>=k){//用来防止窗口内的元素小于k个时，多计算了子数组个数。
               if(i-k>=0){
                   sum -= arr[i-k];
               }
               if(sum>=min){
                   res+=1;
               }
           }
       }
    
        return res;

    }

}
```

#### [面试题 16.04. 井字游戏](https://leetcode-cn.com/problems/tic-tac-toe-lcci/)

![image-20200531191118000](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200531191118000.png)

```java
class Solution {
    public String tictactoe(String[] board) {
        int n = board.length;
        int[][] arr = new int[n][n];
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                if(board[i].charAt(j)=='O'){
                    arr[i][j] = 1;//O就是1
                }else if(board[i].charAt(j)=='X'){
                    arr[i][j]=n+1;//X就是n+1
                }
            }
        }
        boolean iszero = false;//判断是否有0，用来决定是否结束了
        for(int i=0;i<n;i++){
            int sumx = 0;//每行
            int sumy = 0;//每列
            for(int j=0;j<n;j++){
                sumy+=arr[j][i];
                sumx+=arr[i][j];
                if(arr[i][j]==0){
                    iszero = true;
                }
            }
            if(sumx==n||sumy==n){
                return "O";
            }
            if(sumx==n*(n+1)||sumy==n*(n+1)){
                return "X";
            }
        }
        int sumd = 0;//正对角线
        int sumd2 = 0;//反对角线
        for(int i=0;i<n;i++){
            sumd+=arr[i][i];
            sumd2 += arr[i][n-i-1];
        }

        if(sumd==n||sumd2==n){
                return "O";
            }
        if(sumd==n*(n+1)||sumd2==n*(n+1)){
            return "X";
        }

        if(iszero){
            return "Pending";
        }
        return "Draw";
    }
}
```



#### [714. 买卖股票的最佳时机含手续费](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)



![image-20200601201519900](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200601201519900.png)

```java
class Solution {
    public int maxProfit(int[] prices, int fee) {
        //思路：在每一步其实是有两个状态，持有股票和不持有股票，用cash表示不持有股票，一开始为0，hold表示持有股票
        //在第i步的时候，cash[i] = max(cash[i-1],hold[i-1]+price[i]-free);
        //hold[i] = max(hold[i-1],cash[i-1]-price[i]);
        //可以发现，每一步只与上一步有关系，只需要两个变量。

        // int cash = 0;
        // int hold = -prices[0];
        int n = prices.length;
        int[] cash = new int[n];
        int[] hold = new int[n];
        cash[0] = 0;
        hold[0] = -prices[0];
        for(int i=1;i<prices.length;i++){
            cash[i] = Math.max(cash[i-1],hold[i-1]+prices[i]-fee);
            hold[i] = Math.max(hold[i-1],cash[i-1]-prices[i]);
        }
        return (cash[n-1]);


    }
}
```

```java
class Solution {
    public int maxProfit(int[] prices, int fee) {
        int cash = 0, hold = -prices[0];
        for (int i = 1; i < prices.length; i++) {
            cash = Math.max(cash, hold + prices[i] - fee);
            hold = Math.max(hold, cash - prices[i]);
        }
        return cash;
    }
}

我来解释一下为什么不需要临时变量，楼上的那个人讲的太复杂了。 cash = Math.max(cash, hold + prices[i] - fee); hold = Math.max(hold, cash - prices[i]); 我们就只看公式，不看其他的

cash 有两种可能性要么等于cash，要么等于hold + prices[i] - fee；
hold 有两种可能性要么等于hold,要么等于cash - prices[i]；
cash如果等于cash，那么本身值就没有发生变化，所以对下面的计算也就没有影响.
cash如果等于hold + prices[i] - fee，我们将cash带入hold公式里面。
hold = Math.max(hold, hold + prices[i] - fee - prices[i]);==>hold = Math.max(hold, hold - fee);
可以看到买入当天+ prices[i]跟卖出当天- prices[i]正好抵消了，只剩下hold-fee了，而hold-fee是肯定小于hold的，也就是说hold没有变化.
而一天最多只能有一个状态的最大利润会发生变化(买入hold会变，卖出cash会变，不买不卖cash跟hold都不变)
综上结论：如果cash值不变，那么对hold的计算就不会有影响，而如果cash值变了，通过上面带入公式可知，hold最大值会取自身。
```



#### [123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)

![image-20200601221050415](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200601221050415.png)

```java
class Solution {
    public int maxProfit(int[] prices) {
        /**
        对于任意一天考虑四个变量:
        fstBuy: 在该天第一次买入股票可获得的最大收益 
        fstSell: 在该天第一次卖出股票可获得的最大收益
        secBuy: 在该天第二次买入股票可获得的最大收益
        secSell: 在该天第二次卖出股票可获得的最大收益
        分别对四个变量进行相应的更新, 最后secSell就是最大
        收益值(secSell >= fstSell)
        **/
        int fstBuy = Integer.MIN_VALUE, fstSell = 0;
        int secBuy = Integer.MIN_VALUE, secSell = 0;
        for(int p : prices) {
            fstBuy = Math.max(fstBuy, -p);
            fstSell = Math.max(fstSell, fstBuy + p);
            secBuy = Math.max(secBuy, fstSell - p);
            secSell = Math.max(secSell, secBuy + p); 
        }
        return secSell;

    }
}
```

![image-20200601221453486](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200601221453486.png)

![image-20200601221508041](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200601221508041.png)

```java
class Solution {
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length == 0) {
            return 0;
        }
        int len = prices.length;

        int min = prices[0];            // 初始化的前半部分最小买入价格
        int max = prices[len - 1];      // 初始化的后半部分最大卖出价格

        int maxPro1 = 0;                // 前半部分的每天最大利润
        int maxPro2 = 0;                // 后半部分的每天最大利润

        int[] profit1 = new int[len];   // 前半部分的利润表
        int[] profit2 = new int[len];   // 后半部分的利润表

        for (int i = 0; i < len; i++) {

            // 1. 计算 从前往后 的利润
            if (prices[i] <= min) {
                min = prices[i];
            } else {
                maxPro1 = Math.max(maxPro1, prices[i] - min);
            }
            profit1[i] = maxPro1;

            //  2. 计算 从后往前 的利润
            if (prices[len - 1 - i] >= max) {
                max = prices[len - 1 - i];
            } else {
                maxPro2 = Math.max(maxPro2, max - prices[len - 1 - i]);
            }
            profit2[len - i - 1] = maxPro2;
        }

        // 3. 计算利润和，求最大值
        int res = Integer.MIN_VALUE;
        for (int i = 0; i < len; i++) {
            res = Math.max(res, profit1[i] + profit2[i]);
        }
        return res;
    }
}

```

![image-20200601221540468](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200601221540468.png)

```java
  public int maxProfit(int[] prices) {
        
        int minPrice1 = Integer.MAX_VALUE;         
        int maxProfit1 = 0;                        
        int maxProfitAfterBuy = Integer.MIN_VALUE; 
        int maxProfit2 = 0;                        
        for(int price : prices) {
            // 1.第一次最小购买价格
            minPrice1  = Math.min(minPrice1,  price);

            // 2.第一次卖出的最大利润
            maxProfit1 = Math.max(maxProfit1, price - minPrice1);

            // 3.第二次购买后的剩余净利润
            maxProfitAfterBuy  = Math.max(maxProfitAfterBuy,  maxProfit1 - price );

            // 4.第二次卖出后，总共获得的最大利润（第3步的净利润 + 第4步卖出的股票钱）
            maxProfit2 = Math.max(maxProfit2, price + maxProfitAfterBuy);
        }
        return maxProfit2;
    }
}
```

```java
/**
5.29 第一遍
- 思路：动态规划。与 121、122 等题不同的是，这里的 k 不能忽略了。但是也不难，加上一个对 k 的循环即可。
- Recursive Cases：
  1. dp[i][2][0] = max(dp[i-1][2][0], dp[i-1][2][1] + prices[i])//第二次卖出
  2. dp[i][2][1] = max(dp[i-1][2][1], dp[i-1][1][0] - prices[i])//第二次买入
  3. dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])//第一次不持有股票（卖出）
  4. dp[i][1][1] = max(dp[i-1][1][1], - prices[i])//第一次持有股票（买入）
  
  //每一步会有几种状态，一般就会有几个状态转移方程，这里每一步有四种状态，需要四个转移方程，需要一个三维数组，来表示这四种状态。在这里，用四个变量也可以表示。

*/

class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length, m = 2;
        int dp_i_2_0 = 0, dp_i_1_0 = 0;
        int dp_i_2_1 = Integer.MIN_VALUE, dp_i_1_1 = Integer.MIN_VALUE;
        for ( int i = 0; i < n; i++) {
            for (int k = m; k > 0; k--) {//去掉这个循环也对，但是两个循环速度更快，为什么？
                dp_i_1_1 = Math.max(dp_i_1_1, -prices[i]);
                dp_i_1_0 = Math.max(dp_i_1_0, dp_i_1_1 + prices[i]);
                dp_i_2_1 = Math.max(dp_i_2_1, dp_i_1_0 - prices[i]);
                dp_i_2_0 = Math.max(dp_i_2_0, dp_i_2_1 + prices[i]);
            }
        }
        return Math.max(Math.max(Math.max(dp_i_2_0, dp_i_2_1), dp_i_1_0), dp_i_1_1);
    }
}
```



#### [188. 买卖股票的最佳时机 IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)

![image-20200602101256693](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200602101256693.png)

```java
class Solution {
    public int maxProfit(int k, int[] prices) {
        if (prices.length < 2) return 0;

        if (k > prices.length/2) {//防止k过大时候超出内存限制
            int profit = 0;
            for (int i = 1; i < prices.length; i++) {
                int tmp = prices[i] - prices[i - 1];
                if (tmp > 0) profit += tmp;
            }
            return profit;
        }

        int[][] dp = new int[k+1][2];
        // dp[0][0] = Integer.MIN_VALUE;
        for (int i = 0; i <= k; ++i) {
            dp[i][0] = Integer.MIN_VALUE;//第k次买入
        }

        for (int i = 0; i < prices.length; ++i) {
            for (int j = 1; j <= k; ++j) {
                dp[j][0] = Math.max(dp[j][0], dp[j-1][1] - prices[i]);
                dp[j][1] = Math.max(dp[j][1], dp[j][0] + prices[i]);
            }
        }

        return dp[k][1];
    }
}
```



```java
class Solution {
    public int maxProfit(int k, int[] prices) {
        // dp[i][0][k]:第i天的时候是少于等于第k次买入后手里的钱的最大值-持有
        //dp[i][1][k]:第i天的时候是少于等于第k次卖出手里的钱的最大值-不持有
        //其实只需要一个二维数组就可以了，因为第i+1天的状态只和第i天的状态相关
        
        if (prices.length < 2) return 0;
        if (k > prices.length/2) {//防止k过大时候超出内存限制
            int profit = 0;
            for (int i = 1; i < prices.length; i++) {
                int tmp = prices[i] - prices[i - 1];
                if (tmp > 0) profit += tmp;
            }
            return profit;
        }

        int[][] dp = new int[2][k+1];
        dp[0][0] = Integer.MIN_VALUE;
        dp[1][0] = 0;
        for(int i=0;i<=k;i++){
            dp[0][i] = Integer.MIN_VALUE;
        }


        for(int i=0;i<prices.length;i++){
            for(int j=1;j<=k;j++){
                dp[0][j] = Math.max(dp[0][j],dp[1][j-1]-prices[i]);
                dp[1][j] = Math.max(dp[1][j],dp[0][j]+prices[i]);
            }
            
        }
       
        return dp[1][k];

    }
}

```



#### [309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

![image-20200602111856055](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200602111856055.png)

```java
class Solution {
    public int maxProfit(int[] prices) {
        //每一天的状态有三个，0持有，1不持有，2冷冻，如果前一天为卖出，那么今天就是冷冻
        int n = prices.length;
          if(n<2){
            return 0;
        }
        int[][] dp = new int[n][2];

        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        dp[1][0] = Math.max(dp[0][0],dp[0][1]-prices[1]);
        dp[1][1] = Math.max(dp[0][1],dp[0][0]+prices[1]);


        for(int i=2;i<n;i++){
           
            dp[i][0] = Math.max(dp[i-1][0],dp[i-2][1]-prices[i]);
            dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0] + prices[i]);
            
        }

    return dp[n-1][1];
    }
}
```

```java
class Solution {
    public int maxProfit(int[] prices) {
        if(prices.length <= 1){
            return 0;
        }
        int res_i_0 = 0;
        int res_i_1 = -prices[0];
        int res_pre_0 = 0; //前天不持有股票的最大利润
        for (int i = 1; i < prices.length; i++) {
            int temp = res_i_0; //先保存昨天不持有股票的利润
            res_i_0 = Math.max(res_i_0, res_i_1 + prices[i]); //今天不持有股票的利润
            //如果是第二天持有股票，利润是昨天持有股票的利润和今天才买进的利润的最大值
            //如果是第二天之后持有股票，利润是昨天持股利润和前天卖掉股票今天再买的利润的最大值
            res_i_1 = i == 1 ? Math.max(res_i_1, -prices[i]) : Math.max(res_i_1, res_pre_0 - prices[i]);
            res_pre_0 = temp; //下次循环昨天就是前天
        }
        return res_i_0;
    }
}
```

#### [162. 寻找峰值](https://leetcode-cn.com/problems/find-peak-element/)

![image-20200602160254677](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200602160254677.png)

![image-20200602160621541](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200602160621541.png)

```java

public class Solution {
    int[] nums;
    public int findPeakElement(int[] nums) {
        this.nums = nums;
        return search( 0, nums.length - 1);
    }
    public int search( int l, int r) {
        if (l == r)
            return l;
        int mid = (l + r) / 2;
        if (nums[mid] > nums[mid + 1])
            return search( l, mid);
        return search(mid + 1, r);
    }
}
```

#### [209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

![image-20200602165533715](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200602165533715.png)

n*n

```java
class Solution {
    public int minSubArrayLen(int s, int[] nums) {
        int n =nums.length;
        int min = Integer.MAX_VALUE;;

        for(int i=0;i<n;i++){
            if(nums[i]>=s){
                return 1;
            }
           else{
               int res = nums[i];
                for(int j=i-1;j>=0;j--){
                      res+=nums[j];
                      if(res>=s){
                          min = Math.min(min,i-j+1);
                          break;
                      }
                }
           }
        }
        return min==Integer.MAX_VALUE?0:min;

    }
}
```

n

```java
class Solution {
    public int minSubArrayLen(int s, int[] nums) {
        int n =nums.length;
        int min = Integer.MAX_VALUE;
        int sum = 0;
        int j = 0;

        for(int i=0;i<n;i++){
            sum+=nums[i];
            while(sum>=s){
                if(i-j+1<min){
                    min = i-j+1;
                }
                sum-=nums[j];
                j++;

            }
        }
        return min==Integer.MAX_VALUE?0:min;

    }
}
```







#### [718. 最长重复子数组](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/)

![image-20200603205024068](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200603205024068.png)

![image-20200603102041258](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200603102041258.png)





![image-20200603102342329](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200603102342329.png)

check传入长度length,在A和B中查找有没有长度为length的公共子串。如果有，接着按照二分查找的逻辑，查询有没有1.5length长度的子串。如果没有，下一次查找的长度就是0.5length。以此类推。这样能把时间复杂度从n降到logn。

![image-20200603105252454](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200603105252454.png)

```java
class Solution {
    public int findLength(int[] A, int[] B) {
        int ans = 0;
        int n =  A.length;
        int m = B.length;
        int [][] dp = new int[n+1][m+1];
        for(int i=n-1;i>=0;i--){
            for(int j=m-1;j>=0;j--){
                if(A[i]==B[j]){
                    dp[i][j] = dp[i+1][j+1] +1;
                }
                ans = Math.max(ans,dp[i][j]);


            }
        }
        return ans;
    }
}
```



![image-20200603215736725](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200603215736725.png)

```java
import java.math.BigInteger;

class Solution {
    int P = 113;
    int MOD = 1_000_000_007;
    int Pinv = BigInteger.valueOf(P).modInverse(BigInteger.valueOf(MOD)).intValue();

    private int[] rolling(int[] source, int length) {
        int[] ans = new int[source.length - length + 1];
        long h = 0, power = 1;
        if (length == 0) return ans;
        for (int i = 0; i < source.length; ++i) {
            h = (h + source[i] * power) % MOD;
            if (i < length - 1) {
                power = (power * P) % MOD;
            } else {
                ans[i - (length - 1)] = (int) h;
                h = (h - source[i - (length - 1)]) * Pinv % MOD;
                if (h < 0) h += MOD;
            }
        }
        return ans;
    }

    private boolean check(int guess, int[] A, int[] B) {
        Map<Integer, List<Integer>> hashes = new HashMap();
        int k = 0;
        for (int x: rolling(A, guess)) {
            hashes.computeIfAbsent(x, z -> new ArrayList()).add(k++);
        }
        int j = 0;
        for (int x: rolling(B, guess)) {
            for (int i: hashes.getOrDefault(x, new ArrayList<Integer>()))
                if (Arrays.equals(Arrays.copyOfRange(A, i, i+guess),
                                  Arrays.copyOfRange(B, j, j+guess))) {
                    return true;
                }
            j++;
        }
        return false;
    }

    public int findLength(int[] A, int[] B) {
        int lo = 0, hi = Math.min(A.length, B.length) + 1;
        while (lo < hi) {
            int mi = (lo + hi) / 2;
            if (check(mi, A, B)) lo = mi + 1;
            else hi = mi;
        }
        return lo - 1;
    }
}

```





#### [670. 最大交换](https://leetcode-cn.com/problems/maximum-swap/)

![image-20200603232900296](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200603232900296.png)

这题我们的想法肯定是，尽量交换前面的大数位，并且和它交换的数还得是在它后面大于它的最大数

倒序使用数组存储下来每个位置，在它及它以后的最大数的索引
然后再正序从一个数开始遍历，如果它及它以后的最大数不是它本身，那么这个数就是我们需要交换的。

```java
class Solution {
    public int maximumSwap(int num) {
        char[] c = String.valueOf(num).toCharArray();
        int max = Integer.MIN_VALUE;
        int max_index = 0;
        int [] arr = new int[c.length];
        arr[c.length - 1] = c.length - 1;
        
        for (int i = c.length - 1; i >= 0; i --) {
            if (c[i] - '0' > max) {
                max = c[i] - '0';
                max_index = i;
            }
            arr[i] = max_index;
        }
        for (int i = 0; i < c.length; i ++) {
            if (arr[i] != i && c[arr[i]] != c[i]) {
                char tmp = c[i];
                c[i] = c[arr[i]];
                c[arr[i]] = tmp;
                break;
            }
        }
        return Integer.parseInt(new String(c));
        
    }
}

```

```java
class Solution {
    public int maximumSwap(int num) {
        char[] nums = String.valueOf(num).toCharArray();
        int[] last = new int[10];
        for (int i = 0; i < nums.length; i ++) {
            last[nums[i] - '0'] = i;//用来保存0-9最后出现的位置
        }
        for (int i = 0; i < nums.length; i ++)
        {
            for (int j = 9; j > nums[i] - '0'; j --)//遍历查找比当前数大的数
            {
                if (last[j] > i)//如果比nums[i]最大的数出现在他的后面，就交换
                {
                    char tmp = nums[i];
                    nums[i] = (char)(j + '0');
                    nums[last[j]] = tmp;
                    return Integer.parseInt(String.valueOf(nums));
                }
            }
        }
        return num;
    }
}
```

#### 滑动窗口的最大值

给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。

```java
import java.util.*;
public class Solution {
    public ArrayList<Integer> maxInWindows(int [] num, int size){
         ArrayList<Integer> res = new ArrayList<Integer>();
        if(num==null||size<1||num.length<size){
            return res;
        }
        LinkedList<Integer> qmax = new LinkedList<Integer>();
       
        for(int i=0;i<num.length;i++){
            while(!qmax.isEmpty()&&num[qmax.peekLast()]<=num[i]){
                qmax.pollLast();
            }
            qmax.addLast(i);
            if(qmax.peekFirst()==i-size){
                qmax.pollFirst();
            }
            if(i>=size-1){
                res.add(num[qmax.peekFirst()]);
            }
        }
        return res;
        
    }
}
```

#### [76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)

![image-20200801165652173](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200801165652173.png)

```java
class Solution {
    public String minWindow(String s, String t) {
        //滑动窗口
        Map<Character,Integer> window = new HashMap<>();
        //需要组成的
        Map<Character,Integer> need = new HashMap<>();
        //填充need
        for(int i=0;i<t.length();i++){
            need.put(t.charAt(i),need.getOrDefault(t.charAt(i),0)+1);
        }
        //左右指针,[left,right),左闭右开
        int left = 0;
        int right = 0;
        //window中有几个是有效的
        int valid = 0;
        //记录子串的开始节点
        int start = 0;
        //记录子串的长度
        int len = Integer.MAX_VALUE;

        while(right<s.length()){
            //当前字符
            char c = s.charAt(right);
            //右指针加一,将当前字符c加入到了滑动窗口中
            right++;
            //如果当前字符是需要的
            if(need.containsKey(c)){
                //窗口的map中加入它
                window.put(c,window.getOrDefault(c,0)+1);
                //如果这个字符在need和window中的数量一样,意味着它有效了
                if(window.get(c).equals(need.get(c))){
                    valid++;
                }
            }
            //当有效的字符和need中的个数相同时候,窗口中就是一个解了,接着求最短的字符,从左边将窗口缩小
            while(valid==need.size()){
                //更新最优解
                if(right-left<len){
                    start = left;
                    len = right-left;
                }

                char d = s.charAt(left);
                left++;
                //如果移除的这个字符是被需要的
                if(need.containsKey(d)){
                    //第一次的时候将有效个数减一
                    if(window.get(d).equals(need.get(d))){
                        valid--;
                    }
                    if(window.containsKey(d)){
                        window.put(d,window.get(d)-1);
                    }
                }
            }
        }

        return len==Integer.MAX_VALUE?"":s.substring(start,start+len);

    }
}
```



#### [567. 字符串的排列](https://leetcode-cn.com/problems/permutation-in-string/)

![image-20200805192444926](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200805192444926.png)



```java
class Solution {
    
    public boolean checkInclusion(String s1, String s2) {
        Map<Character,Integer> need = new HashMap<>();
        Map<Character,Integer> window = new HashMap<>();

        for(int i=0;i<s1.length();i++){
            need.put(s1.charAt(i),need.getOrDefault(s1.charAt(i),0)+1);
        }
        int left = 0;
        int right = 0;
        int vialid = 0;

        while(right<s2.length()){
            char c = s2.charAt(right);
            right++;
            if(need.containsKey(c)){
                window.put(c,window.getOrDefault(c,0)+1);
                if(need.get(c).equals(window.get(c))){
                    vialid++;
                }
            }
            if(vialid==need.size()){
                return true;
            }
            if((right-left)>=s1.length()){
                
                 char d = s2.charAt(left);
                left++;
                //如果移除的这个字符是被需要的
                if(need.containsKey(d)){
                    //第一次的时候将有效个数减一
                    if(window.get(d).equals(need.get(d))){
                        vialid--;
                    }
                    if(window.containsKey(d)){
                        window.put(d,window.get(d)-1);
                    }
                }
              
            }

        }
        return false;
    }
}
```





#### 调整数组顺序使奇数位于偶数前面

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。

```java
//冒泡排序的思想
public class Solution {
    public void reOrderArray(int [] array) {
       for(int i= 0;i<array.length-1;i++){
            for(int j=0;j<array.length-1-i;j++){
                if(array[j]%2==0&&array[j+1]%2==1){
                    int t = array[j];
                    array[j]=array[j+1];
                    array[j+1]=t;
                }
            }
        }
    }
}
//插入排序
public class Solution {
    public void reOrderArray(int [] array) {
        //相对位置不变，稳定性
        //插入排序的思想
        int m = array.length;
        int k = 0;//记录已经摆好位置的奇数的个数
        for (int i = 0; i < m; i++) {
            if (array[i] % 2 == 1) {
                int j = i;
                while (j > k) {//j >= k+1
                    int tmp = array[j];
                    array[j] = array[j-1];
                    array[j-1] = tmp;
                    j--;
                }
                k++;
            }
        }
    }
}
```

#### [152. 乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray/)

```java
class Solution {
    public int maxProduct(int[] nums) {
        if(nums.length==0){
            return 0;
        }
        int max = nums[0];
        int min = nums[0];
        int res = nums[0];
        for(int i=1;i<nums.length;i++){
            int mx = max,mn = min;
            max = Math.max(mx*nums[i],Math.max(nums[i],mn*nums[i]));
            min = Math.min(mn*nums[i],Math.min(nums[i],mx*nums[i]));
            res = Math.max(max,res);
        }
        return res;
       
    }
}


```



超出内存限制

```java
class Solution {
    public int maxProduct(int[] nums) {
        if(nums.length==0){
            return 0;
        }
        int max = nums[0];
       int[][] dp = new int[nums.length][nums.length];
       dp[0][0] = nums[0];
       for(int i=0;i<nums.length;i++){
           dp[i][i] = nums[i];
            max = Math.max(max,dp[i][i]);
       }
       for(int i=0;i<nums.length-1;i++){
           for(int j=i+1;j<nums.length;j++){
               dp[i][j] = dp[i][j-1]*nums[j];
                max = Math.max(max,dp[i][j]);
           }
       }
       return max;

    }
}
```

#### [406. 根据身高重建队列](https://leetcode-cn.com/problems/queue-reconstruction-by-height/)

![image-20200801162726610](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200801162726610.png)

```java
class Solution {
    public int[][] reconstructQueue(int[][] people) {
        Arrays.sort(people,new Comparator<int[]>(){
            public int compare(int[] o1,int[] o2){
                return o1[0]==o2[0]?o1[1]-o2[1]:o2[0]-o1[0];//如果返回的>0,表示要交换这两个值
            }
        });
        //等价
         Arrays.sort(people,(int[] o1,int[] o2)->{return o1[0]==o2[0]?o1[1]-o2[1]:o2[0]-o1[0];});
        List<int[]> output = new LinkedList<>();
        for(int[] p:people){
            output.add(p[1],p);
        }
        int n = people.length;
        return output.toArray(new int[n][2]);

    }
}
```

#### [39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)

![image-20200803095445937](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200803095445937.png)

```java
class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        Arrays.sort(candidates);
        List<List<Integer>> list = new ArrayList<>();
        int n = candidates.length;
        dfs(candidates,n,0,target,new ArrayDeque<Integer>(),list);
        return list;

       

    }

    public void dfs(int[] candidates,int len,int start,int target,Deque<Integer> path,List<List<Integer>> list){
        if(target==0){
            list.add(new ArrayList(path));
            return;
        }
     
        for(int i=start;i<len;i++){
               if(target<candidates[i]){
                  break;
                }
            path.addLast(candidates[i]);
            dfs(candidates,len,i,target-candidates[i],path,list);
            path.removeLast();
        }
    }
}
```



#### [974. 和可被 K 整除的子数组](https://leetcode-cn.com/problems/subarray-sums-divisible-by-k/)

![image-20200803202120790](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200803202120790.png)

连续的子数组问题就要用前缀和求解

```java
// class Solution {
//     public int subarraysDivByK(int[] A, int K) {
//         Map<Integer, Integer> record = new HashMap<>();
//         record.put(0, 1);
//         int sum = 0, ans = 0;
//         for (int elem: A) {
//             sum += elem;
//             // 注意 Java 取模的特殊性，当被除数为负数时取模结果为负数，需要纠正
//             int modulus = (sum % K + K) % K;
//             int same = record.getOrDefault(modulus, 0);//same是出现的次数
//             ans += same;
//             record.put(modulus, same + 1);
//         }
//         return ans;
//     }
// }

class Solution {
    public int subarraysDivByK(int[] A, int K) {
        if (A == null || A.length < 1 || K <= 0) throw new IllegalArgumentException("invalid param");

        int[] preSum = new int[A.length + 1];
        for (int i = 1; i <= A.length; i++) {
            preSum[i] = preSum[i - 1] + A[i - 1];
        }

        int res = 0;
        int[] counter = new int[K];
        for (int num : preSum) {
            int remaining = num % K;
            if (remaining < 0) remaining += K;
            res += counter[remaining];
            counter[remaining]++;
        }
        return res;
    }
}


class Solution {
    public int subarraysDivByK(int[] A, int K) {
        if (A == null || A.length < 1 || K <= 0) throw new IllegalArgumentException("invalid param");

        int[] preSum = new int[A.length ];
        preSum[0] = A[0];
        for (int i = 1; i <A.length; i++) {
            preSum[i] = preSum[i - 1] + A[i ];
        }

        int res = 0;
        int[] counter = new int[K];
        counter[0] = 1;
        for (int num : preSum) {
            int remaining = num % K;
            if (remaining < 0) remaining += K;
            res += counter[remaining];
            counter[remaining]++;
        }
        return res;
    }
}
```



#### [440. 字典序的第K小数字](https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order/)

![image-20200803210337470](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200803210337470.png)

![img](https://pic.leetcode-cn.com/a087ef3df33a26210275027ca6cafb03168cf0865fadc611c8ca7af41ab8b226-bad2ce390cb0c417bd81e1f2b17e0e7eadba1159bc13c43cf7bf72bd55ddb69b-%E6%88%AA%E5%B1%8F2020-05-09%20%E4%B8%8A%E5%8D%8811.48.14.png)

```java

class Solution {
    public int findKthNumber(int n, int k) {
        int cur = 1;
        k = k - 1;//扣除掉第一个0节点
        while(k>0){
            int num = getNode(n,cur,cur+1);
            if(num<=k){//第k个数不在以cur为根节点的树上
                cur+=1;//cur在字典序数组中从左往右移动
                k-=num;
            }else{//在子树中
                cur*=10;//cur在字典序数组中从上往下移动
                k-=1;//刨除根节点
            }
        }
        return cur;
    }
    public int getNode(int n, long first, long last){
        int num = 0;
        while(first <= n){
            num += Math.min(n+1,last) - first;//比如n是195的情况195到100有96个数
            first *= 10;
            last *= 10;
        }
        return num;
    }
}

作者：pianpianboy
链接：https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order/solution/yi-tu-sheng-qian-yan-by-pianpianboy/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



字典树

```java
class Trie {
    boolean is_string = false;
    Trie[] next ;

    /** Initialize your data structure here. */
    public Trie() {
        next = new Trie[26];

    }
    
    /** Inserts a word into the trie. */
    public void insert(String word) {
        Trie root = this;
        char[] ch = word.toCharArray();
        for(int i=0;i<ch.length;++i){
            if(root.next[ch[i]-'a']==null){
                root.next[ch[i]-'a'] = new Trie();
            }
            root = root.next[ch[i]-'a'];
        }
        root.is_string = true;

    }
    
    /** Returns if the word is in the trie. */
    public boolean search(String word) {
        Trie root = this;
        char[] ch = word.toCharArray();
        for(int i=0;i<ch.length;++i){
            if(root.next[ch[i]-'a']==null){
                return false;
            }
            root = root.next[ch[i]-'a'];
        }
        return root.is_string;

    }


    
    /** Returns if there is any word in the trie that starts with the given prefix. */
    public boolean startsWith(String prefix) {
        Trie root = this;
        char[] ch = prefix.toCharArray();
        for(int i=0;i<ch.length;++i){
            if(root.next[ch[i]-'a']==null){
                return false;
            }
            root = root.next[ch[i]-'a'];
        }
        return true;

    }
}
```



#### [378. 有序矩阵中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/)

![image-20200804203310093](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200804203310093.png)

```java
class Solution {
    public int kthSmallest(int[][] matrix, int k) {
        int n = matrix.length;
        int left = matrix[0][0];
        int right = matrix[n-1][n-1];
        while(left<right){
            int mid = (left+right)/2;
            if(helper(matrix,mid,n)>=k){
                right = mid;
            }else {
                left = mid+1;
            }

        }
        return left;

    }
    public int helper(int[][] matrix,int mid,int n){
        int i = n-1;
        int j = 0;
        int num = 0;
        while(i>=0&&j<n){
            if(matrix[i][j]<=mid){
                num+=i+1;
                j++;
            }else{
                i--;
            }
        }
        return num;
    }
}

```



#### [227. 基本计算器 II](https://leetcode-cn.com/problems/basic-calculator-ii/)

![image-20200805140534323](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200805140534323.png)

```java
class Solution {
    public int calculate(String s) {
        Stack<Integer> numStack = new Stack<>();

        char lastOp = '+';
        char[] arr = s.toCharArray();
        for(int i = 0; i < arr.length; i ++){
            if(arr[i] == ' ') continue;
            if(arr[i]-'0'>=0&&arr[i]-'0'<=9){
                int num =0;
                while(i<arr.length&&arr[i]-'0'>=0&&arr[i]-'0'<=9){
                    num = num*10+arr[i] -'0';
                    i++;
                }
                i--;
                if(lastOp=='+'){
                    numStack.push(num);
                }else if(lastOp=='-'){
                     numStack.push(-num);
                }else{
                    numStack.push(res(lastOp,numStack.pop(),num));
                }
            }else{
                lastOp = arr[i];
            }
        }
        int ans = 0;
        for(int num : numStack) ans += num;
        return ans;
    }
    
    private int res(char op, int a, int b){
        if(op == '*') return a * b;
        else if(op == '/') return a / b;
        else if(op == '+') return a + b; //其实加减运算可以忽略
        else return a - b;
    }
}

```



#### [224. 基本计算器](https://leetcode-cn.com/problems/basic-calculator/)

![image-20200805144457761](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200805144457761.png)



```java
class Solution {
    public int calculate(String s) {

        Stack<Integer> stack = new Stack<Integer>();
        int operand = 0;
        int result = 0; // For the on-going result
        int sign = 1;  // 1 means positive, -1 means negative

        for (int i = 0; i < s.length(); i++) {

            char ch = s.charAt(i);
            if (ch-'0'>=0&&ch-'0'<=9) {
                operand = 10 * operand + (int) (ch - '0');
            } else if (ch == '+') {
                result += sign * operand;
                sign = 1;
                operand = 0;

            } else if (ch == '-') {

                result += sign * operand;
                sign = -1;
                operand = 0;

            } else if (ch == '(') {
                stack.push(result);
                stack.push(sign);
                sign = 1;
                result = 0;

            } else if (ch == ')') {

                // Evaluate the expression to the left
                // with result, sign and operand
                result += sign * operand;

                // ')' marks end of expression within a set of parenthesis
                // Its result is multiplied with sign on top of stack
                // as stack.pop() is the sign before the parenthesis
                result *= stack.pop();

                // Then add to the next operand on the top.
                // as stack.pop() is the result calculated before this parenthesis
                // (operand on stack) + (sign on stack * (result from parenthesis))
                result += stack.pop();

                // Reset the operand
                operand = 0;
            }
        }
        return result + (sign * operand);
    }
}

```





## 字符串

链接：https://www.nowcoder.com/questionTerminal/42852fd7045c442192fa89404ab42e92?f=discussion
来源：牛客网



\1. 三个同样的字母连在一起，一定是拼写错误，去掉一个的就好啦：比如 helllo -> hello 

  \2. 两对一样的字母（AABB型）连在一起，一定是拼写错误，去掉第二对的一个字母就好啦：比如 helloo -> hello 

  \3. 上面的规则优先“从左到右”匹配，即如果是AABBCC，虽然AABB和BBCC都是错误拼写，应该优先考虑修复AABB，结果为AABCC

```
第一行包括一个数字N，表示本次用例包括多少个待校验的字符串。

后面跟随N行，每行为一个待校验的字符串。
```

```java
import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        String[] strings = new String[N];
        for (int i = 0; i < N; i++) {
            strings[i] = sc.next();
        }
        Solution1 solution = new Solution1();
        for (String str : strings)
            System.out.println(solution.solve(str));
    }
}
class Solution1 {
    public String solve(String s) {
        if (s == null || s.length() <= 2) return s;
        for (int i = 0; i < s.length() - 3; i++) {
            if (s.charAt(i) == s.charAt(i + 1) && s.charAt(i + 2) == s.charAt(i + 3)) {//AABB
                s = delete(s, i + 2);
                i--;
            }
            else if(s.charAt(i) == s.charAt(i + 1) && s.charAt(i) == s.charAt(i + 2)){//AAA
                s = delete(s,i);
                i--;
            }
        }
        int n = s.length();
        if(s.charAt(n - 1) == s.charAt(n - 2) && s.charAt(n - 1) == s.charAt(n - 3))//可能结尾剩余3个AAA的情况
            s = delete(s,n-1);
        return s;
    }
    private String delete(String s, int i) {
        return s.substring(0, i) + s.substring(i + 1);
    }
}
```

```java
//自动机

import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        while(N-->0){
            int state = 0;
            char cur;
            String str;
            str = sc.next();
            char last = str.charAt(0);
            String ans = "";
            ans += str.charAt(0);
            for(int i=1;i<str.length();i++){
                cur = str.charAt(i);
                switch(state){
                    case 0:{
                        if(cur == last)//如果是相等的，进入状态1，否则继续状态0；
                            state = 1; //进入状态1：AA形式
                        else state = 0;//继续状态0：AB形式，即正常形式
                        break;
                    }
                    case 1:{
                        if(cur==last)
                            continue;//AAA,忽略即可
                        else state = 2;//进入状态2：AAB形式
                        break;
                    }
                    case 2:{
                        if(cur == last)
                            continue;//AABB，忽略即可
                        else state = 0;//AABC，就是状态0
                        break;
                        
                    }
                    default:break;
                        
                }
                ans = ans + cur;
                last = cur;
            }
            System.out.println(ans);
        }
       
    }
}

```

![img](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/32467579_1565937968420_DE5B282734A51A4B84BFE404BF44B5FE.png)





\1. 我们在字节跳动大街的N个建筑中选定3个埋伏地点。

\2. 为了相互照应，我们决定相距最远的两名特工间的距离不超过D。

![image-20200616160930065](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200616160930065.png)



```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int d = sc.nextInt();
        if(N<=2){
            System.out.println(0);
            return;
        }
        
        long[] arr = new long[N];
        long sum = 0;
        for(int i=0;i<N;i++){
            arr[i] = sc.nextInt();
        }
        
        for(int i=0,j=0;j<N;j++){
            while(j>=2&&arr[j]-arr[i]>d){
                i++;
            }
            sum += helper(j-i);
            
        }
        sum %=  99997867;
        System.out.println(sum);

    }
    
    public static long helper(long n){
        return n*(n-1)/2;
    }
}
```

#### 最小唯一前缀

![image-20200620171839050](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200620171839050.png)

```java

import java.util.Scanner;  

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int N = scanner.nextInt();
        String[] strings = new String[N];
        for (int i = 0; i < N; i++)
            strings[i] = scanner.next();
        scanner.close();
        for (String s : strings)
            System.out.println(unique(s, strings));
    }
        //返回字符串s在字符串数组strings中最短唯一前缀
    private static String unique(String s, String[] strings) {
        String prefix = s.substring(0, 1);//前缀初始为首字符
        for (String single : strings) {
            if (single.equals(s))//跳过字符串s本身
                continue;
            while (single.indexOf(prefix) == 0 && prefix.length() < s.length()) //字符串single与字符串s具有相同的前缀prefix，前缀需要往后延长
                prefix = s.substring(0, prefix.length()+1);
        }
        return prefix;
    }
}
```



![image-20200623230611559](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200623230611559.png)



```java
public class Solution {
    public int StrToInt(String str) {
        if(str==null||str.equals("")){
            return 0;
        }
        char[] ch = str.toCharArray();
        if(!helper(ch)){
            return 0;
        }
        boolean posi = ch[0]=='-'?false:true;
        boolean zh = ch[0]=='+'?true:false;
        int minq = Integer.MIN_VALUE /10;
        int minr = Integer.MIN_VALUE % 10;
        int res = 0;
        int cur = 0;
        for(int i=(posi&&!zh)?0:1;i<ch.length;i++){
            cur = '0' - ch[i];
            if((res<minq)||(res==minq&&cur<minr)){
                return 0;
            }
            res = res * 10 + cur;
        }
        if(posi&&res==Integer.MIN_VALUE){
            return 0;
        }
        return posi?-res:res;
        
        
    }
    public boolean helper(char[] ch){
        if((ch[0]!='-'&&ch[0]!='+') && (ch[0]>'9' ||ch[0]<'0')){
            return false;
        }
        if((ch[0]=='-'||ch[0]=='+')&& (ch.length==1||ch[1]=='0')){
            return false;
        }
        if(ch[0]==0&&ch.length>1){
            return false;
        }
        for(int i=1;i<ch.length;i++){
            if(ch[i]>'9'||ch[i]<'0'){
                return false;
            }
        }
        return true;
    }
}
```

#### [49. 字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)![image-20200728124204677](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200728124204677.png)



```java

class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        List<List<String>> list = new ArrayList<>();
        if(strs.length==0){
            return list;
        }
        int len = strs.length;
        int index = 0;
        Map<String,Integer> map = new HashMap<>();
        for(int i=0;i<len;i++){
            char[] ch = strs[i].toCharArray();
            Arrays.sort(ch);
            String a = String.valueOf(ch);

            if(!map.containsKey(a)){
                map.put(a,index);
                index++;
                List<String> temp = new ArrayList<>();
                temp.add(strs[i]);
                list.add(temp);
            }else{
                 list.get( map.get(a)).add(strs[i]); 
            }
          
        }
        return list;
       
    }
}
```

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        List<List<String>> list = new ArrayList<>();
        if(strs.length==0){
            return list;
        }
        for(int i=0;i<strs.length;i++){
            if(strs[i].equals("A")){
                continue;
            }
            List<String> temp = new ArrayList<>();
            for(int j=i+1;j<strs.length;j++){
                 if(strs[j].equals("A")||strs[i].length()!=strs[j].length()){
                         continue;
                 }
                 if(match(strToarr(strs[i]),strToarr(strs[j]))){
                     temp.add(strs[j]);
                     strs[j] = "A";
                 }
            }
            temp.add(strs[i]);
            strs[i] = "A";
            list.add(temp);
        }
        return list;




    }
    public int[] strToarr(String str){
        int[] a = new int[26];
        for(int i=0;i<str.length();i++){
            a[str.charAt(i)-'a']+=1;
        }
        return a;
    }

    public boolean match(int[] a1,int[] a2){
        for(int i=0;i<26;i++){
            if(a1[i]!=a2[i]){
                return false;
            }
        }
        return true;
    }
}
```

#### [438. 找到字符串中所有字母异位词](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/)

![image-20200729095705249](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200729095705249.png)

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        List<Integer> list = new ArrayList<>();
        int slen = s.length();
        int plen = p.length();
        if(s==null||s.equals("")||slen<plen){
            return list;
        }
       int[] pint = new int[26];
       int[] window = new int[26];
       for(int i=0;i<plen;i++){
           pint[p.charAt(i)-'a']+=1;
           window[s.charAt(i)-'a']+=1;

       }
       if(match(pint,window)){
           list.add(0);
       }
       for(int i=0,j=plen;j<slen;i++,j++){
           window[s.charAt(i)-'a']--;
           window[s.charAt(j)-'a']++;
           if(match(pint,window)){
               list.add(i+1);
           }
       }
        return list;

    


    }
    public boolean match(int[] a,int[] b){
        for(int i=0;i<a.length;i++){
            if(a[i]!=b[i]){
                return false;
            }
        }
        return true;
    }
}
```





#### [76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)

![image-20200728152754728](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200728152754728.png)

```java

class Solution {
    public String minWindow(String s, String t) {
        //滑动窗口
        Map<Character,Integer> window = new HashMap<>();
        //需要组成的
        Map<Character,Integer> need = new HashMap<>();
        //填充need
        for(int i=0;i<t.length();i++){
            need.put(t.charAt(i),need.getOrDefault(t.charAt(i),0)+1);
        }
        //左右指针,[left,right),左闭右开
        int left = 0;
        int right = 0;
        //window中有几个是有效的
        int valid = 0;
        //记录子串的开始节点
        int start = 0;
        //记录子串的长度
        int len = Integer.MAX_VALUE;

        while(right<s.length()){
            //当前字符
            char c = s.charAt(right);
            //右指针加一,将当前字符c加入到了滑动窗口中
            right++;
            //如果当前字符是需要的
            if(need.containsKey(c)){
                //窗口的map中加入它
                window.put(c,window.getOrDefault(c,0)+1);
                //如果这个字符在need和window中的数量一样,意味着它有效了
                if(window.get(c).equals(need.get(c))){
                    valid++;
                }
            }
            //当有效的字符和need中的个数相同时候,窗口中就是一个解了,接着求最短的字符,从左边将窗口缩小
            while(valid==need.size()){
                //更新最优解
                if(right-left<len){
                    start = left;
                    len = right-left;
                }

                char d = s.charAt(left);
                left++;
                //如果移除的这个字符是被需要的
                if(need.containsKey(d)){
                    //第一次的时候将有效个数减一
                    if(window.get(d).equals(need.get(d))){
                        valid--;
                    }
                    if(window.containsKey(d)){
                        window.put(d,window.get(d)-1);
                    }
                }
            }
        }

        return len==Integer.MAX_VALUE?"":s.substring(start,start+len);

    }
}
```

#### [567. 字符串的排列](https://leetcode-cn.com/problems/permutation-in-string/)









```java
class Solution {
    
    public boolean checkInclusion(String s1, String s2) {
        Map<Character,Integer> need = new HashMap<>();
        Map<Character,Integer> window = new HashMap<>();

        for(int i=0;i<s1.length();i++){
            need.put(s1.charAt(i),need.getOrDefault(s1.charAt(i),0)+1);
        }
        int left = 0;
        int right = 0;
        int vialid = 0;

        while(right<s2.length()){
            char c = s2.charAt(right);
            right++;
            if(need.containsKey(c)){
                window.put(c,window.getOrDefault(c,0)+1);
                if(need.get(c).equals(window.get(c))){
                    vialid++;
                }
            }
            if(vialid==need.size()){
                return true;
            }
            if((right-left)>=s1.length()){
                
                 char d = s2.charAt(left);
                left++;
                //如果移除的这个字符是被需要的
                if(need.containsKey(d)){
                    //第一次的时候将有效个数减一
                    if(window.get(d).equals(need.get(d))){
                        vialid--;
                    }
                    if(window.containsKey(d)){
                        window.put(d,window.get(d)-1);
                    }
                }
              
            }

        }
        return false;
    }
}
```

```java
class Solution {
    String s2;
    public boolean checkInclusion(String s1, String s2) {
        int n1 = s1.length();
        int n2 = s2.length();
        if(n1>n2){
            return false;
        }
        char[] s1arr = s1.toCharArray();
        char[] s2arr = s2.toCharArray();
        return helper(s1arr,s2arr);
        
 
        

    }
 
    public boolean helper(char[] s1,char[] s2){
         int[] a1 = new int[26];
        
        for(char c:s1){
            a1[c-'a']+=1;
        }
       for(int i=0;i<=s2.length-s1.length;i++){
           int[] a2 = new int[26];
           for(int j = 0;j<s1.length;j++){
               a2[s2[i+j]-'a']+=1;
           }
           if(math(a1,a2)){
               return true;
           }
       }
        return false;
    }
    public boolean math(int[] a1,int[] a2){
        for(int i=0;i<26;i++){
            if(a1[i]!=a2[i]){
                return false;
            }
        }
        return true;
    }
}
```



## 贪心算法

#### [910. 最小差值 II](https://leetcode-cn.com/problems/smallest-range-ii/)

![image-20200616182656508](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200616182656508.png)

求A数组里面个元素±K后的最大值和最小值的最小的差值，第一想法就是
A数组中的最大值-K，最小值+K，然后求差值肯定是最小的，
那么，为了便于理解，将A数组排序，A[0]是最小值，A[-1]是最大值，为了缩短两头的距离，对于低排序的元素均+K，对于高排序的元素均—K
那么，在数组中总会出现index=i以及其之前元素+K，从i+1开始，以后的元素-K
由于低排序的元素整体+K，高排序的元素整体—K，那么就有可能出现整体+K的最后一个元素中A[i]+K 是大于 整体—K的高排序的元素中的最大值A[-1]-K的，因此，需要在这里加以判断，在新的数组B中，最大值是来自于A[i]+K还是A[-1]-K；
同样的，最小值也需要判断是来自于前部分数组的A[0]+K还是后部分数组A[j]-K；
所以针对以上两种情况分别取最大值和最小值，然后随着i位置变化，找寻小差值

代码



```java

class Solution {
    public int smallestRangeII(int[] A, int K) {
        Arrays.sort(A);
        int length = A.length;
    
        int max = A[length-1];
        int min = A[0];
        int ans = max-min;
        for(int i=0;i<length-1;i++){
            int j=i+1;
            int hight = Math.max(max-K,A[i]+K);
            int slow = Math.min(min+K,A[j]-K);

            ans = Math.min(ans,hight-slow);
        }
        return ans;
    }
}
```



#### [82. 删除排序链表中的重复元素 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/)



![image-20200708182849025](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200708182849025.png)



为了方便处理头结点，这里我们添加一个哨兵节点p0，让他指向head！（实不相瞒是看大佬题解学到的超级有用！！）
（所有链表题加一个哨兵节点都可以非常方便处理头部节点！）

然后就用一前一后的p1,p2指针来查看是否有相同的节点，这里我分两种情况
如果有相同的节点：（r=1)
就让p2后移直到一个新节点
直接用p1.next=p2.next 就可以删掉所有重复节点啦！！
如果没有相同的节点：(r=0)
就是寻常的p1,p2后移即可



```java
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if(head==null||head.next==null){
            return head;
        }
        ListNode p0 = new ListNode(-1);
        p0.next = head;
        ListNode p1 = p0;
        ListNode p2 = head;
        int r = 0;
        while(p1.next!=null){
            while(p2.next!=null&&p1.next.val==p2.next.val){
                p2 = p2.next;
                r = 1;
            }
            if(r==1){
                p1.next = p2.next;
                p2 = p2.next;
                r = 0;
                
            }else{
                p1 = p2;
                if(p2.next!=null){
                    p2 = p2.next;
                }
            }

        }
        return p0.next;
     
    }
}


```



## 图

### 最小生成树

#### [1135. 最低成本联通所有城市](https://leetcode-cn.com/problems/connecting-cities-with-minimum-cost/)

```java
class Solution {
    public int minimumCost(int N, int[][] connections) {
        int[] parent = new int[N+1];//parent[i]表示i的父亲,可以理解为i所在区域的队长,一开始就是他自己
        for (int i = 0; i <= N; i++) {
            parent[i] = i;
        }

        Arrays.sort(connections, (int[] o1,int[] o2)->o1[2]-o2[2]);
        int count = 0;
        int cost = 0;
        for (int[] edg : connections) {
            if (findParent(edg[0], parent) != findParent(edg[1], parent)) {//如果两个节点的队长不一样,说明他们不在同一个区域,就不会形成环
                union(edg[0], edg[1], parent);//将两个节点放在同一个区域,选出共同的队长
                count++;
                cost += edg[2];
            }

            if (count == N - 1) {
                break;
            }
        }

        if (count != N - 1) {
            return -1;
        }

        return cost;
    }

    /**
     * 这里Union 需要注意，是parent[px] = py;
     * 没有做路径压缩，如果要做压缩，需要一个size数组记录个数
     */
    private void union(int x, int y, int[] parent) {
        int px = findParent(x, parent);//x的队长
        int py = findParent(y, parent);//y的队长
        parent[px] = py;//两个的队长不相等,将y的队长设置为x队长的队长.
      
    }

    private int findParent(int x, int[] parent) {
        if (parent[x] != x) {
            while (parent[x] != x) {//循环找到它的队长
                x = parent[x];
            }
        }
        return x;
    }
}

```



广度优先搜索

```java
// 节点访问标识,访问过的节点无需访问（剪枝）
int[][] visited = new int[m][n];
// 队列初始化
Queue<Node> queue = new LinkedList();

// 【第1步】将起点加入队列, 非空进入循环
queue.add(第一个数据)
while(!queue.isEmpty()) {
    // 【第2步】 获取当前队列长度即同一层级（辈分）节点个数，并遍历
    int size = queue.size(); // 一定要先获取，queue后面要加入下一层级节点
    for (int i = 0; i < size; i++) {
        // 【第3步】 对同一层级节点逐个寻找下一层有效**路径节点**，找到目标直接返回结果终止搜索。
        Node node = queue.poll();
        // 下一层节点 比如网格上下左右移动
        Node nextNode = node.x + xj;
        //  1. 不符合要求的下一层节点直接过滤（比如越界、已经被visited[][]标记访问了）
        //  2. 找到目标节点 直接返回结果
        //  3. 符合要求的下一层节点放入队列
        queue.offer(nextNode)
    }
}
// 【第4步】 BFS搜索完成没找到结果，返回-1
return -1;

作者：jin-129
链接：https://leetcode-cn.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/solution/wang-ge-zhong-de-zui-duan-lu-jing-bfssuan-fa-shi-x/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```







## 链表

请判断一个链表是否为回文链表。

```java

class Solution {
    public boolean isPalindrome(ListNode head) {
        if(head==null||head.next==null){
            return true;
        }
        ListNode fast = head;
        ListNode slow = head;
        ListNode cur = head;
        ListNode pre = null;

        while(fast!=null&&fast.next!=null){
            cur = slow;
            fast = fast.next.next;
            slow = slow.next;
            cur.next = pre;
            pre = cur;
        }
        if(fast!=null){
            slow = slow.next;
        }
        while(cur!=null){
            if(cur.val != slow.val){
                return false;
            }
            cur = cur.next;
            slow = slow.next;

        }
        return true;




    }
}
```



排列组合：

例如1,2,3,4排列组合

```java
public class Main {
     
    public static Stack<Integer> stack = new Stack<Integer>();
    public static void main(String[] args) {
        int shu[] = {1,2,3,4};
        f(shu,4,0);
    }
    /**
     *
     * @param shu   待选择的数组
     * @param targ  要选择多少个次
     * @param cur   当前选择的是第几次
     */
    private static void f(int[] shu, int targ, int cur) {
        // TODO Auto-generated method stub
        if(cur == targ) {
            System.out.println(stack);
            return;
        }
         
        for(int i=0;i<shu.length;i++) {
            if(!stack.contains(shu[i])) {
                stack.add(shu[i]);
                f(shu, targ, cur+1);
                stack.pop();
            }
             
        }
    }
 
}


class Solution {
    List<List<Integer>> list = new ArrayList<>();
    public List<List<Integer>> permute(int[] nums) {
        helper(nums,nums.length,0,new Stack<>());
        return list;


    }
    public void helper(int[] nums,int targ,int cur,Stack arr){
        if(targ==cur){
           list.add(new ArrayList(arr));
            return;
        }
        for(int i=0;i<nums.length;i++){
            if(!arr.contains(nums[i])){
                arr.push(nums[i]);
                helper(nums,targ,cur+1,arr);
                arr.pop();
            }
        }
        
    }
  
}


class Solution {
    List<List<Integer>> list = new ArrayList<>();
    public List<List<Integer>> permute(int[] nums) {
        helper(nums,0,nums.length);
        return list;


    }
    public void helper(int[] nums,int from,int to){
        if(from==to){
            List res = new ArrayList();
            for(int a:nums){
                res.add(a);
            }
            list.add(res);
          
            return;
        }
        for(int i=from;i<to;i++){
            swap(nums,from,i);
            helper(nums,from+1,to);
             swap(nums,from,i);
           
        }
    }
        
    private static void swap(int[] arr, int a, int b) {
        int tmp = arr[a];
        arr[a] = arr[b];
        arr[b] = tmp;
    }
}
```

```java
public class AllPerm{
    public static void main(String[] args){
        String s = "abc";
        perm(s.toCharArray(),0,s.length()-1);
    }
    private static void swap(char[] str,int a,int b){
        char tmp  = str[a];
        str[a] = str[b];
        str[b] = temp;
    }
    public static void perm(char[] str,int from,int to){
        if(from==to){
            System.out.println(str);
            return;
        }
        for(int j = from;j<to;j++){
            swap(str,from,j);
            perm(str,from+1,to);
            swap(str,from,j);
        }
    }
}
```

![image-20200713230235818](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200713230235818.png)

```java
class Solution {
       List<List<Integer>> list = new ArrayList<>();
    
    public List<List<Integer>> subsets(int[] nums) {
     
        if(nums.length==0){
            return list;
        }
           List<Integer> arr = new ArrayList<Integer>();
        helper(nums,arr,0);
        return list;



    }
    public void helper(int[] nums,List arr,int pos){
        if(pos==nums.length){
            list.add(new ArrayList(arr));//注意添加的时候，要New出一个新的列表出来
            return;
        }
        helper(nums,arr,pos+1);
        arr.add(nums[pos]);
        helper(nums,arr,pos+1);
        arr.remove(arr.size()-1);
    }
}
```



![image-20200713230252805](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200713230252805.png)





在1,2,3,4中选3个的组合

```java
public class Main {
     
    public static Stack<Integer> stack = new Stack<Integer>();
    public static void main(String[] args) {
        int shu[] = {1,2,3,4};
         
        f(shu,3,0,0); // 从这个数组4个数中选择三个
    }
     
    /**
     *
     * @param shu  元素
     * @param targ  要选多少个元素
     * @param has   当前有多少个元素
     * @param cur   当前选到的下标
     *
     * 1    2   3     //开始下标到2
     * 1    2   4     //然后从3开始
     */
    private static void f(int[] shu, int targ, int has, int cur) {
        if(has == targ) {
            System.out.println(stack);
            return;
        }
         
        for(int i=cur;i<shu.length;i++) {
            if(!stack.contains(shu[i])) {
                stack.add(shu[i]);
                f(shu, targ, has+1, i);
                stack.pop();
            }
        }
         
    }
}
```



## 算法总结

[Java中List转换为数组,数组转List]

List转换为Array可以这样处理：

ArrayList<String> list=new ArrayList<String>();

String[] strings = new String[list.size()];

list.toArray(strings);

反过来，如果要将数组转成List怎么办呢？如下：

String[] s = {"a","b","c"};
List list = java.util.Arrays.asList(s);



**int到Integer:**

int a=3;
Integer A=new Integer(a);

或:
Integer A=Integer.valueOf(a);

**Integer到int:**

Integer A=new Integer(5);

int a=A.intValue();

至于Integer.parseInt(String str)则是将String类型转为int类型。

```java
降序

 Integer[] a = new Integer[]{3,5,9};
 Arrays.sort(a, ( Integer o1, Integer o2) -> { return o2-o1;});//>0就交换


 int[][] people = new int[2][2];
  Arrays.sort(people,(int[] o1,int[] o2)->{return o1[0]==o2[0]?o1[1]-o2[1]:o2[0]-o1[0];});

```





1.字符串中的数字子串求和：

- 四个变量：累加和res，整型变量num，符号位posi，当前字符cur
- 把累加的时机放在char不是数字字符的时候
- 如果char不是数字，num清零，处理符号。
- 如果str以数字结尾，为了使最后一个数字累加，遍历完之后再执行一次累加。

2.去除字符串中连续出现k个0的子串

- 两个变量，整形变量count，目前连续0的个数。start,表示连续0出现的开始的位置
- 如果char是0，start=start==-1?i:start。count++;
- 如果char不是0，则进行处理
- 最后遍历完再处理一次。

3.将整形数字字符串转换为整数值

- 4个变量。布尔型posi，

4.





## 背包问题

### 01背包

```
01背包的状态转换方程 f[i,j] = Max{ f[i-1,j-Wi]+Pi( j >= Wi ),  f[i-1,j] }

0-1背包问题是指每一种物品都只有一件，可以选择放或者不放。现在假设有n件物品，背包承重为m。

对于这种问题，我们可以采用一个二维数组去解决：f[i][j]，其中i代表加入背包的是前i件物品，j表示背包的承重，f[i][j]表示当前状态下能放进背包里面的物品的最大总价值。那么，f[n][m]就是我们的最终结果了。

采用动态规划，必须要知道初始状态和状态转移方程。初始状态很容易就能知道，那么状态转移方程如何求呢？对于一件物品，我们有放进或者不放进背包两种选择：

 （1）假如我们放进背包，f[i][j] = f[i - 1][j - weight[i]] + value[i]，这里的f[i - 1][j - weight[i]] + value[i]应该这么理解：在没放这件物品之前的状态值加上要放进去这件物品的价值。而对于f[i - 1][j - weight[i]]这部分，i - 1很容易理解，关键是 j - weight[i]这里，我们要明白：要把这件物品放进背包，就得在背包里面预留这一部分空间。

 （2）假如我们不放进背包，f[i][j] = f[i - 1][j]，这个很容易理解。

  因此，我们的状态转移方程就是：f[i][j] = max(f[i][j] = f[i - 1][j] , f[i - 1][j - weight[i]] + value[i]) 

  当然，还有一种特殊的情况，就是背包放不下当前这一件物品，这种情况下f[i][j] = f[i - 1][j]。
```



```java
    public static int method(int m,int[] volumes,int[] values){
        int n = volumes.length;
        int[][] dp = new int[n+1][m+1];
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                if(volumes[i-1]>j){
                    dp[i][j] = dp[i-1][j];
                }else {
                    dp[i][j] = Math.max(dp[i-1][j-volumes[i-1]]+values[i-1],dp[i-1][j]);
                }
            }
        }
        return dp[n][m];
    }
```

![image-20200825220523543](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200825220523543.png)

```java
 //内循环倒序
public static int method(int m,int[] volumes,int[] values){
        int n = volumes.length;
        int[] dp = new int[m+1];
        for(int i=1;i<=n;i++){
            for(int j=m;j>=1;j--){
                if(j>=volumes[i-1]){
                    dp[j] = Math.max(dp[j],dp[j-volumes[i-1]]+values[i-1]);
                }
            }

        }
        return dp[m];
    }
```



### 完全背包



完全背包就是每个物品有无数件,如换零钱问题

```java
//内循环顺序
public static int method(int m,int[] volumes,int[] values){
        int n = volumes.length;
        int[] dp = new int[m+1];
        for(int i=1;i<=n;i++){
            for(int j=volumes[i-1];j<=m;j++){
                    dp[j] = Math.max(dp[j],dp[j-volumes[i-1]]+values[i-1]);
            }

        }
        return dp[m];
    }
```



```
关于为什么是顺序，用没有优化过存储的递归表达式来说明的话。0-1背包问题是d[i][j]=Max(d[i-1][j],d[i-1][j-w[i]]+v[i])，而完全背包问题是d[i][j]=Max(d[i-1][j],d[i][j-w[i]]+v[i])。
```



### 多重背包

问题描述：多重背包是在01背包的基础上，加了个条件：第 i 件物品有ni件。

![img](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/20180818100850203.png)



![img](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/20180818100900300.png)

![img](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/20180818100913126.png)

![img](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/20180818100923717.png)



## DFS

#### [39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)

![image-20200826135633336](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200826135633336.png)

```java
class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        Arrays.sort(candidates);
        List<List<Integer>> list = new ArrayList<>();
        int n = candidates.length;
        dfs(candidates,n,0,target,new ArrayDeque<Integer>(),list);
        return list;

       

    }

    public void dfs(int[] candidates,int len,int start,int target,Deque<Integer> path,List<List<Integer>> list){
        if(target==0){
            list.add(new ArrayList(path));
            return;
        }
     
        for(int i=start;i<len;i++){
               if(target<candidates[i]){
                  break;
                }
            path.addLast(candidates[i]);
            dfs(candidates,len,i,target-candidates[i],path,list);
            path.removeLast();
        }
    }
}
```

#### [40. 组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/)

![image-20200826135724922](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200826135724922.png)

唯一不同的是，candidates中含有重复的数字，如果不加以判断，按着组合总和的写法来写话，结果中肯定会有重复的（比如【1,1,2】）
[1,2]和[1,2]是一样的，这样肯定是重复的，所以我们需要加个判断，在判断之前需要对数组排序，
判断的条件是当前值等于前一个值的话，就跳过，执行下一个循环
比如【1,1,2】
1 == 1
所以要跳过下标为1（值等于1）的循环
if i > 0 and candidates[i] == candidates[i - 1]:
continue
就是这个判断条件
因为要求candidates 中的每个数字在每个组合中只能使用一次，所以进入下一层时选择的数就要从上一层选的值的下一个
递归结束 条件同组合总和

```java
class Solution {
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        List<List<Integer>> list = new ArrayList<>();
        Arrays.sort(candidates);
        dfs(candidates,candidates.length,0,target,list,new LinkedList<Integer>());
        return list;


    }
    public void dfs(int[] candidates,int len,int start,int target,List<List<Integer>> list,LinkedList<Integer> path){
        if(target==0){
            list.add(new ArrayList(path));
            return;
        }
        for(int i=start;i<len;i++){
            if(i>start&&candidates[i]==candidates[i-1]){
                continue;
            }
            if(target<candidates[i]){
                break;
            }
            path.addLast(candidates[i]);
            dfs(candidates,len,i+1,target-candidates[i],list,path);
            path.removeLast();

        }
    }
}
```

#### [216. 组合总和 III](https://leetcode-cn.com/problems/combination-sum-iii/)

![image-20200826141654328](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200826141654328.png)

```java
class Solution {
    public List<List<Integer>> combinationSum3(int k, int n) {
        List<List<Integer>> list = new ArrayList<>();
         LinkedList<Integer> tmp = new LinkedList<>();
        dfs(1,n,list,tmp,k,0);
        return list;
        

    }
    public void dfs(int index,int n,List<List<Integer>> list,LinkedList<Integer> path,int k,int sum){
        if(path.size()==k){
            if(sum==n){
                list.add(new ArrayList(path));
            }
            return;
        }
        if(sum+index>n){
            return;
        }
        if(index>9){
            return;
        }
        for(int i=index;i<=9;i++){
            path.addLast(i);
            index++;
            dfs(index,n,list,path,k,sum+i);
            path.removeLast();
        }
    }
}
```



#### [77. 组合](https://leetcode-cn.com/problems/combinations/)

![image-20200826135934748](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200826135934748.png)

```java
class Solution {
    public List<List<Integer>> combine(int n, int k) {
        List<List<Integer>> list = new ArrayList<>();
        if(k>n){
            return list;
        }
        LinkedList<Integer> tmp = new LinkedList<>();
        dfs(1,n,list,tmp,k);
        return list;


    }
    public void dfs(int index,int n,List<List<Integer>> list,LinkedList<Integer> tmp,int k){
        if(tmp.size()==k){
            list.add(new ArrayList(tmp));
            return;
        }
        if(index>n){
            return;
        }
        for(int i=index;i<=n;i++){

             tmp.addLast(i);
             index++;//这里需要注意点,如果直接dfs(index+1,n,list,tmp,k);会把前面的数也加进来了.会出现[3,3],[3,2]
             dfs(index,n,list,tmp,k);
             tmp.removeLast();
        }
       
    }
}
```



#### [377. 组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv/)

![image-20200826135840633](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200826135840633.png)



```java
class Solution {
    public int combinationSum4(int[] nums, int target) {
        // Arrays.sort(nums);
        int n = nums.length;
        int[] dp = new int[target+1];
        dp[0] = 1;
        for(int i=1;i<=target;i++){
           for(int j=0;j<n;j++){
               if(i>=nums[j]){
                   dp[i]+=dp[i-nums[j]];
               }
           }
        }
        return dp[target];

    }
}
```

#### [254. 因子的组合](https://leetcode-cn.com/problems/factor-combinations/)



![image-20200826150731220](image/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A/image-20200826150731220.png)

```java
class Solution {
    public List<List<Integer>> getFactors(int n) {
        List<List<Integer>> list = new ArrayList<>();
        LinkedList<Integer> tmp = new LinkedList<>();
        dfs(2,list,tmp,n);
        return list;

    }
    public void dfs(int index,List<List<Integer>> list,LinkedList<Integer> tmp,int target){
        if(target==1){
            if(tmp.size()>1){
                 list.add(new ArrayList(tmp));
            }
            return;
        }
        for(int i=index;i*i<=target;i++){

            if(target%i==0){
                tmp.addLast(i);
                ///下面是直接把生成的结果添加进去了,才能保证在i*i<=target能够找到元素16
                // 比如32,结果为[[2,16],[2,2,8],[2,2,2,4],[2,2,2,2,2],[2,4,4],[4,8]]
                tmp.addLast(target/i);
                list.add(new ArrayList(tmp));
                tmp.removeLast();
                ///
                dfs(i,list,tmp,target/i);
                tmp.removeLast();
            }
        }
    
    }
}
```







































