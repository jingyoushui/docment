

## 1.算法基础

### 数组

颠倒数组元素的顺序：

```java
int N = a.length;
for(int i=0;i<N/2;i++){
    double temp = a[i];
    a[i] = a[N-1-i];
    a[N-1-i] = temp;
}
```

矩阵相乘：

```java
int N= a.length;
double[][] c = new double[N][N];
for(int i = 0;i<N;i++){
    for(int j=0;j<N;j++){
        for(int k=0;k<N;k++){
            c[i][j] += a[i][k]*b[k][j];
        }
    }
}
```

### 递归

递归三要素：

- 最简单的情况，也就是递归的出口，方法的第一条语句总是一个包含return的条件语句
- 递归调用总是会尝试解决一个规模更小的子问题
- 递归调用的父方法和尝试解决的子问题之间不应该有交集。

### Math函数库：

java.lang.Math

![](/home/lixing/文档/image/选区_293.png)

![](/home/lixing/文档/image/选区_294.png)









### union-find算法

API:

```java
public class UF(){
    UF(int N);
    void union(int p,int q);//在p和q之间添加一条连接
    int find(int p);//p所在的分量的标识
    boolean connected(int p,int q);//pq是否在同一个分量
    int count();//连通分量的数量
}
```

实现：

quick-find算法：

当且仅当id[p]和id[q]相等时，p和q是连通的。

```java
package unionfind;

import java.util.Scanner;

public class QuickFindUF {
    private int[] id;    // id[i] = component identifier of i
    private int count;   // number of components

    /**
     * Initializes an empty union-find data structure with
     * {@code n} elements {@code 0} through {@code n-1}.
     * Initially, each elements is in its own set.
     *
     * @param  n the number of elements
     * @throws IllegalArgumentException if {@code n < 0}
     */
    public QuickFindUF(int n) {
        count = n;
        id = new int[n];
        for (int i = 0; i < n; i++)
            id[i] = i;
    }

    /**
     * Returns the number of sets.
     *
     * @return the number of sets (between {@code 1} and {@code n})
     */
    public int count() {
        return count;
    }

    /**
     * Returns the canonical element of the set containing element {@code p}.
     *
     * @param  p an element
     * @return the canonical element of the set containing {@code p}
     * @throws IllegalArgumentException unless {@code 0 <= p < n}
     */
    public int find(int p) {
        validate(p);
        return id[p];
    }

    // validate that p is a valid index
    private void validate(int p) {
        int n = id.length;
        if (p < 0 || p >= n) {
            throw new IllegalArgumentException("index " + p + " is not between 0 and " + (n-1));
        }
    }

    @Deprecated
    public boolean connected(int p, int q) {
        validate(p);
        validate(q);
        return id[p] == id[q];
    }

    public void union(int p, int q) {
        validate(p);
        validate(q);
        int pID = id[p];   // needed for correctness
        int qID = id[q];   // to reduce the number of array accesses

        // p and q are already in the same component
        if (pID == qID) return;

        for (int i = 0; i < id.length; i++)
            if (id[i] == pID) id[i] = qID;
        count--;
    }

 
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();//多少个节点
        int line = scanner.nextInt();//多少行数据
        QuickFindUF uf = new QuickFindUF(n);
        while (line-->0) {
            int p = scanner.nextInt();
            int q = scanner.nextInt();
            if (uf.find(p) == uf.find(q)) continue;
            uf.union(p, q);
            System.out.println(p + "->" + q);
        }
        System.out.println(uf.count() + " components");
    }

}

//10
//11
//4 3
//3 8
//6 5
//9 4
//2 1
//8 9
//5 0
//7 2
//6 1
//1 0
//6 7

```

这个算法无法处理大型问题，因为对应每个输入union()都会扫描整个id[]数组

quick-union算法：

每个触点所对应的id[]元素都是同一个分量中的另一个触点的名称（也可能是它自己）。这样每个触电就能一直找到自己的跟触点，如果p和q的根节点相同，那么说明他们在同一个连通分量中，如果不同，将他们连接在一起。

```java
package unionfind;

import java.util.Scanner;

public class QuickUnionUF {
    private int[] parent;  // parent[i] = parent of i
    private int count;     // number of components

    public QuickUnionUF(int n) {
        parent = new int[n];
        count = n;
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }


   
    public int count() {
        return count;
    }

    /**
     * Returns the canonical element of the set containing element {@code p}.
     *
     * @param  p an element
     * @return the canonical element of the set containing {@code p}
     * @throws IllegalArgumentException unless {@code 0 <= p < n}
     */
    public int find(int p) {
        validate(p);
        while (p != parent[p])
            p = parent[p];
        return p;
    }

    // validate that p is a valid index
    private void validate(int p) {
        int n = parent.length;
        if (p < 0 || p >= n) {
            throw new IllegalArgumentException("index " + p + " is not between 0 and " + (n-1));
        }
    }

    /**
     * Returns true if the two elements are in the same set.
     */
    @Deprecated
    public boolean connected(int p, int q) {
        return find(p) == find(q);
    }

    public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) return;
        parent[rootP] = rootQ;
        count--;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();//多少个节点
        int line = scanner.nextInt();//多少行数据
        QuickUnionUF uf = new QuickUnionUF(n);
        while (line-->0) {
            int p = scanner.nextInt();
            int q = scanner.nextInt();
            if (uf.find(p) == uf.find(q)) continue;
            uf.union(p, q);
            System.out.println(p + "->" + q);
        }
        System.out.println(uf.count() + " components");
    }
}

```



### 背包、队列和栈



背包(Bag),队列(Queue)和栈(Stack)，其实就是一组对象的集合，所有的操作都是关于添加删除或访问集合中的对象，不同之处就是添加删除或访问对象的顺序不同。

#### API：

背包：

```java
public class Bag<Item> implements Iterable<Item>{
    Bag();//创建一个空背包
    void add(Item item);//添加 一个元素
    boolean isEmpty();//背包是否为空
    int size();//元素数量
}
```

先进先出队列：

```java
public class Queue<Item> implements Iterable<Item>{
    Queue();
    void enqueue(Item item);//添加一个元素
    Item dequeue();//删除最近添加的元素
    boolean isEmpty();
    int size()
}
```

后进先出栈：

```java
public class Stack<Item> implements Iterable<Item>{
    Stack();
    void push(Item item);//添加一个元素
    Item pop();
    boolean isEmpty();
    int size();
      
}
```

泛型（也叫参数化类型）：如上面的<Item>将Item定义为一个类型参数，它只是一个象征性的占位符，表示的是用例将会使用的某种具体的数据类型。

自动装箱：类型参数必须被实例化为引用类型，java的封装类型都是`原始数据类型`（也叫基本数据类型）所对应的`引用类型`，如封装类型Boolean,Byte,Character,Double,Float,Integer,Long,Short分别对应的原始类型boolean,byte,char,double,float,int,long,short.

1.基本类型只能按值传递，而每个基本类型对应的封装类是按引用传递的。 
2.从性能上说java中的基本类型是在堆栈上创建的，而所有的对象类型都是在堆上创建的，（对象的引用在堆栈上创建）。比如 Integer i=new Integer(10); 其中new Integer()是在堆上创建的，而他的引用Integer i是在堆栈上。 封装类的出现，是为了更方便的使用一些基本类型不具备的方法，比如valueOf（），toString（）等等。还有你如果想传递一个int对象的引用，而不是值，那只能用封装类。 

引用类型（reference type）指向一个对象，不是原始值，指向对象的变量是引用变量。在java里面除去基本数据类型的其它类型都是引用数据类型，自己定义的class类都是引用类型，可以像基本类型一样使用。引用类型常见的有：String，StringBuffer，ArrayList，HashSet，HashMap等。

java会自动在引用类型和对应的原始数据类型之间进行转换。

```java
Stack<Integer> stack = new Stack<Integer>();
stack.push(17);//自动装箱，int -> Integer
int i = stack.pop();//自动拆箱 Integer -> int
```

原始类型对应的引用类型就叫做封装类型，自动的将一个原始类型转换为一个封装类型就叫自动装箱，将一个封装类型转换为原始类型叫做自动拆箱。

背包：不支持删除元素的集合类型，元素的处理顺序不重要。

79页

## 2.排序算法

### 优先队列

优先队列：一种支持下面两种操作的数据结构：删除最大的元素和插入元素。优先队列的使用与队列（删除最老的元素）和栈（删除最新的元素）类似。

泛型优先队列API:

```java
public class MaxPQ extends Comparable<key>{
    MaxPQ();
    MaxPQ(int max);//创建一个最大容量为max的优先队列
    MaxPQ(Key[] a);//用a中的元素创建一个优先队列
    void Insert(Key k);//向优先队列中插入元素
    Key max();//返回最大元素
    Key delMax();//删除并返回最大元素
    boolean isEmpty();//返回队列是否为空
    int size();//返回优先队列中元素的个数
}
```

#### 初级实现

- 数组实现（无序）
- 数组实现（有序）
- 链表表示法

#### 堆实现

当一颗二叉树的每个节点都大于等于它的两个子节点时，它被称为堆有序。跟节点是堆有序的二叉树中的最大节点。

二叉堆：是一组能够用堆有序的完全二叉树排序的元素，并在数组中按照层级储存（不使用数组的第一个位置），位置k的节点的父节点的位置为k/2,子节点为2k和2k+1;使用它们能实现对数级别的插入元素和删除最大元素的操作。利用在数组中无需指针就可以沿着树上下移动的便利和性质。

使用长度为N+1的数组pq[]来表示一个大小为N的堆，不使用pq[0]。

堆实现的比较：

```java
private boolean less(int i,int j){
    return pq[i].compareTo(pq[j])<0;
}
```

堆实现的交换

```java
private void exch(int i,int j){
    Key t = pq[i];
    pq[i] = pq[j];
    pq[j] = t;
}
```

由下至上的堆有序化：

```java
private void swim(int k){
    while(k>1&&less(k/2,k)){
        exch(k/2,k);
        k = k/2;
    }
}
```

由上至下的堆有序化：

```java
private void sink(int k){
    while(2*k<=N){
        int j = 2*k;
        if(j<N&&less(j,j+1)){//找到子节点的较大者
            j++;
        }
        if(!less(k,j)){//如果父节点大于等于子节点，就跳出循环
            break;
        }
        exch(k,j);//交换元素
        k = j;
    }
```

基于堆的优先队列

```java
package 排序;

import java.util.Scanner;
import java.util.Stack;

public class MaxPQ<Key extends Comparable<Key>> {
    private Key[] pq;//基于堆的完全二叉树
    private int N = 0;//存储于pq[]中，pq[0]没有使用

    public MaxPQ(int maxN){
        pq = (Key[]) new Comparable[maxN+1];
    }


    public boolean isEmpty(){
        return N ==0;
    }
    public int size(){
        return N;
    }
    public void insert(Key v){
        pq[++N] = v;//等价与pq[N] = v;N++;
        swim(N);

    }
    public Key delMax(){
        Key max = pq[1];//从跟节点得到最大的元素
        exch(1,N--);//将其与最后一个元素交换，等价于exch(1,N);N--;
        pq[N+1] = null;//防止越界
        sink(1);
        return max;

    }

    public void swim(int k){//上浮
        while(k>1&&less(k/2,k)){
            exch(k/2,k);
            k = k/2;
        }

    }
    public void sink(int k) {//下沉
        while (2 * k <= N) {
            int j = 2 * k;
            if (j < N && less(j, j + 1)) {//找到子节点的较大者
                j++;
            }
            if (!less(k, j)) {//如果父节点大于等于子节点，就跳出循环
                break;
            }
            exch(k, j);//交换元素
            k = j;
        }
    }
    public boolean less(int i,int j){
        return pq[i].compareTo(pq[j])<0;
    }
    public void exch(int i,int j){
        Key t = pq[i];
        pq[i] = pq[j];
        pq[j] = t;
    }

    //创建一个队列的大小为N，输入若干数，返回最小的N个数字
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int N = scanner.nextInt();
        int M = scanner.nextInt();
        MaxPQ<Integer> pq  = new MaxPQ<Integer>(N+1);
        for(int i=0;i<M;i++){
            pq.insert(scanner.nextInt());
            if(pq.size()>N){
                pq.delMax();
            }
        }//最小的N个数在优先队列中
        Stack<Integer> stack = new Stack<Integer>();
        while (!pq.isEmpty()){//按照从大到小的顺序将堆中的N个数保存到栈中
            stack.push(pq.delMax());
        }
        for (Integer x:stack){//从大到小输出最小的N个数
            System.out.println(x);
        }
       
    }

}

```

栈的两种遍历方式：

```java
		stack.push(1);
        stack.push(2);
        stack.push(3);
        stack.push(4);
        stack.push(5);
       for (Integer x:stack){//将按照插入的顺序进行遍历,集合遍历方式
			System.out.println(x);
       }
        while (!stack.isEmpty()){
            System.out.println(stack.pop());
        }
```

索引优先队列：

```java
package 排序;


import java.util.Iterator;
import java.util.NoSuchElementException;
//索引优先序列
public class IndexMinPQ<Key extends Comparable<Key>> implements Iterable<Integer> {
    private int maxN;        // maximum number of elements on PQ
    private int n;           // number of elements on PQ
    private int[] pq;        // binary heap using 1-based indexing
    private int[] qp;        // inverse of pq - qp[pq[i]] = pq[qp[i]] = i
    private Key[] keys;      // keys[i] = priority of i

    public IndexMinPQ(int maxN) {
        if (maxN < 0) throw new IllegalArgumentException();
        this.maxN = maxN;
        n = 0;
        keys = (Key[]) new Comparable[maxN + 1];    // make this of length maxN??
        pq   = new int[maxN + 1];
        qp   = new int[maxN + 1];                   // make this of length maxN??
        for (int i = 0; i <= maxN; i++)
            qp[i] = -1;
    }

    public boolean isEmpty() {
        return n == 0;
    }

    public boolean contains(int i) {
        validateIndex(i);
        return qp[i] != -1;
    }

    public int size() {
        return n;
    }

    public void insert(int i, Key key) {
        validateIndex(i);
        if (contains(i)) throw new IllegalArgumentException("index is already in the priority queue");
        n++;
        qp[i] = n;
        pq[n] = i;
        keys[i] = key;
        swim(n);
    }


    public int delMin() {
        if (n == 0) throw new NoSuchElementException("Priority queue underflow");
        int min = pq[1];
        exch(1, n--);
        sink(1);
        assert min == pq[n+1];
        qp[min] = -1;        // delete
        keys[min] = null;    // to help with garbage collection
        pq[n+1] = -1;        // not needed
        return min;
    }


    public void changeKey(int i, Key key) {
        validateIndex(i);
        if (!contains(i)) throw new NoSuchElementException("index is not in the priority queue");
        keys[i] = key;
        swim(qp[i]);
        sink(qp[i]);
    }

    @Deprecated
    public void change(int i, Key key) {
        changeKey(i, key);
    }



    public void delete(int i) {
        validateIndex(i);
        if (!contains(i)) throw new NoSuchElementException("index is not in the priority queue");
        int index = qp[i];
        exch(index, n--);
        swim(index);
        sink(index);
        keys[i] = null;
        qp[i] = -1;
    }

    // throw an IllegalArgumentException if i is an invalid index
    private void validateIndex(int i) {
        if (i < 0) throw new IllegalArgumentException("index is negative: " + i);
        if (i >= maxN) throw new IllegalArgumentException("index >= capacity: " + i);
    }

    /***************************************************************************
     * General helper functions.
     ***************************************************************************/
    private boolean greater(int i, int j) {
        return keys[pq[i]].compareTo(keys[pq[j]]) > 0;
    }

    private void exch(int i, int j) {
        int swap = pq[i];
        pq[i] = pq[j];
        pq[j] = swap;
        qp[pq[i]] = i;
        qp[pq[j]] = j;
    }


    /***************************************************************************
     * Heap helper functions.
     ***************************************************************************/
    private void swim(int k) {
        while (k > 1 && greater(k/2, k)) {
            exch(k, k/2);
            k = k/2;
        }
    }

    private void sink(int k) {
        while (2*k <= n) {
            int j = 2*k;
            if (j < n && greater(j, j+1)) j++;
            if (!greater(k, j)) break;
            exch(k, j);
            k = j;
        }
    }


    public Iterator<Integer> iterator() { return new HeapIterator(); }

    private class HeapIterator implements Iterator<Integer> {
        // create a new pq
        private IndexMinPQ<Key> copy;

        // add all elements to copy of heap
        // takes linear time since already in heap order so no keys move
        public HeapIterator() {
            copy = new IndexMinPQ<Key>(pq.length - 1);
            for (int i = 1; i <= n; i++)
                copy.insert(pq[i], keys[pq[i]]);
        }

        public boolean hasNext()  { return !copy.isEmpty();                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Integer next() {
            if (!hasNext()) throw new NoSuchElementException();
            return copy.delMin();
        }
    }



    public static void main(String[] args) {
        // insert a bunch of strings
//        String[] strings = { "it", "was", "the", "best", "of", "times", "it", "was", "the", "worst" };
        String[] strings = {"3","6","12","8","6","9","1","3","2","10","22","1"};

        IndexMinPQ<String> pq = new IndexMinPQ<String>(strings.length);
        for (int i = 0; i < strings.length; i++) {
            pq.insert(i, strings[i]);
        }

        // delete and print each key
        while (!pq.isEmpty()) {
            int i = pq.delMin();
            System.out.println(i + " " + strings[i]);
        }
        System.out.println();

        // reinsert the same strings
        for (int i = 0; i < strings.length; i++) {
            pq.insert(i, strings[i]);
        }

        // print each key using the iterator
        for (int i : pq) {
            System.out.println(i + " " + strings[i]);
        }
        while (!pq.isEmpty()) {
            pq.delMin();
        }

    }
}

```

P205堆排序

## 3.查找算法



![选区_035](/home/lixing/文档/image/选区_035.png)

#### 二分查找：

迭代式：

```java
 public int rank(Key key) {
        if (key == null) throw new IllegalArgumentException("argument to rank() is null");

        int lo = 0, hi = n-1;
        while (lo <= hi) {
            int mid = lo + (hi - lo) / 2;
            int cmp = key.compareTo(keys[mid]);
            if      (cmp < 0) hi = mid - 1;
            else if (cmp > 0) lo = mid + 1;
            else return mid;
        }
        return lo;
    }
```

递归式：

```java
public int rank2(Key key,int lo,int hi){
        if(hi<lo) return lo;
        int mid = lo+(hi-lo)/2;
        int cmp = key.compareTo(keys[mid]);
        if(cmp<0) return rank2(key,lo,mid-1);
        else if(cmp>0) return rank2(key,mid+1,hi);
        else return mid;
    }
```

#### 二分查找树

```java
 public Value get(Key key) {
        return get(root, key);
    }
//递归实现
    private Value get(Node x, Key key) {
        if (key == null) throw new IllegalArgumentException("calls get() with a null key");
        if (x == null) return null;
        int cmp = key.compareTo(x.key);
        if      (cmp < 0) return get(x.left, key);
        else if (cmp > 0) return get(x.right, key);
        else              return x.val;
    }
//迭代实现
private Value get2(Key key){
        Node x = root;
        while (x!=null){
            int cmp = key.compareTo(x.key);
            if(cmp==0) return x.val;
            else if(cmp<0) x= x.left;
            else if(cmp>0) x=x.right;
        }
        return null;
    }
```

如果树不是平衡的，函数调用的栈的深度可能会是递归实现的一个问题。

```java
public void put(Key key, Value val) {
        if (key == null) throw new IllegalArgumentException("calls put() with a null key");
        if (val == null) {
            delete(key);
            return;
        }
        root = put(root, key, val);
        assert check();
    }

    private Node put(Node x, Key key, Value val) {
        if (x == null) return new Node(key, val, 1);
        int cmp = key.compareTo(x.key);
        if      (cmp < 0) x.left  = put(x.left,  key, val);
        else if (cmp > 0) x.right = put(x.right, key, val);
        else              x.val   = val;
        x.size = 1 + size(x.left) + size(x.right);
        return x;
    }
```



在由N个随机键构造的二叉查找树中，查找命中平均所需比较次数为2lnN.

在由N个随机键构造的二叉查找树中，插入操作查找未命中平均所需比较次数为2lnN.

删除最小节点：

```java
 public void deleteMin() {
        if (isEmpty()) throw new NoSuchElementException("Symbol table underflow");
        root = deleteMin(root);
        assert check();
    }

    private Node deleteMin(Node x) {
        if (x.left == null) return x.right;
        x.left = deleteMin(x.left);
        x.size = size(x.left) + size(x.right) + 1;
        return x;
    }
```

删除一个节点：

```java
public void delete(Key key) {
        if (key == null) throw new IllegalArgumentException("calls delete() with a null key");
        root = delete(root, key);
        assert check();
    }

    private Node delete(Node x, Key key) {
        if (x == null) return null;

        int cmp = key.compareTo(x.key);
        if      (cmp < 0) x.left  = delete(x.left,  key);//比根节点小，在左子树删除
        else if (cmp > 0) x.right = delete(x.right, key);//比根节点大，在右子树删除
        else {//找到要删除的节点
            if (x.right == null) return x.left;//x右子树为空，用左子树代替它
            if (x.left  == null) return x.right;//x左子树为空，用右子树代替它
            Node t = x;//x左右都不为空，
            x = min(t.right);//查找它的右子树的最小节点，将它赋值给x
            x.right = deleteMin(t.right);//将右子树的最小节点删除，再给当前的x做右子树
            x.left = t.left;//之前的左子树还是左子树
        }
        x.size = size(x.left) + size(x.right) + 1;
        return x;
    }
```



#### 红黑二叉查找树

![Encoding a 3-node in a red-black BST](/home/lixing/文档/image/redblack-encoding.png)

红链接是将两个2-节点连接起来构成一个3-节点。将3-节点表示为由一条左斜的红色连接相连的两个2-节点。对于任意2-3树，经过转换都可以变成二叉查找树。

- 红链接均为左连接
- 没有任何一个节点同时和两条红链接相连
- 该树是完全黑色平衡的，任意空链接到根节点的路径上的黑链接数量相同。

将红链接画平，那么所有空连接到根节点的距离是相同的。将红链接相连的节点合并，一颗红黑树就是一颗2-3树。

![1-1 correspondence between left-leaning red-black BSTs and 2-3 trees](/home/lixing/文档/image/redblack-1-1.png)

每个节点都只有一条链接指向它，就把该链接的颜色保存到该节点中。如果指向它的链接是红色的，那么这个节点就是红节点。



左旋转和右旋转和颜色转换：利用旋转操作可以使得2-3树和红黑树之间一一对应，旋转操作保证了有序性和完美平衡性。

![选区_036](/home/lixing/文档/image/选区_036.png)

- 如果右子节点是红色的而左子节点是黑色的，进行左旋转。
- 如果左子节点是红色的且它的左子节点也是红色的，进行右旋转。
- 如果左右子节点均为红色的，进行颜色转换。



如何保证不存在两条连续的红链接和不存在红色的右链接？

如果插入的节点小于老节点，那么只需新增一个红色节点即可。如果新加入的节点大于老节点，将产生一条红色的右链接，利用左旋转将它转化为红色左链接。





![选区_037](/home/lixing/文档/image/选区_037.png)

向双键树中插入新键：

![选区_038](/home/lixing/文档/image/选区_038.png)















## 4.图论算法

### 无向图

无向图API

```java
public class Graph{
	Graph(int V);//构造一个含有V个顶点但不含有边的图
    Graph(In in);//从标准输入读入一幅图，先是顶点数，然后是边的个数，然后是用顶点对表示的边，
    int V();//获取顶点数
    int E();//获取边数
    void addEdge(int v,int w);//添加一个v-w的边
    Iterable<Integer> adj(int v);//遍历输出和v相邻的所有顶点
    String toString();//对象的字符串表示
        
}
```

最常用的图处理代码：

计算v的度数：

```java
public static int degree(Graph G,int v){
    int degree = 0;
    for(int w:G.adj(v)){
        degree++;
    }
    return degree;
        
}
```

计算所有顶点的最大度数：

```java
public static int maxDegree(Graph G){
    int max=0;
    for(int v=0;v<G.V();v++){
        if(degree(G,v)>max){
            max = degree(G,v);
        }
    }
    return max;
}
```

计算所有顶点的平均度数：

```java
public static double avgDegree(Graph G){
    return 2*G.E()/G.V();
}
```

计算自环的个数：

```java
public static int numberOfSelfLoops(Graph G){
    int count = 0;
    for(int v=0;v<G.V();v++){
        for(int w :G.adj(v)){
            if(v == w);count++;
        }
    }
    return count/2;
}
```

图的邻接表的字符串表示：

```java
public String toString(){
    String s= V+"顶点，"+E+"边\n";
    for(int v=0;v<V;v++){
        s+=v+":";
        for(int w:this.adj(v)){
            s+=w+" ";
        }
        s+="\n";
    }
    return s;
}
```

使用的数据结构：邻接表数组

以顶点为索引的列表数组，其中的每个元素都是 和该顶点相邻的顶点列表。

特点：

- 使用的空间和V+E成正比
- 添加一条边所需要的时间为常数
- 遍历顶点v的所有相邻顶点所需要的时间和v的度成正比

Graph数据类型

```java
package bag_queue_stack;

import java.util.Scanner;

public class Graph{
    private final int V;
    private int E;
    private Bag<Integer>[] adj;
    public Graph(int V){
        this.V = V;this.E = 0;
        adj = (Bag<Integer>[]) new Bag[V];//创建邻接表
        for(int v=0;v<V;v++){
            adj[v] = new Bag<Integer>();
        }
    }
    public Graph(Scanner in){
        this(in.nextInt());
        int E = in.nextInt();
        for(int i=0;i<E;i++){
            int o = in.nextInt();
            int p = in.nextInt();
            addEdge(o,p);
        }
    }
    public int V(){return V;}
    public int E(){return E;}
    public void addEdge(int v,int w){
        adj[v].add(w);
        adj[w].add(v);
        E++;
    }
    public Iterable<Integer> adj(int v){
        return (Iterable<Integer>) adj[v];
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        Graph G = new Graph(scanner);
        DepthFirstSearch searchs = new DepthFirstSearch(G,0);

//        for(int v=0;v<G.V();v++){
//            if(searchs.marked(v)){
//                System.out.print(v+" ");
//            }
//        }
//        for(int i:G.adj(1)){
//            System.out.println(i);
//        }

        DepthFirstPaths paths = new DepthFirstPaths(G,0);
        for(int i:paths.pathTo(3)){
            System.out.println(i);
        }

    }
}

```

判断一个顶点与其他顶点是否连通

```java
public class Graph{
    Search(Graph G,int s);//找到和起点s连通的点
    boolean marked(int v);//v和s是连通的吗
    int count();//与s连通的点的个数
}
```

这个方法是用来判断一个图是不是连通图（从一个顶点出发，可以到达任何节点），其中marked()方法是关键，判断两个顶点是否连通，将通过深度优先搜索算法求解。

####  深度优先搜索算法

```java
package bag_queue_stack;

public class DepthFirstSearch{
    private boolean[] marked;
    private int count;
    public DepthFirstSearch(Graph G,int s){
        marked = new boolean[G.V()];
        dfs(G,s);
    }
    private void dfs(Graph G,int v){
        marked[v] = true;
        count++;
        for(int w:G.adj(v)){
            if(!marked[w]){
                dfs(G,w);
            }
        }
    }
    public boolean marked(int w){
        return marked[w];
    }
    public int count(){
        return count;
    }
}

```

深度优先搜索算法可以用来解决“两个给定的顶点是否连通”，“图中有多少个连通子图”等问题。

- 给定一幅图和一个起点s，问从s到给定目的顶点v是否存在一条路径？如果有，找出这条路径。

#### 寻找路径

```java
public class Paths{
    Paths(Graph G,int s);//在G中找出所有起点为s的路径
    boolean hasPathTo(int v);//是否存在从s到v的路径
    Iterable<Integer> pathTo(int v);//s到v的路径，如果不存在则返回null
}
```

使用深度优先搜索寻找路径

```java
import java.util.Stack;

public class DepthFirstPaths {
    private boolean[] marked;//这个顶点上调用过dfs()了吗
    private int[] edgeTo;//从起点到一个顶点的已知路径上的最后一个顶点
    private final int s;//起点

    public DepthFirstPaths(Graph G, int s){
        marked = new boolean[G.V()];
        edgeTo = new int[G.V()];
        this.s = s;
        dfs(G,s);

    }
    private void dfs(Graph G,int v){
        marked[v] = true;
        for(int w:G.adj(v)){
            if(!marked[w]){
                edgeTo[w] = v;//表示v-w是第一次访问w时经过的边。是以顶点编号为索引的数组
                dfs(G,w);
            }
        }
    }
    public boolean hasPathTo(int v){
        return marked[v];
    }
    public Iterable<Integer> pathTo(int v){
        if(!hasPathTo(v)){
            return null;
        }
        Stack<Integer> path = new Stack<Integer>();
        for(int x = v;x!=s;x=edgeTo[x]){//从后往前查找，查找第一次到达v时经过了哪个节点，再查这个节点，一直查到起点为止。
            path.push(x);
        }
        path.push(s);
        return path;
    }

}
```

深度优先搜索得到从给定起点到任意标记顶点的路径所需要的时间与路径的长度成正比。

#### 广度优先搜索

解决的问题：

- 给定一幅图和一个起点s，问从s到给定目的顶点v是否存在一条路径，如果有，找出最短路径。

要找到从s到v的最短路径，从s开始，在所有由一条边就可以到达的顶点中寻找v，如果找不到就继续在与s距离两条边的所有顶点中查找

```java
package bag_queue_stack;


import java.util.Stack;

public class BreadthFirstPaths {
    private boolean[] marked;//到达该顶点的最短路径已知吗
    private int[] edgeTo;
    private final int s;//起点

    public BreadthFirstPaths(Graph G,int s){
        marked = new boolean[G.V()];
        edgeTo = new int[G.V()];
        this.s = s;
        bfs(G,s);

    }

    private void bfs(Graph G,int s){
        Queue<Integer> queue = new Queue<Integer>();
        marked[s] = true;//标记起点
        queue.enqueue(s);//将它加入队列
        while (!queue.isEmpty()){
            int v = queue.dequeue();//队列中删除一个顶点
            for(int w:G.adj(v)){
                if(!marked[w]){
                    edgeTo[w] = v;//w是从v来的,且是第一次从v来，即从v来最近。
                    marked[w] = true;
                    queue.enqueue(w);//将它加入队列中
                }
            }
        }

    }
    public boolean hasPathTo(int v){
        return marked[v];
    }
    public Iterable<Integer> pathTo(int v){
        if(!hasPathTo(v)){
            return null;
        }
        Stack<Integer> path = new Stack<Integer>();
        for(int x = v;x!=s;x=edgeTo[x]){
            path.push(x);
        }
        path.push(s);
        return path;
    }
}

```

广度优先搜索最坏情况下所需要的时间和V+E成正比。

#### 连通分量

连通图：若G中任意两个不同的顶点v和w都连通，则G为连通图

连通分量：无向图G的极大连通子图称为G的最强连通分量，不相交的连通子图称为图的连通分量

- 任何连通图的连通分量只有一个，就是它本身
- 非连通的无向图有多个连通分量

API

```java
public class CC{
    CC(Graph G);
    boolean connected(int v,int w);//v和w连通吗
    int count();//连通分量数
    int id(int v);//v所在的连通分量的标识符
}
```

使用深度优先搜索找出图中的所有连通分量

```java
package bag_queue_stack;

public class CC {
    private boolean[] marked;
    private int[] id;//以顶点作为索引的数组id,将同一个连通分量中的顶点和连通分量的标识符关联起来
                    //如果v属于第i个连通分量，则id[v]=i;
    private int count;//表示第几个连通分量，最后的数就代表了连通分量的个数
    public CC(Graph G){
        marked = new boolean[G.V()];
        id = new int[G.V()];
        for(int s=0;s<G.V();s++){
            if(!marked[s]){
                //s的一次递归调用，能访问到所有与它连通的顶点
                dfs(G,s);
                //到这里说明v的连通顶点已经访问完毕
                count++;
            }
        }
    }
    private void dfs(Graph G,int v){
        marked[v] = true;
        id[v] = count;    //如果v属于第i个连通分量，则id[v]=i;
        for(int w:G.adj(v)){
            if(!marked[w]){

                dfs(G,w);

            }
        }
    }
    public boolean connected(int v,int w){
        return id[v] == id[w];
    }
    public int id(int v){
        return id[v];
    }
    public int count(){
        return count;
    }
}

```



检测环：给定的图有环吗？

```java
package bag_queue_stack;


public class Cycle {
    private boolean[] marked;
    private boolean hasCycle;
    public Cycle(Graph G){
        marked = new boolean[G.V()];
        for(int s=0;s<G.V();s++){
            if(!marked[s]){
                dfs(G,s,s);
            }
        }

    }
    //第一个参数v表示当前检测的点，u表示是从u点来的，如果检测出v相邻的点中有已经被标记过的，并且还不是u的话
    //说明有环存在
    private void dfs(Graph G,int v,int u){
        marked[v] = true;
        for(int w:G.adj(v)){
            if(!marked[w]){
                dfs(G,w,v);
            }else if(w!=u){//w点被访问过了，并且它还不是从w-v边上的点，说明现在v点与链上的两个点相邻，就形成了环
                hasCycle = true;
            }
        }
    }
    public boolean hasCycle(){
        return hasCycle;
    }
}

```



双色问题：能够用两种颜色将图中所有点着色，使得任意一条边的两个端点的颜色都不相同。等价与二分图

```java
package bag_queue_stack;

public class TwoColor {
    private boolean[] marked;
    private boolean[] color;
    private boolean isTwoColorable = true;

    public TwoColor(Graph G){
        marked = new boolean[G.V()];
        color = new boolean[G.V()];
        for(int s=0;s<G.V();s++){
            if(!marked[s]){
                dfs(G,s);
            }
        }
    }
    private void dfs(Graph G,int v){
        marked[v] = true;
        for(int w:G.adj(v)){
            if(!marked[w]){
                color[w] = !color[v];
                dfs(G,w);
            }else if(color[w]==color[v]){
                isTwoColorable = false;
            }
        }
    }
    public boolean isBiparite(){
        return isTwoColorable;
    }
}

```



### 有向图

有向图数据结构：

```java
public class Digraph{
    Digraph(int V);
    Digraph(In in);
    int V();
    int E();
    void addEdge(int v,int w);
    Iterable<Integer> adj(int v);
    Digraph reverse();//该图的反向图
    String toString();
}
```

```java
package bag_queue_stack;

public class Digraph {
    private final int V;
    private int E;
    private Bag<Integer>[] adj;
    
    public Digraph(int V){
        this.V = V;
        this.E = 0;
        adj = (Bag<Integer>[]) new Bag[V];
        for(int v=0;v<V;v++){
            adj[v] = new Bag<Integer>();
        }
        
    }
    public Digraph(Scanner in){
        this(in.nextInt());
        int E = in.nextInt();
        for(int i=0;i<E;i++){
            int o = in.nextInt();
            int p = in.nextInt();
            addEdge(o,p);
        }
    }
    public int V(){
        return V;
    }
    public int E(){
        return E;
    }
    public void addEdge(int v,int w){
        adj[v].add(w);
        E++;
    }
    public Iterable<Integer> adj(int v){
        return adj[v];
    }
    public Digraph reverse(){
        Digraph R = new Digraph(V);
        for(int v=0;v<V;v++){
            for(int w:adj(v)){
                R.addEdge(w,v);
            }
        }
        return R;
    }
    
}

```



####　有向图的可达性

```java
package bag_queue_stack;

import java.util.Scanner;

public class DirectedDFS {
    private boolean[] marked;
    public DirectedDFS(Digraph G,int s){//在G中找到从s可到达的所有顶点
        marked = new boolean[G.V()];
        dfs(G,s);
    }
    public DirectedDFS(Digraph G,Iterable<Integer> sources){//在G中找到从sources中的所有顶点可以到达的所有顶点
        marked = new boolean[G.V()];
        for(int s:sources){
            if(!marked[s]){
                dfs(G,s);
            }
        }
    }
    private void dfs(Digraph G,int v){
        marked[v] = true;
        for (int w:G.adj(v)){
            if(!marked[w]){
                dfs(G,w);
            }
        }
    }
    public boolean marked(int v){
        return marked[v];
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        Digraph G = new Digraph(scanner);
        DirectedDFS directedDFS = new DirectedDFS(G,0);


        Bag<Integer> sources = new Bag<Integer>();
        sources.add(1);
        sources.add(2);
        DirectedDFS directedDFS2 = new DirectedDFS(G,sources);
//        for(int v=0;v<G.V();v++){
//            if(directedDFS.marked(v)){
//                System.out.print(v+" ");
//            }
//        }
        for(int v=0;v<G.V();v++){
            if(directedDFS2.marked(v)){
                System.out.print(v+" ");
            }
        }
    }
}

```

在JVM中的垃圾回收的可达性分析算法就是类似的。

#### 环和有向无环图

拓扑排序：给定一副有向图，将所有的顶点排序，使得所有的有向边均从排在前面的元素指向排在后面的元素。

判断有没有环：

```java
package bag_queue_stack;

import java.util.Stack;

public class DirectedCycle {
    private boolean[] marked;
    private int[] edgeTo;
    private Stack<Integer> cycle;//有向环中的所有顶点
    private boolean[] onStack;//递归调用栈上的所有顶点

    public DirectedCycle(Digraph G){
        onStack = new boolean[G.V()];
        edgeTo = new int[G.V()];
        marked = new boolean[G.V()];
        for(int v=0;v<G.V();v++){
            if(!marked[v]){
                dfs(G,v);
            }
        }
    }
    private void dfs(Digraph G,int v){
        onStack[v] = true;
        marked[v] = true;
        for(int w:G.adj(v)){
            if(this.hasCycle())return;
            else if(!marked[w]){
                edgeTo[w] = v;
                dfs(G,w);
            }else if(onStack[w]){
                cycle = new Stack<Integer>();
                for(int x=v;x!=w;x=edgeTo[x]){
                    cycle.push(x);
                }
                cycle.push(w);
                cycle.push(v);
            }
        }
        onStack[v] = false;
    }
    public boolean hasCycle(){
        return cycle!=null;
    }
    public Iterable<Integer> cycle(){
        return cycle;
    }
}

```

#### 有向图基于深度优先搜索的顶点排序

前序：在递归调用之前将顶点加入队列

后序：在递归调用之后将顶点加入队列

逆后序：在递归调用之后将顶点压入栈

```java
package bag_queue_stack;

import java.util.Stack;

public class DepthFirstOrder {
    private boolean[] marked;
    private Queue<Integer> pre;
    private Queue<Integer> post;
    private Stack<Integer> reversePost;
    
    public DepthFirstOrder(Digraph G){
        pre = new Queue<Integer>();
        post = new Queue<Integer>();
        reversePost = new Stack<Integer>();
        marked = new boolean[G.V()];
        for(int v=0;v<G.V();v++){
            if(!marked[v]){
                dfs(G,v);
            }
        }
    }
    private void dfs(Digraph G,int v){
        pre.enqueue(v);
        marked[v] = true;
        for(int w:G.adj(v)){
            if(!marked[w]){
                dfs(G,w);
            }
        }
        post.enqueue(v);
        reversePost.push(v);
        
    }
    public Iterable<Integer> pre(){
        return pre;
    }
    public Iterable<Integer> post(){
        return post;
    }
    public Iterable<Integer> reversPost(){
        return reversePost;
    }
}

```

#### 拓扑排序

一副有向图的拓扑排序即为所有顶点的逆后序排序。

使用深度优先搜索对有向图进行拓扑排序所需要的时间和V+E成正比

```java
package bag_queue_stack;
//拓扑排序
public class Topological {
    private Iterable<Integer> order;//顶点的拓扑顺序
    public Topological(Digraph G){
        DirectedCycle cyclefinder = new DirectedCycle(G);
        if(!cyclefinder.hasCycle()){
            DepthFirstOrder dfs = new DepthFirstOrder(G);
            order = dfs.reversPost();
        }
    }
    public Iterable<Integer> order(){
        return order;
    }
    public boolean isDAG(){
        return order!=null;
    }

}

```



#### 有向图的强连通性

强连通性：如果两个顶点v和w是互相可达的，则称他们为强连通的。如果任意两个顶点都是强连通的，则这幅图也是强连通的。

- 两个顶点是强连通的，当且仅当它们都在一个普通的有向环中。

强连通分量API

```java
public class SCC{
    SCC(Digraph G);
    boolean stronglyConnected(int v,int w);//v和w是强连通的吗
    int count();//强连通分量总数
    int id(int v);//v所在的强连通分量标识符
}
```



Kosaraju算法：

- 在给定的有向图G中，使用深度优先排序来计算它的反向图R的逆后序排列
- 在G中进行标准的深度优先搜索，按照计算好的顺序
- 在构造函数中，所有在同一个递归dfs调用中被访问的顶点都在同一个强连通分量中。

```java
package bag_queue_stack;

public class KosarajuSCC {
    private boolean[] marked;
    private int[] id;
    private int count;

    public KosarajuSCC(Digraph G){
        marked = new boolean[G.V()];
        DepthFirstOrder order = new DepthFirstOrder(G.reverse());
        for(int s:order.reversPost()){
            if(!marked[s]){
              dfs(G,s)  ;
              count++;
            }
        }

    }
    private void dfs(Digraph G,int v){
        marked[v] = true;
        id[v] = count;
        for(int w:G.adj(v)){
            if(!marked[w]){
                dfs(G,w);
            }
        }
    }
    public boolean stronglyConnected(int v,int w){
        return id[v] == id[w];
    }
    public int id(int v){
        return id[v];
    }
    public int count(){
        return count;
    }
}

```



Kosaraju算法的预处理所需要的时间和空间与V+E成正比且支持常数时间的有向图强连通性的查询。

#### 传递闭包

闭包：有向图G的传递传递闭包是由相同的一组顶点组成的另一副有向图，在传递闭包中存在一条从v指向w的边，当且仅当在G中w是从v可达的。

顶点对的可达性：

```java
package bag_queue_stack;

public class TransitiveClosure {
    private DirectedDFS[] all;
    public TransitiveClosure(Digraph G){
        all = new DirectedDFS[G.V()];
        for(int v=0;v<G.V();v++){
            all[v] = new DirectedDFS(G,v);
        }
    }
    public boolean reachable(int v,int w){
        return all[v].marked(w);
    }
}

```



### 最小生成树

图的生成树是它的一颗含有其所有顶点的无环连通子图，一副加权无向图的最小生成树是它的一颗权值和最小的生成树。

原理：

- 切分定理：把加权图中的所有顶点分为两个集合，检查横跨两个集合的所有边，它的横切边中的权重最小者必然属于图的最小生成树。
- 贪心算法：

加权边API: Edge

```java
package 最小生成树;

public class Edge implements Comparable<Edge>{
    private final int v;//顶点之一
    private final int w;//另一个顶点
    private final double weight;//边的权重

    public Edge(int v,int w,double weight){
        this.v = v;
        this.w = w;
        this.weight = weight;
    }

    public double weight(){
        return weight;
    }
    public int either(){
        return v;
    }
    public int other(int vertex){
        if(vertex==v){
            return w;
        }else {
            return v;
        }
    }

    @Override
    public int compareTo(Edge that) {
        if(this.weight()<that.weight()){
            return -1;
        }else if(this.weight()>that.weight()){
            return 1;
        }else {
            return 0;
        }

    }
    public String toString(){
        return String.format("%d-%d %.2f",v,w,weight);
    }
}

```

#### 加权无向图的数据结构

只需要将无向图Graph中的顶点Integer类型改为Edge类型。

```java
package 最小生成树;

import bag_queue_stack.Bag;

import java.util.Scanner;

public class EdgeWeightedGraph {
    private final int V;//顶点总数
    private int E;//边的总数
    private Bag<Edge>[] adj;//邻接表

    public EdgeWeightedGraph(int V){
        this.V = V;
        this.E = 0;
        adj = new Bag[V];
        for(int v=0;v<V;v++){
            adj[v] = new Bag<Edge>();
        }


    }
    public EdgeWeightedGraph(Scanner in){
        this(in.nextInt());//这是调用public EdgeWeighted(int V)
        int E = in.nextInt();
        for(int i=0;i<E;i++){
            int o = in.nextInt();
            int p = in.nextInt();
            double d = in.nextDouble();
            Edge e = new Edge(o,p,d);
            addEdge(e);
        }
    }
    public int V(){
        return V;
    }
    public int E(){
        return E;
    }
    public void addEdge(Edge e){
        int v = e.either();
        int w = e.other(v);
        adj[v].add(e);
        adj[w].add(e);
        E++;
    }
    public Iterable<Edge> adj(int v){
        return adj[v];
    }

}

```

最小生成数API：

```java
public class MST{
    MST(EdgeWeightedGraph G);
    Iterable<Edge> edges();//最小生成树的所有边
    double weight();//最小生成树的权重
}
```

#### Prim算法

该算法一开始只有一个顶点，然后每次总是将下一条连接树中的顶点与不在树中的顶点且权重最小的边加入树中。

数据结构：

- 顶点：marked[]数组
- 边：由顶点索引的Edge对象的数组edgeTo[],  edgeTo[v]为将v连接到树中的edge对象。
- 横切边：使用一条优先队列MinPQ<Edge>来根据权重比较所有的边

算法过程：

使用一个私有方法visit()来为树添加一个顶点，将它标记为已访问，并将与它关联的所有未失效的边加入优先队列，以保证队列含有所有连接树顶点和非树顶点的边。代码的内循环是算法的具体实现：从优先队列中取出一条边并将它添加到树中，并把这条边的另一个顶点也添加到树中，然后用新的顶点作为参数调用visit方法来更新横切边的集合。weight()方法可以遍历树的所有边并得到它们的权重和（延迟实现），或者用一个运行时的中间变量统计总权重（即时实现）

prim算法延迟实现空间与E成正比：因为优先队列中最多有E条边。所需时间与ElogE成正比：因为优先队列的插入一次需要logE,删除最小的需要2logE,最多插入E次。

最小生成树的Prim算法的延迟实现

```java
package 最小生成树;

import bag_queue_stack.Queue;
import 排序.MinPQ;

public class LazyPrimMST {
    private boolean[] marked;//最小生成树的顶点
    private Queue<Edge> mst;//最小生成树的边
    private MinPQ<Edge> pq;//横切边（包括失效的边）

    public LazyPrimMST(EdgeWeightedGraph G){
        pq = new MinPQ<Edge>(G.E());
        marked = new boolean[G.V()];
        mst = new Queue<Edge>();
        visit(G,0);//假设G是连通的
        while (!pq.isEmpty()){
            Edge e = pq.delMin();//从pq中得到权重最小的边
            int v = e.either(),w = e.other(v);
            //如果这条边的两个顶点都在树中了，则为失效边，跳过失效的边
            if(marked[v]&&marked[w]){
                continue;
            }
            mst.enqueue(e);//将边添加到树中
            if(!marked[v]){//将顶点添加到树中
                visit(G,v);
            }
            if(!marked[w]){
                visit(G,w);
            }
        }


    }

    private void visit(EdgeWeightedGraph G,int v){
        //标记顶点v并将所有链接v和未被标记的顶点的边加入pq
        marked[v] = true;
        for(Edge e:G.adj(v)){
            if(!marked[e.other(v)]){
                pq.insert(e);
            }
        }
    }
    public Iterable<Edge> edges(){
        return mst;
    }
    public double weight(){
        double w = 0.0;
        for(Edge e:mst){
            w+=e.weight();
        }
        return w;
    }
}

```



Prim算法的即时实现：

我们只会在优先队列中保存每个非树顶点w的一条边，将它和树中的顶点连接起来权重最小的那条边。

它将懒实现中的marked[] 和mst[]换成了两个顶点索引的数组，edgeTo[]和distTo[]。



最小生成树的Prim算法（即时版本）

```java
package 最小生成树;

import bag_queue_stack.Queue;
import 排序.IndexMinPQ;
//最小生成树Prim算法即时版本
import java.util.Scanner;

public class PrimMST {
    private static final double FLOATING_POINT_EPSILON = 1E-12;

    private Edge[] edgeTo;        // 距离树最近的边
    private double[] distTo;      // edgeTo对应的权重
    private boolean[] marked;     // marked[v] = true if v on tree, false otherwise
    private IndexMinPQ<Double> pq;

    public PrimMST(EdgeWeightedGraph G) {
        edgeTo = new Edge[G.V()];
        distTo = new double[G.V()];
        marked = new boolean[G.V()];

        for (int v = 0; v < G.V(); v++)
            distTo[v] = Double.POSITIVE_INFINITY;

        pq = new IndexMinPQ<Double>(G.V());
        distTo[0] = 0.0;
        pq.insert(0,0.0);
        while (!pq.isEmpty()){
            visit(G,pq.delMin());//将最近的顶点添加到树中
        }

    }

    private void visit(EdgeWeightedGraph G,int v){
        //将顶点v添加到树中，更新数据
        marked[v] = true;
        for(Edge e:G.adj(v)){
            int w = e.other(v);
            if(marked[w]){
                continue;
            }
            if(e.weight()<distTo[w]){
                //链接w和树的最佳边变为e
                edgeTo[w] = e;
                distTo[w] = e.weight();
                if(pq.contains(w)){
                    pq.change(w,distTo[w]);
                }else {
                    pq.insert(w,distTo[w]);
                }
            }
        }
    }

    public Iterable<Edge> edges() {
        Queue<Edge> mst = new Queue<Edge>();
        for (int v = 0; v < edgeTo.length; v++) {
            Edge e = edgeTo[v];
            if (e != null) {
                mst.enqueue(e);
            }
        }
        return mst;
    }

    public double weight() {
        double weight = 0.0;
        for (Edge e : edges())
            weight += e.weight();
        return weight;
    }


    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        EdgeWeightedGraph G = new EdgeWeightedGraph(scanner);
        PrimMST mst = new PrimMST(G);
        for (Edge e : mst.edges()) {
            System.out.println(e);
        }
        System.out.printf("%.5f\n", mst.weight());
    }


}

```



即时算法的时间与ElogV成正比：算法会进行V次插入操作，V次删除最小元素的操作，和E次改变优先级的操作。

所需的空间和V成正比：优先队列中边数最多为V,且使用了三个由顶点索引的数组。

#### Kruskal算法

按照边的权重顺序，将边加入最小生成树中，加入的边不会与已经加入的边构成环，直到树中含有V-1条边为止。

KrusKal算法空间与E成正比，时间与ElogE成正比。

KrusKal算法一般比Prim算法要慢，因为在处理每条边时除了两种算法都要完成的优先队列操作之外，还需要进行一次connect操作。

最小生成树的Kruskal算法

```java
package 最小生成树;

import bag_queue_stack.Queue;
import unionfind.UF;
import 排序.MinPQ;

import java.util.Scanner;

public class KruskalMST {
    private static final double FLOATING_POINT_EPSILON = 1E-12;

    private double weight;                        // weight of MST
    private Queue<Edge> mst = new Queue<Edge>();  // edges in MST

    /**
     * Compute a minimum spanning tree (or forest) of an edge-weighted graph.
     * @param G the edge-weighted graph
     */
    public KruskalMST(EdgeWeightedGraph G) {
        // more efficient to build heap by passing array of edges
        MinPQ<Edge> pq = new MinPQ<Edge>(G.E());
        for (Edge e : G.edges()) {
            pq.insert(e);
        }

        // run greedy algorithm
        UF uf = new UF(G.V());
        while (!pq.isEmpty() && mst.size() < G.V() - 1) {
            Edge e = pq.delMin();//获取权重最小的边
            int v = e.either();
            int w = e.other(v);
            if (uf.find(v) != uf.find(w)) { // v-w does not create a cycle
                uf.union(v, w);  // merge v and w components
                mst.enqueue(e);  // add edge e to mst
                weight += e.weight();
            }
        }

        // check optimality conditions
        assert check(G);
    }

    /**
     * Returns the edges in a minimum spanning tree (or forest).
     * @return the edges in a minimum spanning tree (or forest) as
     *    an iterable of edges
     */
    public Iterable<Edge> edges() {
        return mst;
    }

    /**
     * Returns the sum of the edge weights in a minimum spanning tree (or forest).
     * @return the sum of the edge weights in a minimum spanning tree (or forest)
     */
    public double weight() {
        return weight;
    }

    // check optimality conditions (takes time proportional to E V lg* V)
    private boolean check(EdgeWeightedGraph G) {

        // check total weight
        double total = 0.0;
        for (Edge e : edges()) {
            total += e.weight();
        }
        if (Math.abs(total - weight()) > FLOATING_POINT_EPSILON) {
            System.err.printf("Weight of edges does not equal weight(): %f vs. %f\n", total, weight());
            return false;
        }

        // check that it is acyclic
        UF uf = new UF(G.V());
        for (Edge e : edges()) {
            int v = e.either(), w = e.other(v);
            if (uf.find(v) == uf.find(w)) {
                System.err.println("Not a forest");
                return false;
            }
            uf.union(v, w);
        }

        // check that it is a spanning forest
        for (Edge e : G.edges()) {
            int v = e.either(), w = e.other(v);
            if (uf.find(v) != uf.find(w)) {
                System.err.println("Not a spanning forest");
                return false;
            }
        }

        // check that it is a minimal spanning forest (cut optimality conditions)
        for (Edge e : edges()) {

            // all edges in MST except e
            uf = new UF(G.V());
            for (Edge f : mst) {
                int x = f.either(), y = f.other(x);
                if (f != e) uf.union(x, y);
            }

            // check that e is min weight edge in crossing cut
            for (Edge f : G.edges()) {
                int x = f.either(), y = f.other(x);
                if (uf.find(x) != uf.find(y)) {
                    if (f.weight() < e.weight()) {
                        System.err.println("Edge " + f + " violates cut optimality conditions");
                        return false;
                    }
                }
            }

        }

        return true;
    }


    /**
     * Unit tests the {@code KruskalMST} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
//        int in = scanner.nextInt();
        EdgeWeightedGraph G = new EdgeWeightedGraph(scanner);
        KruskalMST mst = new KruskalMST(G);
        for (Edge e : mst.edges()) {
            System.out.println(e);
        }
        System.out.printf("%.5f\n", mst.weight());
    }

}

```

![](/home/lixing/文档/image/选区_292.png)



### 最短路径

找到从一个顶点到另一个顶点成本最小的路径。采用的模型是加权有向图。











