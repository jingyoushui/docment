### 3.4 HotSpot的算法实现细节

- 所有收集器在根节点枚举这一步骤时都必须暂停用户线程。整个枚举期间执行子系统看起来就像是冻结在某个时间点。

- 虚拟机有办法直接得到哪些地方存放着对象引用，在hotspot中是使用一组称为OopMap的数据结构来达到这个目的。在类加载动作完成后和在即时编译过程中会记录哪些位置是引用

- 在程序执行时必须强制只有到达安全点后才能够暂停，安全点的选取是以“是否具有让程序长时间执行的特征”为标准进行选定的，只有在这些指令中才会产生安全点。

- 如何在垃圾收集时让所有线程跑到最近的安全点：

  - 抢先式中断：在垃圾收集发生时，系统首先让所有线程中断，然后让不在安全点上的线程再运行一下直到跑到安全点上。（现在几乎不使用这种方法）
  - 主动式中断：当垃圾收集需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志位，各个线程执行过程时会不停地主动轮询这个标志，一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。

  HotSpot使用内存保护陷阱的方式，把轮询操作精简为只有一条汇编指令，当需要暂停用户线程时，虚拟机把0x160100的内存页设置为不可读，线程就会产生一个自陷异常信号，然后在预先注册的异常处理器中挂起线程实现等待。

- 上面的安全点有一个问题，就是如果线程处于sleep或者blocked状态呢，没有在执行，在垃圾回收时也就没有办法跑到安全点上将自己挂起，所以要引入安全区域来解决。

- 安全区域：在某一段代码片段中，引用关系不会发生变化，在这个区域的任何地方开始垃圾收集都是安全的，当线程进入安全区域时，会标识自己进入了安全区域，当要离开时，先检查一下虚拟机是否完成了根节点枚举，完成了就继续执行，没完成就必须等待。

- 记忆集：是一种用于记录从非收集器区域指向收集区域的指针集合的抽象数据结构，收集器通过记忆集判断某一块非收集区域是否存在有指向了收集区域的指针。卡表是记忆集的一种实现，它定义了记忆集的记忆精度，与堆内存的映射关系等。

- 卡表最简单的形式是字节数组，字节数组的每一个元素对应着一个内存块（卡页），一个卡页的内存通常不止包含一个对象，只要卡页内有一个对象的字段存在跨代指针，就把该数组元素标识为1，否则为0.在垃圾收集时只要筛选为1的元素对应的卡页就好了。

- 写屏障：用来维护卡表状态，在引用对象赋值时会产生一个环形通知，供程序执行额外的动作，也就是说赋值的前后都是在写屏障的覆盖范围内。

- 并发的可达性分析：

  三色标记：

  - 白色：未被垃圾收集器访问过
  - 黑色：被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。
  - 灰色，被访问过，但存在引用还没有扫描

  对象消失问题：

  - 赋值器插入了一条或多条从黑色对象到白色对象的新引用：增量更新方法
  - 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用：原始快照方法



### 3.5 经典的垃圾收集器

新生代

- Serial收集器：单线程收集器，在运行垃圾回收时，必须暂停其他所有工作的线程。新生代采取复制算法暂停所有用户线程
- ParNew收集器：Serial收集器的多线程并行版本。
- Parallel Scavenge收集器：基于标记复制算法实现，能够并行收集的多线程收集器，该收集器的关注点是吞吐量（处理器用于运行用户代码的时间与处理器总耗时的比值），主要适合于在后台运算而不需要太多交互的分析任务。

老年代

- serial Old收集器：单线程收集器，老年代采取标记-整理算法暂停所有用户线程。与Parallel Scavenge搭配使用，或者作为CMS的后备方案

- Parallel Old收集器：Parallel Scavenge的老年代版本，支持多线程并发收集，基于标记-整理算法实现

- CMS（Concurrent Mark Sweep）收集器：以获取最短回收停顿时间为目标的收集器，基于标记-清除算法实现，主要用于网站等关注服务的响应速度的系统中。运行过程包括四个步骤：

  - 初始标记：标记一下GC root能直接关联的对象，单线程运行，需要 stop the world
  - 并发标记：从GC root 的直接关联对象开始遍历整个对象图的过程，耗时较长，可以与用户线程并发运行
  - 重新标记：修正并发标记期间，因用户线程继续运行而导致的标记产生变动的那一部分的标记记录，多线程并行，需要stop the world
  - 并发清除：清理删除掉标记阶段判断的已经死亡的对象，耗时较长，这个阶段可以和用户线程并发进行。

  CMS优点：并发收集，低停顿

  CMS缺点：

  - 对处理器资源非常敏感
  - 无法处理浮动垃圾，所谓浮动垃圾指出现在标记过程结束之后的垃圾，无法在本次收集中处理他们。

  - 由于是基于标记-清除算法实现的，所有在收集结束之后会产生大量的空间碎片。

- G1收集器：是一款面向服务端的垃圾收集器，开创了收集器面向局部收集的设计思路和基于Region的内存布局形式，它可以面向堆内存任何部分来组成回收集，衡量标准不再是老年代和新生代，而是哪块内存中存放的垃圾数量最多，回收收益最大。G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的java堆划分为多个大小相等的独立区域（Region），每次收集到的内存空间都是Region大小的整数倍，这样可以有计划的避免在整个java堆中进行全区域的垃圾收集。在后台维护一个优先列表，优先处理回收价值最大的Region.

- G1收集器步骤：

  - 初始标记：标记一下GC Root能够直接关联到的对象，并且修改TAMS指针的值，G1为每个Region设计了两个名为TAMS的指针，用来将region划分出一个区域用于并发回收过程中新对象的分配。该阶段需要暂停用户线程
  - 并发标记阶段：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图。
  - 最终标记：用于处理并发阶段结束后产生的SATB记录，该阶段暂停用户线程
  - 筛选回收：对各个Region的回收价值和成本进行排序，选择一些构成回收集，将他们中存活的对象复制到空的Region中，再清理掉整个旧Region空间。该阶段需要暂停用户线程。



### 3.6低延迟垃圾收集器

垃圾收集器的三个指标：内存占用，吞吐量，延迟

Shenandoah:可以认为是G1的继承者，也是基于Region的堆内存布局，回收策略同样是优先处理回收价值最大的Region，但是在内存管理方面，支持并发的整理算法。不再使用G1的记忆集，而是使用链接矩阵。工作过程可以分为九个步骤：

- 初始标记：标记与GC root直接关联的对象，暂停用户线程
- 并发标记：遍历对象图，标记出可达对象，与用户线程并发进行
- 最终标记：处理剩余的SATB扫描，统计出回收价值最高的Region，暂停用户线程
- 并发清理：清理整个区域一个存活对象都没有的Region
- 并发回收：将回收集中存活的对象复制到其他Region,这个过程是与用户线程并发的，使用读屏障和被称为Brooks Pointers的转发指针来解决
- 初始引用更新：把所有指向旧地址引用指向新地址，这是一个初始阶段，未做更新，只是集合线程。暂停用户线程
- 并发引用更新：真正的引用更新操作，与用户线程一起并发。
- 最终引用更新：解决了堆中的引用更新之后，还需要修正存在于GC Root中的引用
- 并发清理：回收Region的内存空间。

ZGC垃圾收集器：ZGC收集器是一款基于Region内存布局的，不设分代的，使用了读屏障、染色指针和内存多重映射技术来实现可并发的标记-整理算法的，以低延迟为首要目标的一款垃圾收集器。

ZGC的核心问题就是并发整理算法的实现，标志性的设计是采用了染色指针技术，在Serial收集器上把标记直接记录在对象头上，G1和shenandoah使用BitMap与对象独立的数据结构，ZGC使用染色指针是最直接的最纯粹的直接把标记信息记载引用对象的指针上。

染色指针是一种直接将少量额外的信息存储在指针上的技术，拿64位的硬件来说，最多也只能有46位的寻址空间，就是64TB,染色指针取这46位的前4位存储四个标志信息，也就还有42位4TB的内存空间。

染色指针的优点：

- 一旦某个Region的存活对象被移走后，这个Region立即就能够被释放和重用掉，不需要等待整个堆中所有指向该Region的引用被修正
- 大幅度减少在垃圾收集过程中的内存屏障的使用数量。
- 染色指针可以作为一种可扩展的存储结构用来记录更多与对象标记、重定位过程相关的数据。

ZGC工作过程：

- 并发标记：并发标记是遍历对象图做可达性分析的阶段，ZGC的标记是在指针上而不是在对象上进行的，标记阶段会更新染色指针中的Marked0,Marked1标志位
- 并发预备重分配：根据特定的查询条件统计得出本次收集过程要清理哪些Region，将这些Region组成重分配集。
- 并发重分配：把重分配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个转发表，记录从旧对象到新对象的转向关系。如果用户线程访问了位于重分配集中的对象，这次访问将会被预置的内存屏障所截获，然后立即根据Region上的转发记录将访问转发到新复制的对象上，并同时修正更新该引用的值，使其直接指向新对象，该过程为指针的自愈。
- 并发重映射：重映射所做的就是修正整个堆中指向重分配集中旧对象的所有引用。ZGC将并发重映射阶段要做的工作合并到了下一次垃圾收集循环中的并发标记阶段里去完成。



## 6. 类文件结构

- 任何一个class文件都对应着唯一的一个类或接口的定义信息
- class文件是一组以8个字节为基础单位的二进制流，只有两种数据类型：无符号数和表



## 7.虚拟机类加载机制

类加载机制：Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的java类型。

### 类加载的时机

类加载的生命周期：

- 加载，验证，准备，解析，初始化，使用，卸载
- 验证，准备，解析这三个部分称为连接

对类进行初始化的六种情况：

- 遇到new,getstatic,putstatic,invokestatic指令时，对应与java的
  - new一个对象
  - 读取或设置一个类型的静态字段
  - 调用一个静态方法
- 使用java.lang.reflect包的方法对类型进行反射调用的时候
- 当初始化类的时候，发现其父类还没有进行初始化，则需要先初始化父类
- 虚拟机启动时，用户指定一个主类，先初始化主类
- java.lang.invoke.MethodHandle解析为XXXStatic时
- default修饰的接口方法，如果其实现类发生了初始化，这个接口要先初始化

被动引用不会导致类初始化

- 通过子类引用父类的静态方法，不会导致子类初始化
- 通过数组定义来引用类，不会触发此类的初始化
- 常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类初始化。

### 类加载的过程

加载阶段：

- 通过一个类的全限定类名来获取定义此类的二进制字节流
- 将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构
- 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口



