# 分布式架构-缓存

指标： 最小内存---最大功用

1、命中率
2、绝对过期：从数据加入开始算时间
3、滑动过期:例如session，每被访问一次，时间延长一些

![20200305_19582e](image/#%20%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/20200305_19582e.png)

![20200305_67d76e](image/#%20%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/20200305_67d76e.png)



![20200306_319806](image/#%20%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/20200306_319806.png)

Cacheable:

![image-20200306113541651](image/#%20%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/image-20200306113541651.png)



![20200306_a441fd](image/#%20%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/20200306_a441fd.png)

![20200306_6828cd](image/#%20%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/20200306_6828cd.png)

![image-20200306132202173](image/#%20%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/image-20200306132202173.png)

![20200306_456073](image/#%20%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/20200306_456073.png)



![20200306_a3f900](image/#%20%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/20200306_a3f900.png)

![20200306_32e02e](image/#%20%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/20200306_32e02e.png)

![20200306_b8a858](image/#%20%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/20200306_b8a858.png)



加锁时，每一个查询的id就需要一把锁，相同的id是同一把锁，不同的id是不同的锁，将锁放到concurenthashmap中



![20200306_a8f5b2](image/#%20%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/20200306_a8f5b2.png)

![20200306_be23fc](image/#%20%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/20200306_be23fc.png)

上堂课回顾：

1、高并发第一选择---- 加缓存

2、springcache配置 ---- 缓存管理器 

----- springboot2.0版本使用cache对redis版本是有要求

3、springcache里面 ---- 三个标签使用：cacheable/cacheput/cacheEvict

4、congfig配置，自定义key

 

缓存一致性问题解决办法：

1、同步调用方式----- 实时修改

2、准实时修改----- mq/发布订阅/观察者模式

3、非实时------ 缓存过期/绝对过期

4、报表一类------ 定时刷新

 

缓存需要预防的问题/解决方案：

1、缓存雪崩 ------  加锁（参数key）/限流  面试喜欢问

2、缓存穿透--------- 布隆过滤器 （用法原理类比SET）

# 分布式事务与锁

单机里面，完美解决了锁与事务

一、使用锁的原因分析：

1、使用锁的目的

------------多个外部线程同时来竞争使用同一资源时，会彼此影响，导致混乱

------------锁的目的，将资源的使用做排它性处理，使同一时间，仅一个线程能访问资源

2、并不是所有的资源，都无法同时服务多个线程 ------ 比如，无状态的资源

3、无成员变量/成员变量不存在变化的类---- 就是无状态类 ----- 这种类是线程安全的

4、有状态的对象，也不一定是不安全的

---------- 如果状态变化是原子的（即没有中间变迁过程，变化不需要时间，没有中间态） ---- 那么它一样是线程安全的

5、重要的概念，动作的原子性

6、总结：锁的本质

锁要解决的问题是 ------- 资源数据会不一致

锁要达成的目标是 ------- 让资源使用起来，像原子性一样

锁达成目标的手段 ------- 让使用者访问资源时，只能排队，一个一个地去访问资源

 

二、在单机应用里，JVM可以通过以下工具，可协调资源像原子性一样操作

1、sychronized ------ java语言天生支持

2、lock ---- jdk有接口标准

 

三、分布式环境下，如何协调资源达到原子性的操作？

1、sychronized / lock 这些java天然的实现，无法跨JVM发挥作用

2、只得去寻求分布式环境里，大家都公认的服务来做见证人，以协调资源

3、常见的公证人 ------》 mysql/zk/file/redis 

![20200306_7de41b](image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/20200306_7de41b.png)

4、目标 ----- 通过公证人发出信号，来协调分布式的访问者，排队访问资源

5、条件 ----- 任何一个能够提供【是/否】信号量的事物，都可以来做公证人

6、陷阱 ----- 发出锁信号量的动作，本身必须是原子性的

 

7、mysql来充当公证人（为了说明问题，工作中不要用），利用的是一条sql语句执行的成功/失败，是原子的，id是主键，利用行级锁，流程如下：

![img](image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/wpsPHP7GR.jpg) 

8、redis来充当公证人，利用的其 setnx指令的成功/失败，是原子的，流程如下：

![20200306_0ec740](image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/20200306_0ec740.png)

![20200306_3b06a5](image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/20200306_3b06a5.png)





![img](image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/wpsHoN6cw.jpg) 

9、为了防止线程宕机，造成锁死在那里挡道，需要给锁认定一个有效期限，

------此期限的自动失效解锁，与线程的主动解锁之间，会存在冲突，reids的解锁流程必须考虑这一点：

![img](image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/wpsd6W7Ia.jpg) 

10、上图的解锁逻辑虽然是正确的，但因为整个动作不是原子的，因为不安全。需要改为lua脚本来执行

![img](image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/wpsPkcbfP.jpg) 

11、lua 脚本为什么是原子性的

----- redis是单线程执行指令的，因此内部不存在线程竞争

![img](image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/wpszzlgLt.jpg) 

（1）服务器A依次发送了ab指令到redis

（2）服务器B依次发送了cd指令到redis

（3）两台机器同向redis发送的四条指令，最终在指令队列里顺序是：acbd

（4）可以看到，服务器A发送的ab两条指令，中间穿插了c指令，破坏了其完整性，因此，ab两条指令不是原子的

（5）lua脚本，被放进队列时，ab指令是放在一起的，因为ab会顺序一起被执行，成为了原子性动作

 

四、事务的概念

1、锁的问题  ----- 多对一的问题 ------ 是多个线程同时访问同一个资源，造成资源状态不一致

2、事务的问题 ----- 一对多的问题 ----- 是一个线程进数据库，操作多条sql，其中，某条sql的失败，致使整个业务失去意义;

3、数据库中事务的实现方式：

------------------ service执行一个操作，要执行N条sql（ 一条sql 是一个原子性操作）

--------- 数据库内部，如何实现事务？

--------- 所有的sql执行完毕之前，结果都以副本形式存在，如下图

![img](image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/wpsphUoh8.jpg) 

------- commit操作 ------ 业务线程向数据库发指令 ----- 把副本转正

------ roback操作 ------- 把副本丢掉

4、jdbc规范里，定义这样标准---- 事务管理器

![img](image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/wps7eqzNM.jpg) 

![img](image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/wpsJ3BLjr.jpg) 

事务管理器定义三个标准接口，即：

1、启动事务（启动副本），

2、副本转正

3、副本丢弃

 

五、分布式事务

1、分布式事务，是指多台数据库的执行sql，也想要达到一致性的标准，即：多台一起commit或rollback

2、参照单机事务的模型，分布式事务的思路延袭，也想通过三个标准接口的模式来完成（启副本/commit/rollback）

3、按这个思路， X/Open组织提出了分布式事务的规范 ----- XA

4、XA的核心，便是全局事务，通过XA二阶段提交协议，与各分布式数据交互，分准备与提交两个阶段，如下图：



![20200306_fc2680](image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/20200306_fc2680.png)

![20200306_25fff9](image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/20200306_25fff9.png)







课程回顾：

1、锁的本质，资源的操作不是原子 -------- 锁目标，让一系列操作，一次性做完。排队

2、分布式环境下，一切能够发出两个信号量事物都能够做锁 ----- 做锁要求：加锁/解锁两个动作，一定是原子的

3、mysql来做锁 ------- 一条sql的执行，是原子的

4、redis有做锁 -------- setnx操作，是原子的

5、redis要做安全的锁，----- 加锁进程死掉，--------  有效期使用解锁过程复杂化--锁判断----lua脚本来保证原子性

6、锁 ---- 多个线程操作一个资源 ; 事务 ----- 一个线程，操作多个资源问题。

7、事务 ----- ACID ----- 启事务/commit/rollback

8、X/open组织提出分布式事务规范 ---- XA

 

 

本堂课内容：

1、事务执行的中间态说明： 

----- sql执行后，尚未提交 ，此时对应的数据状态：

​		-----正本数据（原来的数据）  ----- 锁定状态-------允许其它线程读不允许改（此时易出现幻读）

​		-----副本数据（sql执行结果）  ------ 隔离状态 ------其它线程是无法接触到的-------（可设置事务隔离级别，使其可读）未生效的数据 ---- 脏读 

​		----- commit/rollback时出错   ------- 不能执行机率非常低

2pc:两阶段提交 

2、预置一个事务问题场景：去哪网上订购机票 

国航：北京 ---- 香港 

南航：香港 ----- 泰国

 

只有同时能在国航/南航买到机票，才算有意义，否则做退票处理！

 

一、XA规范下的2pc事务

2pc步骤：

1、引入包

![img](image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/wpsp1ffQB.jpg) 

2配置xadatasource --- 2pc方式需要支持XA协议的数据源

![img](image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/wpsZcpQxS.jpg) 

3、代码示例 ------- 默认只有runtime（包括其子类）异常回滚 --------普通异常Exception是不回滚的

![img](image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/wpsklrtf9.jpg) 

只要doOrder方法里抛出了RuntimeException，则两个数据库里的sql结果，都会被回滚掉

 加了@Transactional注解之后，如果出现异常就会回滚，没有异常就会自动提交。

二、 2pc在现实使用中的问题/限制：

1、必须要使用支持XA协议的datasource数据源

2、因为要同时锁定两个数据库的数据，事务锁定时间大大延长 ------ 现实中数据库性能欠佳

 ![20200311_8dbc4e](image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/20200311_8dbc4e.png)

三、base理论/柔性事务 ----- 为了可用性，牺牲一致性

![img](image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/wpsG6H8Wp.jpg) 

1、base理论的本质，是不再遵守ACID标准（分正副本，数据加锁，强一致性），不做强一致性

2、base理论的S，即指事务执行的中间状态（commit之前的状态），可以不隔离锁定，允许对外界表现出不一致

-----------一个事务执行需要时间 ------- a步骤---》b步骤 -------- 20毫秒 ---- 中间状态

3、base理论的E，即指保证最终所有的步骤都得到执行，达到最终数据是一致的

4、整个base理论的过程，如下：

事务开始前 ----- 数据是一致的

事务进行中 ------ 数据是不一致的 ---- 中间态不一致 ---- 放宽标准

事务结束后 ------ 数据又一致

5、对比ACID事务，base事务就是砍掉其中的数据锁定状态

----------------为了可用性 --- 数据锁定的状态--- 不可用状态

6、业界对事务分类标准：

ACID标准，强一致性要求的事务标准 ----- 刚性事务

牺牲一致，放弃ACID里的强一致要求-------柔性事务： 

 

四、tcc两阶段、补偿性事务

![img](image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/wpsocHQEG.jpg) 

1、业务接口改造：

一个普通业务接口-----切成三个接口：try--confirm--cancel

try   ------- 原业务接口------- 接口执行完毕，数据库数据就提交 ----如： insert一条数据1

confirm ------ 确认数据 --------- 将try阶段的数据查询出来确认，如： select 1确认数据是否已ok

cancel -------- 抵消数据 --------- 将try阶段的数据做逆向取消，如： delete from删除数据/ insert  -1再加一条数据抵消  ------- 逆向业务方法，又称之谓补偿动作

2、try -confirm-cancel的三个步骤联动过程

如果try不出异常正常结束，则框架自动去调用confirm方法

如果try出了异常，框架去调用cancel补偿方法

3、tcc方案，对原业务的侵入性太强。为了更好控制，通常做变种使用

try   ------- 将原业务接口，涉及到的资源锁定/或者做预备 ------ 通过一个冻结状态，做排它处理

confirm ------ 正式调用原业务接口方法，如：insert一条数据1 ----- 因try阶段已经为此语句准备好了执行条件，不会再出现业务的冲突情况（业务一定是可行的）

cancel -------- 恢复资源状态，取消资源的冻结状态

<img src="image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/wpsuMFBmX.jpg" alt="img" style="zoom:150%;" /> 

4、tcc-transation框架方案实战

（1）、引入pom

![img](image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/wpsO8go4d.jpg) 

（2）、配置tcc数据源

![img](image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/wpssOzcMu.jpg) 

（3）、tcc事务的日志表，TCC_TRANSACTION_ENJOY这张，是由_ENJOY

![img](image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/wpsC8R2tL.jpg) ![img](image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/wpsy5BUb2.jpg)

（4）代码逻辑如下：其中confirm指定确认方法，cancelMethod指定补偿方法

<img src="image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/wpsKaUOTi.jpg" alt="img" style="zoom:150%;" /> 

（5）tcc框架对业务方法的要求：

try-confirm-cancel三个方法，都必须要满足幂等性/可查询性

<img src="image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/wpsuD3KBz.jpg" alt="img" style="zoom:200%;" /> 

（6）tcc事务，与其它事务框架的对比

异步确保型事务 

-------- 典型的使用MQ中间件来传递事务调用。

-------- 其重点是确保事务消息一定会传达到目标系统，目标系统只许成功不许失败（不成功我也不管）

-------- 因为是异步的，因此事务发起后，就不再关注了。名曰事务，已不像事务范畴

 ![20200311_03da20](image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/20200311_03da20.png)

最大努力通知型

-------- 通过多线程异步重试，来传递事务调用

-------- 即通过重试机制，努力将事务调用传递到目标系统，目标系统只许成功不许失败（不成功我也不管）

-------- 因为是异步的，其执行已经脱离事务范畴

 





# 单点登录

一、oauth2与单点登陆的区别

1、oauth2，不同的企业之间的登陆，应用之间的信任度较低

2、单点登陆，是同一企业的产品系列间的登陆，相互信任度较高

二、session-cookie机制

1、session-cookie机制出现的根源， http连接是无状态的连接，每次请求之间没有联系

-------- 同一浏览器向服务端发送多次请求，服务器无法识别，哪些请求是同一个浏览器发出的

<img src="image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/wpszdNfRo.jpg" alt="img" style="zoom:100%;" /> 

2、为了标识哪些请求是属于同一个人 ---------- 需要在请求里加一个标识参数

方法1-----------直接在url里加一个标识参数(对前端开发有侵入性)，如: token

方法2-----------http请求时，自动携带浏览器的cookie（对前端开发无知觉），如：jsessionid=dfdfdfdfdf 

3、浏览器标识在网络上的传输，是明文的，不安全的

-----------安全措施：改https来保障

4、cookie的使用限制---依赖域名

-------------- 顶级域名下cookie，会被二级以下的域名请求，自动携带

-------------- 二级域名的cookie，不能携带被其它域名下的请求携带

5、在服务器后台，通过解读标识信息（token或jsessionid），来对应会话是哪个session

--------------- 一个tomcat，被1000个用户登陆，tomcat里一定有1000个session -------》存储格式map《sessionid，session对象》

--------------- 通过前端传递的jsessionid，来对应取的session ------ 动作发生时机request.getsession

![20200311_02c2d7](image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/20200311_02c2d7.png)





三、session共享方式，实现的单点登陆

![20200311_b30b9c](image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/20200311_b30b9c.png)

1、多个应用共用同一个顶级域名，sessionid被种在顶级域名的cookie里

2、后台session通过redis实现共享，即每个tomcat都在请求开始时，到redis查询session;在请求返回时，将自身session对象存入redis

3、当请求到达服务器时，服务器直接解读cookie中的sessionid，然后通过sessionid到redis中查找到对应会话session对象

![20200311_0f96cb](image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/20200311_0f96cb.png)



![20200311_e6ce17](image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/20200311_e6ce17.png)

4、后台判断请求是否已登陆，主要校验session对象中，是否存在登陆用户信息

5、整个校验过程，通过filter过滤器来拦截切入，如下图：

<img src="image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/wpsvsUZ9y.jpg" alt="img" style="zoom:100%;" /> 

6、登陆成功时，后台需要给页面种cookie方法如下：

![img](image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/wps7zILsJ.jpg) 

response里，反映的种cookie效果如下：

![img](image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/wps6aizLT.jpg) 

7、为了request.getsession时，自动能拿到redis中共享的session，

  我们需要重写request的getsession方法（使用HttpServletRequestWrapper包装原request）

四、cas单点登陆方案

![20200311_7de774](image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/20200311_7de774.png)

![20200311_3b9753](image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/20200311_3b9753.png)

![20200311_1040d6](image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/20200311_1040d6.png)

1、对于完全不同域名的系统，cookie是无法跨域名共享的

2、cas方案，直接启用一个专业的用来登陆的域名（比如：cas.com）来供所有的系统登陆。

3、当业务系统（如b.com）被打开时，借助cast系统来登陆，过程如下：

cas登陆的全过程：

（1）、b.com打开时，发现自己未登陆 ----》 于是跳转到cas.com去登陆

（2）、cas.com登陆页面被打开，用户输入帐户/密码登陆成功 

（3）、cas.com登陆成功，种cookie到cas.com域名下 -----------》把sessionid放入后台redis《ticket，sesssionid》---页面跳回b.com。ticket就是一个UUID,作为key

（4）、b.com重新被打开，发现仍然是未登陆，但是有了一个ticket值

（5）、b.com用ticket值，到redis里查到sessionid，并做session同步（去redis取session放到tomact） ------ 》种cookie给自己，页面原地重跳

（6）、b.com打开自己页面，此时有了cookie，后台校验登陆状态，成功

（7）整个过程交互，列图如下：

<img src="image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/wpsWtfq43.jpg" alt="img" style="zoom:200%;" /> 

4、cas.com的登陆页面被打开时,如果此时cas.com本来就是登陆状态的,则自动返回生成ticket给业务系统

​	整个单点登陆的关键部位，是利用cas.com的cookie保持cas.com是登陆状态,此后任何第三个系统跳入,都将自动完成登陆过程. cas保存了所有系统的cookie值。

5,本示例中,使用了redis来做cas的服务接口（存ticket和取ticket）,请根据工作情况,自行替换为合适的服务接口(主要是根据sessionid来判断用户是否已登陆)

6,为提高安全性,ticket应该使用过即作废(本例中,会用有效期机制),用ticket取sessionid，ticket是在浏览器上传递的。





# 分布式任务调度

Spring&SpringBoot任务调度工具：

@Scheduled

@Scheduled(fixedDelayString = "5000")
5秒调用一次

@Scheduled(cron = "0/5 * *  * * ?")
使用cron表达式 5秒调用一次

一、任务调度的直接实现：

-------------------------触发器 + 线程池 ==== 任务调度

-------------------------spring标签法简洁使用

![img](image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/wpsJ19IzC.jpg)

![20200311_4b7634](image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/20200311_4b7634.png)

![20200311_0e09ef](image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/20200311_0e09ef.png) 

![20200311_8963e3](image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/20200311_8963e3.png)



![20200311_bffa55](image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/20200311_bffa55.png)



![20200311_22b836](image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/20200311_22b836.png)



![20200311_219c5f](image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/20200311_219c5f.png)





1、其实现思想：

-----调度线程--- 单线程（守护线程）不停轮循---trigger触发器

---- 若触发器到达临界值，则根据触发器对应出它的job，去线程池里取一个线程来执行job

---- 则线程池全忙，则阻塞等待线程（线程池知识）

 

2、实现思想生发： java底层，轮循线程守护的使用非常普遍，如：

---------- 监听（监听网络端口/tomcat网关监听/mq队列等）------是一个线程在不停地轮循buff（队列）里是否有值

---------- 异步调用 ------------- 如future模式，其阻塞等待任务会集的过程，也是轮循线程不停查询结果值队列）

---------- 消息驱动，事件驱动 ------ 如html中onclick，onchage等，全是有轮循线程永不停歇地检测状态

---------- java中pull 转 push设计大法------- 服务方把自己的结果推给消费方时，只是把结果放入buff中，消费方依靠一个轮循线程检测消息到达

 

3、分布式环境里， 任务调度的困难及解决思想

--------------对集群机器中配置的任务，只能运行一个（排它处理）

第一方式 ---------- 锁：当集群中所有机器都触发时，只有第一个得到锁，可以运行，后面的机器发现任务已运行，则自动取消运行

​	 ------------实现套路：触发器被布置多份 -------重复触发 ----- 再用锁只放一个触发出去

​					

 

第二方式 ------------选举：

​		---------触发器被布置多份 -------	选举出一个leader有效，其它暂置为无效--zk选举

 

4、业界的流行的方案框架：

e-job ----- 直接把任务 分摊出去 ---- 每台机器负责哪些任务，分配好

xxl-job--- 调度器（任务触发）是中心化部署（管理台），而执行器与业务系统集成（集群）

 

 

 

 

5、e-job的方式：

（1）引pom依赖

![img](image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/wpsgyQfUh.jpg) 

（2）配置文件：指定zk和触发规则、分片信息等

![img](image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/wpsuWBOeX.jpg) 

（3）任务代码示例（需实现SimpleJob接口）：

![img](image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/wpsudypzC.jpg) 

（4）、任务分片解释：

-----------------某些量大的任务，能够通过分拆分摊，提高执行时效，如：给1万用户发短信？

此时，可做为分片任务来处理，即任务分拆成多片小任务。任务触发时，每片任务发送到一台机器去处理，如1万用户发短信，拆成两个任务（每个发5000条短信），分别到达两台机器去执行。

------------------分片与业务数据的对应关系，由业务自行对应，如：每一片该处理哪些数据

![img](image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/wpsp0U2Th.jpg) 

（5）、ejob分片之后，每一个分片，是一个独立的子任务 ----- 策略随机选机器 ---

 

6、xxl调度配置

（1）、调度器（控制台）的部署配置：

可以上github去下载源码：[***\*https://github.com/xuxueli/xxl-job\****](https://github.com/xuxueli/xxl-job)

也可以直接使用peter老师上传的源码包（无大区别，指定xxl-job-core为2.0.1）

a、运行建库脚本

![img](image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/wpsn0LIeX.jpg) 

b、项目中配置mysql

![img](image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/wpsyJhqzC.jpg) 

c、打包项目jar包，发布

maven打包后，得到admin.jar,上传到服务器，

启动：nohub java -jar admin.jar > log.xxx 2>&1 &

d、打开控制台，登陆后，可查看项目调度情况

![img](image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/wpspeI9Th.jpg) 

 

（2）、执行器的配置部署

a、执行器pom引入：

![img](image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/wpsl31UeX.jpg) 

 

 

 

 

 

b、配置控制台地址、执行器名称、通信端口等

![img](image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/wpspjiIzC.jpg) 

c、在控制台添加执行器，必须：AppName == 上一步中的appname配置

![img](image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/wpsQudxUh.jpg) 

 

d、添加完毕后，可发现控制台中，执行器列表中，显示出online机器地址（ip：port），代理控制台已检测到执行器启动了

![img](image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/wpsLpJnfX.jpg) 

 

e、执行器中编写调度任务

![img](image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/wpsFAMfAC.jpg) 

f、控制台中添加任务调度：JobHandle，就是上一步中的@JobHandle标签指定的名字

![img](image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/wpsMkq9Uh.jpg) 

 

g、可以点击执行，立即运行此任务，测试正确性。后续各增删改操作完全随你心意

![img](image/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98/wpswdF4fX.jpg) 

 































































