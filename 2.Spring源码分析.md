# 享学Spring

### 第一次课

 一 CAP1章节  将你的工程从XML配置到注解 

一、创建工程

1，创建Maven工程：![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wps766NfV.jpg)

2，![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpscn8QiG.jpg)

3，![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsBOcVlr.jpg)

4，pom.xml引入spring-context jar和Junit测试用例包

<dependencies>

​		<dependency>

​			<groupId>org.springframework</groupId>

​			<artifactId>spring-context</artifactId>

​			<version>5.0.6.RELEASE</version>

​		</dependency>

<dependency>

​			<groupId>junit</groupId>

​			<artifactId>junit</artifactId>

​			<version>4.12</version>

​			<scope>test</scope>

​		</dependency>

</dependencies>

 

5，如果是以前,我们应该建立spring的beanx.xml

 

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsCRj2oc.jpg) 

beans.xml内容如下,使用bean标签注册一些组件<新建Person.java>:

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsfKAasX.jpg) 

3,新建cap1包名，新建Person.java类
![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsQmXjvI.jpg)

 

4，新建MainTest1测试类：ClassPathXmlApplicationContext:类路径下的XML

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpshZruyt.jpg) 

如果我们用注解开发, 很明显是不需要XML的

 

5， 注解测试： 如何使用注解（去掉配置文件）开发

新建MainConfig类

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsoJaGBe.jpg) 

 

6， 注解测试： 新建MainTest2注解测试，用来测试//AnnoatationConfigApplicationContext: 注解配置来获取IOC容器

 

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsX3YSEZ.jpg) 

 

 

 二 CAP2章节  ComponentScan扫描规则 

 

 

2.1 操作:新建cap2文件夹,新建Cap2MainConfig.java配置类

作用:指定要扫描的包

 ![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsq8a7HK.jpg)

1,@ComponentScan(value="com.enjoy.cap2")表示扫描此目录下的包

2,建立测试用例方法;

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wps52GmLv.jpg) 

 

2.2 新建Cap2MainConfig2配置类

作用:定制包扫描时的过滤规则

新建dao, service,controller

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsEnmDOg.jpg)![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsRVTUR1.jpg)![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpscPfdVM.jpg) 

 

在Cap2MainConfig2加入配置: @Filter: 扫描规则

 @ComponentScan(value="com.enjoy.cap2", includeFilters ={		@Filter(type=FilterType.ANNOTATION,classes={Controller.class}),		@Filter(type=FilterType.ASSIGNABLE_TYPE,classes={BookService.class})

}, useDefaultFilters =false) //默认是true,扫描所有组件，要改成false,使用自定义扫描范围

*/

//@ComponentScan value:指定要扫描的包

// excludeFilters  = Filter[] 指定扫描的时候按照什么规则排除那些组件

// includeFilters  = Filter[] 指定扫描的时候只需要包含哪些组件

// useDefaultFilters  = false 默认是true,扫描所有组件，要改成false

//－－－－扫描规则如下

//FilterType.ANNOTATION：按照注解

//FilterType.ASSIGNABLE_TYPE：按照给定的类型；比如按BookService类型

//FilterType.ASPECTJ：使用ASPECTJ表达式

//FilterType.REGEX：使用正则指定

//FilterType.CUSTOM：使用自定义规则，自已写类，实现TypeFilter接口

 

 

 

//FilterType.CUSTOM的例子,常用

先新增自定义过滤规则类:

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsPEqyYx.jpg) 

在Cap2MainConfig申明

@ComponentScan(value="com.enjoy.cap2",includeFilters={

​		@Filter(type=FilterType. *CUSTOM\**\***,classes={JamesTypeFilters. class })

},useDefaultFilters= false ) 

 public   class  Cap2MainConfig2 {}

 

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wps8glV1i.jpg) 

 三 CAP3章节  scope扫描规则 

1,新建Cap3MainConfig.java

###### ![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsfPFj53.jpg) 

2,没加@Scope之前, 默认的bean是单实例的. 新建 test01()方法测试如下:

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsy78I8O.jpg) 

返回true, 证明取到的是同一个person bean,只实例化了一次.

 

3, 加入@Scope(“prototype”) //多实例

prototype: 多实例：IOC容器启动并不会去调用方法创建对象放在容器中，而是                                  每次获取的时候才会调用方法创建对象,见test02

singleton: 单实例（默认）：IOC容器启动会调用方法创建对象放到IOC容器中

以后每交获取就是直接从容器（理解成从map.get对象）中拿  

request: 主要针对WEB应用，同一次请求创建一个实例

session: 同一个session创建一个实例（ 后面两个用得不多，了解即可 ）

 

 

 

 

 四 CAP4章节  lazy懒加载 

1,新建Cap4MainConfig.java

 

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsPhAacA.jpg) 

2,建立测试用例test01();

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsuedDfl.jpg) 

当在Cap4MainConfig加入@Lazy时,  只有获取anno.getBean时才会加载到IOC容器中

 

### 第二次课

 四 CAP5章节  @Conditional条件注册bean 

1,将IOC容器注册bean时, 当操作系统为WINDOWS时,注册Lison实例; 当操作系统为LINUX时, 注册James实例,此时要用得@Conditional注解进行定制化条件选择注册bean;

2,新建Cap7MainConfig1.java,

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsEYxqTk.jpg) 

新建WinCondition.java类做为条件类, 同时必须得实现spring提供的Confition接口

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsbEboMX.jpg) 

新建 LinuxCondition条件类, 用来处理操作系统为LINUX的bean注册

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsAf8mFA.jpg) 

2,   把IOC容器里的所有person实例名打印出来(为了看效果,刚开始在配置类可以 不加@Conditinal )

​	 @Test

​	  public   void  test01()

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsdGxnyd.jpg) 

 

3,   新建test02(), 测试@Conditional  条件加载bean到IOC容器( 加上@Conditinal )

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wps436orQ.jpg) 

当引入@Conditional时, 容器可以选择性的注册bean.

 

 

 五 CAP6章节  @Import注册bean 

同样按流程先新建Cap8MainConfig1.java配置类

新建Dog.ava类-----> public   class  Dog {}

新建Cat.java类----> public   class  Cat{}

按以下1,2,3箭头步骤分别导入多个类,使用import将dog, cat的bean注册到容器中,并测试打印,看容器中是否已加载此类

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsZotskt.jpg) 

 分别使用  

@Import(Dog.class)  

@Import({Dog.class,Cat.class})

 

ImportSelector可以批量导入组件的全类名数组,自定义逻辑返回需要导入的组件JamesImportSelector.java

@Import({Dog.class,Cat.class,JamesImportSelector.class})

 新建  JamesImportSelector  , 新建Fish  Tiger类(与建Cat和Dog一样) 

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsUElyd6.jpg) 

怎么测呢?

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsLZxF6I.jpg) 

 

当然,除了以上,还可以通过ImportBeanDefinitionRegistrar自定义注册,向容器中注册bean;

@Import({Dog. class ,Cat. class ,JamesImportSelector. class ,JamesImportBeanDefinitionRegistrar. class })

新建 JamesImportBeanDefinitionRegistrar 自定义注册类,实现bean注册

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsKQiOZl.jpg) 

当然除了以上加载方式,还可以通过实现FactoryBean接口方式来加载bean

\* 使用spring提供的FactoryBean(工厂bean)

​	 *  beans.factory.FatoryBean源码跟进去

​	 *   容器调用getObject()返回对象，把对象放到容器中；

​	 *   getObjectType()返回对象类型

​	 *   isSingleton()是否单例进行控制

​	 *   新建JamesFactoryBean实现FactoryBean

​	 *   在config里新建jamesFactoryBean()方法

​	 *   写完test03测试用例后:

​	 *    a,默认获取到的是工厂bean调用getObject创建的对象

​	 *    b,要获取工厂Bean本身,需要在id前加个  &jamesFactoryBean

​	 */	

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsxF8YSY.jpg) 

把自定义的 JamesImportBeanDefinitionRegistrar 加入配置类进行测试

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsoVibMB.jpg) 

 



### 第三次课



上节课讲的FactoryBean的实现,出现的问题说明如下:

测试用例里分析Object bean1 = anno.getBean("jamesFactoryBean");是Pig还是jamesFactoryBean的实例bean呢,调试跟进getBean源码看看(可看第三节课的视频)

发现实际是获取getObject创建的对象, 并不是jamesFactoryBean对象

 

注:当声明Object bean1 = anno.getBean("&jamesFactoryBean");, 获取到的bean为jamesFactoryBean对象, 也可跟进源码分析看看

 

 

 一, CAP7章节  bean的生命周期 

bean的生命周期:指  bean创建-----初始化----销毁  的过程

bean的生命周期是由容器进行管理的

我们可以自定义 bean初始化和销毁 方法: 容器在bean进行到当前生命周期的时候, 来调用自定义的初始化和销毁方法

 如何定义和销毁(4种方式):

  1)  指定初始化和销毁方法 <之前在beanx.xml, 可以指定init-method和destory-mothod>

​	用注释如何做: 新建Bike.java

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsNgtdKV.jpg) 

1.1> 指定初始化和销毁方法

​	在配置类里通过@Bean(initMethod="init", destroyMethod="destroy")指定

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpswgwhIf.jpg) 

1.2> 单实例: 当容器关闭的时候,会调用destroy消耗

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsNdQmGz.jpg) 

 

多实例: 容器只负责初始化,但不会管理bean, 容器关闭不会调用销毁方法

 

  2  )  让Bean实现 InitializingBean 和 DisposableBean接口

A, InitializingBean(定义初始化逻辑,可点进去看此类):afterPropertiesSet()方法:当beanFactory创建好对象,且把bean所有属性设置好之后,会调这个方法,相当于初始化方法

   B, DisposableBean(定义销毁逻辑,可点进去看此类):destory()方法,当bean销毁时,会把单实例bean进行销毁

 操作步骤:

 2.1> 新建Train.java类, 实现 InitializingBean, DisposableBean 接口

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsUWWtET.jpg) 

 2.2> 加载bean方式

:@Bean public Train train()或@Component  public class Train

​	或[在Config加上扫描@ComponentScan("com.enjoy.cap7.bean")](mailto:在Config加上扫描@ComponentScan(\),用以下方式

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wps5VQCCd.jpg) 

  测试用例只要加载容器和关闭容器即可.

 

 3)  可以使用JSR250规则定义的(java规范)两个注解来实现

​	 @PostConstruct: 在Bean创建完成,且属于赋值完成后进行初始化,属于JDK规范的注解

​	 @PreDestroy: 在bean将被移除之前进行通知, 在容器销毁之前进行清理工作

​	 步骤:新建Jeep.java

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wps01bNAx.jpg) 

 

 

-----只有以上三种,以下是后置处理器,负责在初始化方法前后作用--------

BeanPostProcessor类[interface]: bean的后 置处理器,在bean初始化之前调用进行拦截

​	 作用:在bean初始化前后进行一些处理工作, 打开此类

​	 a> p	  什么时候调用:它任何初始化方法调用之前(比如在InitializingBean的afterPropertiesSet初始化之前,或自定义init-method调用之前使用)     

​	 b> postProcessAfterInitialization():在初始化之后进行后置处理工作, 比如在InitializingBean的afterPropertiesSet()

​	 步骤: 新建后置处理器类JamesBeanPostProcessor

​	 ![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsjYmZyR.jpg)

总结:bean的整个生命周期我们都能控制 	

可以分析Bike的日志证明在init初始化之前调用了 postProcessBeforeInitialization  (), 

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsCEWcxb.jpg) 

 

 二, 容器启动及BeanPostProcessor源码分析 

针对以上cap12进行debug测试;

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsdWJrvv.jpg) 

加完断点后, 测试用例debug, 分析容器创建流程

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsaOGHtP.jpg) 

 

 

BeanPostProcessor原理:

可从容器类跟进顺序为:

AnnotationConfigApplicationContext-->refresh()-->

finishBeanFactoryInitialization(beanFactory)--->

beanFactory.preInstantiateSingletons()-->

760行getBean(beanName)--->

199行doGetBean(name,  null ,  null ,  false )-->

317行createBean(beanName, mbd, args)-->

501行doCreateBean(beanName, mbdToUse, args)-->

541行createBeanInstance(beanName, mbd, args)(完成bean创建)-->

578行populateBean(beanName, mbd, instanceWrapper)(属性赋值)-->

579行initializeBean(beanName, exposedObject, mbd)(Bean初始化)->

1069行到1710行,后置处理器完成对init方法的前后处理.

 

最终得到如下如下

createBeanInstance(beanName, mbd, args)(完成bean创建)

populateBean(beanName, mbd, instanceWrapper); 给bean进行属性赋值

initializeBean() //初始化Bean方法内容如下,后置处理器对init方法的前后处理

{

 applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);

  invokeInitMethods(beanName, wrappedBean, mbd)  //执行自定义初始化

 applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName)

}

从以上分析不难发现,bean的生命周期为bean的创建, 初始化, 当容器关闭时对单实例的bean进行销毁.





### 第四次课



 一 CAP7章节  Spring底层对BeanPostProcessor的使用 

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsXoZbE8.jpg) 

 1,  ApplicationContextAwareProcessor  实现分析  : 

此类帮我们组建IOC容器,跟进ApplicationContextAwareProcessor我们发现, 这个后置处理器其实就是判断我们的bean有没有实现ApplicationContextAware 接口,并处理相应的逻辑,其实所有的后置处理器原理均如此.

那么怎么组建呢? 只需要实现 ApplicationContextAware 接口

步骤:

  1>, 新建Plane.java(将Jeep.java复制一份即可)

​      class  Plane  implements  ApplicationContextAware

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsJ2Uk5m.jpg) 

分析一下ApplicationContextAwareProcessor类的方法

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpshVivwB.jpg) 

a,在创建Plane对象,还没初始化之前, 先判断是不是实现了ApplicationContextAware接口,

如果是的话就调用invokeAwareInterfaces方法, 并给里面注入值;

b,进入invokeAwareInterfaces()方法,判断是哪个aware, 如果是ApplicationContextAware, 就将当前的bean转成ApplicationContextAware类型, 调用setApplicationContext(), 把IOC容器注入到Plane里去;

c,用debug调用; 测试用例打断点测试

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wps1s7GXP.jpg) 

d,也可看debug调用栈来分析;

 注 : debug可以打在ApplicationContextAwareProcessor处理器类的applyBeanPostProcessorsBeforeInitialization()方法里, 方便调试, 当bean为Plane类型时,F5跟进看, 最终在 InvokeAwareInterfaces()方法里返回我们的IOC容器applicationContext.

 

 2,BeanValidationPostProcess分析:数据校验, 

   看BeanPostProcessor接口实现CTRL+T 

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsphqUo4.jpg) 

 

了解即可,处理器的原理和其它处理器一致.

 当对象创建完,给bean赋值后,在WEB用得特别多;把页面提交的值进行校验 

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsvin9Pi.jpg) 

 

 

 

 3,InitDestroyAnnotationBeanPostProcessor 

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpshUMphx.jpg) 

 

此处理器用来处理@PostConstruct, @PreDestroy, 怎么知道这两注解是前后开始调用的呢, 就是  InitDestroyAnnotationBeanPostProcessor这个处理的 

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wps1kKHIL.jpg) 

以@PostConstruct为例, 为什么声明这个注解后就能找到初始化init方法呢?

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpszQX09Z.jpg) 

 

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsRjAlBe.jpg) 

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsXBuH2s.jpg)    ![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wps9Jh4tH.jpg)

 

 

总结: Spring底层对BeanPostProcessor的使用, 包括bean的赋值, 注入其它组件, 生命周期注解功能,@Async, 等等

 

 

 

 

 二 CAP8章节  @Value赋值 

新建cap8目录;

1, 新建Bird.java类

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsh0GsVV.jpg) 

2,新建Cap8MainConfig.java配置类

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsjs5Sma.jpg) 

 

3,新建测试用例Cap8Test.java, 从容器获取bean并打印

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsRUEkOo.jpg) 

 

打印结果如下: 主要是没设值

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpshUkNfD.jpg) 

 

4,以前使用bean.xml配置文件进行赋值

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsVlXgHR.jpg) 

 

5,使用@Value赋值如何赋值呢?见下

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsrYCL85.jpg) 

 

6,从配置文件[properties]读取, 新建test.properties

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsLCqhAk.jpg) 

 

7,test.properties内容为bird.color=red

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wps1y8N1y.jpg) 

8,在Bird类新增private String color及set和get方法;

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsfoKltN.jpg) 

9,将test.properties配置文件加载起来

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpspymUU1.jpg) 

10,再运行test01()用例, 打印出以下结果

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsrRYtmg.jpg) 

 

11,test.properties值是加在运行环境变量里:

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wps78z4Nu.jpg) 

 

 

 

 

 三 CAP9章节  @Autowired自动装配 

自动装配:spring利用依赖注入(DI), 完成对IOC容器中的各个组件的依赖关系赋值

 

1,新建TestController.java  TestService.java  TestDao; 分别建在指定的包内,可看步骤2.

这些所有JAVA 类的对象扫描后都是保存在IOC容器中管理的;

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpshLGGfJ.jpg)   ![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsBGDjHX.jpg)   ![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsXEqX8b.jpg)

 

2,新建配置类Cap9MainConfig.java(),扫描并将以上bean都扫描并加载到容器

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsfBmCAq.jpg) 

 

3, 针对以上基础类建立完成后, 可以先做个测试

在TestService.java, 使用Autowired注入,并把testDao打印出来(在测试时方便对比)

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpszxsi2E.jpg) 

 

4, 新建Cap9Test.java测试用例,比较TestService拿到testDao与直接从容器中拿到的testDao是否为同一个?

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wps1sHZtT.jpg) 

结果很明显是同一个testDao,地址一样

 

 小结 :

@Autowired表示默认优先按 类型 去容器中找对应的组件,相当于anno.getBean(TestDao.class)去容器获取id为testDao的bean, 并注入到TestService的bean中;

使用方式如下:

  TestService{

​    @Autowired

​    private TestDao testDao;//默认去容器中找id为”testDao”的bean

  }

 

 

5, 注意事项

5.1如果容器中找到多个testDao, 会加载哪个testDao呢?

  操作步骤:

在Cap9MainConfig.java声明@Bean(“testDao2”)

 ![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsnJZIV7.jpg)

并将TestDao加入flag属性和set, get及toString方法,用来分辨加载了哪个bean.

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsLFttnm.jpg) 

如何区分TestService是使用了( @Reponstry的testDao的flag=1 )的bean还是( testDao2的flag=2 )的bean?

测试步骤如下:

 1, 直接使用@Autowired, 将testDao注入到TestService

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wps90gfPA.jpg) 

测试结果

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpspL31gP.jpg) 

 

 2, 如果一定要使用容器中的testDao2呢?操作如下:

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsFQPPI3.jpg) 

测试结果

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsVtBEai.jpg) 

 

 3, 虽然以上定义了private TestDao testDao2, 但还是想加载bean id为testDao(flag=1)的bean,怎么办?此时可以使用@Autowired和@Qualifier结合来指定注入哪一个bean,

操作如下:

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsDbsuCw.jpg) 

测试结果

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsNChl4K.jpg) 

 

 4, 如果容器中没有任何一个testDao, 会出现什么状况呢?

操作如下: 注释掉@Repository和@Bean("testDao2")

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsDY7cwZ.jpg)     ![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wps33S5Xd.jpg)

此时容器启动时这两个bean都不会加载(因为注解被注释啦.......)

测试结果如下:

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsfTGZps.jpg) 

很明显报错了, [因为@Autowired注解里的属性默认required=true.必须找到bean](mailto:因为@Autowired注解里的属性默认required=true.必须找到bean)

 

那怎么解决呢?

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsfpLURG.jpg) 

测试结果如下:

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsn5SQjV.jpg) 

 

 

 5, @Primary注解指定bean如何加载呢?

( 注 :将以上原注释掉的@Repository和@Bean("testDao2") 恢复,见下图)

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsldbOL9.jpg)    ![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsdzlMdo.jpg)

 

 

 重要:为了验证@Qualifier与@Primary两注解的加载顺序,测试如下 

当对于testDao在容器中同时存在多个时, 且@Qualifier与@Primary注解同时存在,会发生什么呢?

见下操作:  打开@Qualifier与@Primary注解.

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsd4HLFC.jpg) ![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsXE0L7Q.jpg)

 

测试结果:

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpszmkNz5.jpg) 

此时只能说明一点: @Qualifier是根据bean id指定获取testDao, 不受@Primary影响.

 

 

那么@Primary的功能在哪呢?继续测试.....

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsFGMP1j.jpg) 

测试结果:

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsnukTty.jpg) 

 

 

 

5.2除了@Autowired, 是不是还用过@Resource(JSR250)  和@Inject(JSR330) 

将Qualifier和Autowired注释掉(注意: 此时@Primary 还没注释......)

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsf8cYVM.jpg) 

 

测试结果:

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsBxe4n1.jpg) 

效果也是一样的, 但它不先优先装配@Primary的bean

 

 小结:@Resource和Autowired的区别如下: 

@Resource和Autowired一样可以装配bean

@Resource缺点: 不能支持@Primary功能

​        不能支持@Autowired(required = false)的功能

 

当然也可以在TestService里按以下方式指定要注入的Bean

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsRUubQf.jpg) 

测试结果: 

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsNCIjiu.jpg) 

 

 

5.3 @Inject自动装配的使用:

 注:@Inject与@Autowired的区别如下: 

@Inject和Autowired一样可以装配bean, 并支持@Primary功能, 可用于非spring框架.

@Inject缺点: 但不能支持@Autowired(required = false)的功能,需要引入第三方包javax.inject 

 

操作步骤:

1,pom.xml导入javax.inject包

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsVvftKI.jpg) 

 

2,使用@Inject注解

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsRnQDcX.jpg) 

 

 

结论:@Inject不支持required=false,  但支持primary

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsdsJPEb.jpg) 

Autowired属于spring的, 不能脱离spring,  @Resource和@Inject都是JAVA规范

推荐大家使用@Autowired

 

### 第五次课

一,  @Autowired方法, 参数, 构造方法都可加载, 跟进源码看看

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsIwgXfx.jpg) 

A>放到方法上的测试步骤:

  新建Moon.java

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsMCNeLQ.jpg) 

 

 

  新建Sun.java

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsqTqxga.jpg) 

setMoon()方法使用的参数,自定义类型的值从IOC容器中获取, 方法里的moon会从容器中拿到

 

以下是验证方式

在配置类要加入扫描bean包

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpseGiRLt.jpg) 

测试:

 新建test02()测试方法

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsS4hchN.jpg) 

 

结果如下:(为同一个bean)

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsiinyM6.jpg) 

方法使用的参数,自定义类型的值从IOC容器中获取, 方法里的moon会从容器中拿到

 

 

B> 将Autowired标记在有参构造器

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wps4XHVhq.jpg) 

构造函数的moon是从容器里拿到的

执行test02()测试;

 

 

 

 

 

同样,也可以放在构造器的参数位置也可以获取到IOC容器的bean.

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wps2IJkNJ.jpg) 

 

结论: 不管@Autowired是放到参数, 方法还是构造方法, 都是从容器里取到的bean...

 

 

 

 

 二 自动装配:Aware注入spring底层组件原理 

aware就是感知到这些接口是干什么的，如先举个`BeanNameAware`的例子，实现`BeanNameAware`接口，可以让该`Bean`感知到自身的`BeanName`（对应Spring容器的`BeanId`属性）属性

  自定义组件想要使用Spring容器底层的组件(ApplicationContext, BeanFactory, ......)

  思路: 自定义组件实现xxxAware, 在创建对象的时候, 会调用接口规定的方法注入到相关组件:Aware

  之前讲过Plane.java就是使用这个

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpscSbLi3.jpg) 

 

 

CTRL+SHIFT+T  找到Aware

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsGYVcOm.jpg) 

查看有哪些接口继承了Aware接口

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsQIBFjG.jpg) 

 

 

 

使用ApplicationContextAware接口为例, 实现接口

步骤:

1, 新建Light.java类, 实现ApplicaitonContextAware接口

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsQnx9OZ.jpg) 

 

 2,实现BeanNameAware接口

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsc0AEkj.jpg) 

 

 

 

 

 2,实现EmbeddedValueResolverAware接口

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsiD0aQC.jpg) 

 

3, 将Light类加入@Component, 声明为被扫描的组件

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wps4xJIlW.jpg) 

 

4,将test02()加入打印anno容器, 用来比如

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wps8fwhRf.jpg) 

 

5,测试, 执行test()02;

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsyekRmz.jpg) 

 

 

 总结 :把Spring底层的组件可以注入到自定义的bean中,ApplicationContextAware是利用ApplicationContextAwareProcessor来处理的, 其它XXXAware也类似, 都有相关的Processor来处理, 其实就是后置处理器来处理;

XXXAware---->功能使用了XXXProcessor来处理的, 这就是后置处理器的作用;

  ApplicaitonContextAware--->ApplicationContextProcessor后置处理器来处理的

 

问题: Spring怎么把applicationContext容器注入进来的呢????

  debug栈分析, 之前讲过的.

 

 

 

 

 

 

 

 

 三 CAP27  AOP功能测试 

AOP: 面向切面编程[底层就是动态代理]

指程序在运行期间动态的将某段代码切入到指定方法位置进行运行的编程方式

 

1,先建立MainConfigOfAOP配置类

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsyRetSS.jpg) 

2,在POM.XML中导入spring-aspects依赖包

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsyt95nc.jpg) 

 

3,新建立一个业务逻辑类Calculator.java

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsWR6JTv.jpg) 

在div()方法运行之前, 记录一下日志, 运行后也记录一下,运行出异常,也打印一下

有的同学可能会这么做, 在每个方法加入个打印.

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsGF5opP.jpg) 

但这样会有问题, 这种方式耦合了....

 

新建一个日志切面类....

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsg5g5U8.jpg) 

日志切面类的方法需要动态感知到div()方法运行到哪里了, 然后再执行, 如果除法开始, 就日志开始方法, 

  也叫通知方法, 分以下几种:

   前置通知: logStart(),在目标方法(div)运行之前运行 (@Before)

   后置通知:logEnd(), 在目标方法(div)运行结束之后运行,无论正常或异常结束 (@After)

   返回通知:logReturn, 在目标方法(div)正常返回之后运行 (@AfterReturning)

   异常通知:logException, 在目标方法(div)出现异常后运行(@AfterThrowing)

   环绕通知:以上没写,动态代理, 手动执行目标方法运行joinPoint.procced(),最底层通知,手动指定执行目标方法(@Around), 执行之前相当于前置通知, 执行之后相当于返回通知

其实就是通过反射执行目标对象的连接点处的方法；

 

给日志切面类LogAspect的方法标注何时运行(即通知注解)

怎么加入 呢?

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsennNqs.jpg) 

若不想区分切入了哪个方法及参数类型和个数,可以有如下指定方式:

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsEJzxWL.jpg) 

 

不难发现问题:注解里的内容是冗余重复的, 公共的代码应该抽出来

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsQRdjs5.jpg) 

并加上Around环绕通知

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsS2f6Xo.jpg) 

那么应该写一个公共切入点表达式.

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsq8xUtI.jpg) 

 

公共切入方法加要指定的方法

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsWFjKZ1.jpg) 

 

 

有了以上操作, 我们还需要将切面类和被切面的类, 都加入到容器中

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsS8gCvl.jpg) 

 

但这个时候还会有问题, Spring无法区别以上的两个bean哪个是切面类, 哪个是业务逻辑类

怎么区别呢????

只需要给切面类LogAspects上加一个注解@Aspect即可.

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpscBxv1E.jpg) 

 

是不是就完了呢?并没有

需要开启基于注解的AOP模式

给配置类中加@EnableAspectJAutoProxy[一定得加上,关键]

注意: 在spring以后会有很多@EnableXXXX, 表示开启某项功能, 取代XML配置

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsyF7pxY.jpg) 

 

测试: 新建一个测试类Cap10Test.java

同学们在测试的过程中, 应该怎么测? 很容易出问题.

大家可能会这么写:

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsSJ7l3h.jpg) 

没用到容器, 肯定是不行的, 获取bean时使用IOC容器取出bean

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsybcjzB.jpg) 

 运行结果如下:

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wps4toh5U.jpg) 

 

 ### 第六次课

使用JoinPoint可以拿到相关的内容, 比如方法名,  参数

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsINxEdx.jpg) 

 

那么方法正常返回, 怎么拿方法的返回值呢?

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wps7qb063.jpg) 

 

那么如果是异常呢?定义

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsknSm0A.jpg) 

 小结:  AOP看起来很麻烦, 只要3步就可以了:

 1,将业务逻辑组件和切面类都加入到容器中, 告诉spring哪个是切面类(@Aspect)

 2,在切面类上的每个通知方法上标注通知注解, 告诉Spring何时运行(写好切入点表达式,参照官方文档)

 3,开启基于注解的AOP模式  @EableXXXX

 



 九 CAP27 AOP源码透析 

![20200322_404e04](image/2.Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/20200322_404e04.png)

IOC启动先创建BeanFactory，它有一个getBean()方法用来获取bean.如果是IOC容器中没有，getBean的时候就会CreateBean,先初始化对象，然后属性赋值，然后initMethod方法，最后吧bean放到Map中。

 \* AOP原理：【看给容器中注册了什么组件，这个组件什么时候工作，这个组件的功能是什么？】

 \* 		 @EnableAspectJAutoProxy ；核心从这个入手,AOP整个功能要启作用,就是靠这个,加入它才有AOP

​    跟进 @EnableAspectJAutoProxy 源码:

 

//导入了此类,点进去看

@Import(AspectJAutoProxyRegistrar. class )

 public   @interface  EnableAspectJAutoProxy {

  //proxyTargetClass属性，默认false，采用JDK动态代理织入增强(实现接口的方式)；如果设为true，则采用CGLIB动态代理织入增强

  boolean  proxyTargetClass()  default   false ;

  //通过aop框架暴露该代理对象，aopContext能够访问

  boolean  exposeProxy()  default   false ;

}

 

 

它引入AspectJAutoProxyRegistrar, 并实现了ImportBeanDefinitionRegistrar接口

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsPniMT7.jpg) 

ImportBeanDefinitionRegistrar接口作用: 能给容器中自定义注册组件, 以前也使用过, 比如我们以前也使用过这个类

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsgZHcNE.jpg) 

 

在 AspectJAutoProxyRegistrar 里可以自定义注册一些bean

那么注册了什么bean呢? 以debug模式进行测试一下

给 AspectJAutoProxyRegistrar类 的 registerBeanDefinitions ()方法打上断点.

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsd7pEGb.jpg) 

 

  

看注册bean的如何处理?

AopConfigUtils.**registerAspectJAnnotationAutoProxyCreatorIfNecessary**(registry);

注册一个这个组件, 如果有需要的话....

 

 

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpssp67zI.jpg) 

点进去看看

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpstXaDtf.jpg) 

想注册一个AnnotationAwareAspectJAutoProxyCreator的组件, 如果registry已经有了的话,就执行以下操作;

但是我们的注册中还没有, 第一次, 所以来创建一个cls, 用registry把bean的定义做好, bean的名叫做internalAutoProxyCreator

 

其实就是利用 @EnableAspectJAutoProxy  中的  AspectJAutoProxyRegistrar给我们容器中注册一个 AnnotationAwareAspectJAutoProxyCreator组件;

翻译过来其实就叫做 ”注解装配模式的ASPECT切面自动代理创建器”组件

 

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsWzN9mM.jpg) 

判断if(registry.containsBeanDefinition(**ATUO_PROXY_CREATOR_BEAN_NAME**))

{

  如果容器中bean已经有了 internalAutoProxyCreator, 执行内部内容

}

else

创建AnnotationAwareAspectJAutoProxyCreator信息; 把此bean注册在registry中.

做完后, 相当于

其实就是 **ATUO_PROXY_CREATOR_BEAN_NAME值为**internalAutoProxyCreator,给容器中注册internalAutoProxyCreator组件, 该组件类型为AnnotationAwareAspectJAutoProxyCreator.class

 

可以打开之前讲过的Cap6Test, 用到了registry...

 

因此我们要重点研究AnnotationAwareAspectJAutoProxyCreator组件(ASPECT自动代理创建器), 研究这个透了, 整个原理也就明白了, 所有的原理就是看容 器注册了什么组件, 这个组件什么时候工作, 及工作时候的功能是什么?  只要把这几个研究清楚了,原理就都清楚了.

 

AnnotationAwareAspectJAutoProxyCreator神奇的组件分析:

类关系图如下,继承关系:

 AnnotationAwareAspectJAutoProxyCreator：

 \* 	AnnotationAwareAspectJAutoProxyCreator

 \* 	  ->AspectJAwareAdvisorAutoProxyCreator

 \* 		 ->AbstractAdvisorAutoProxyCreator

 \* 			 ->AbstractAutoProxyCreator

 \* 			  implements SmartInstantiationAwareBeanPostProcessor, BeanFactoryAware

 \* 						关注后置处理器（在bean初始化完成前后做事情）、自动装配BeanFactory

 

SmartInstantiationAwareBeanPostProcessor: bean的后置处理器

BeanFactoryAware 能把beanFacotry bean工厂传进来 

通过分析以上的bean继承关系我们发现,  具有BeanPostProcessor特点, 也有Aware接口的特点, 实现了BeanFactoryAware 接口

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsj6MJgj.jpg) 

 

那我们来分析做为beanPostProcessor后置处理器做了哪些工作, 做为BeanFactoryAware又做了哪些工作

 

 

 一  ,   分析  创建和注册AnnotationAwareAspectJAutoProxyCreator的  流程  : 

1）、register()传入配置类，准备创建ioc容器

2）、注册配置类，调用refresh（）刷新创建容器；

3）、registerBeanPostProcessors(beanFactory);注册bean的后置处理器来方便拦截bean的创建(主要是分析创建AnnotationAwareAspectJAutoProxyCreator)；

 1）、 先获取ioc容器已经定义了的需要创建对象的所有BeanPostProcessor

 2）、给容器中加别的BeanPostProcessor

 3）、优先注册实现了PriorityOrdered接口的BeanPostProcessor；

 4）、再给容器中注册实现了Ordered接口的BeanPostProcessor；

 5）、注册没实现优先级接口的BeanPostProcessor；

 6）、注册BeanPostProcessor，实际上就是创建BeanPostProcessor对象，保存在容器中；

 	创建internalAutoProxyCreator的BeanPostProcessor【其实就是AnnotationAwareAspectJAutoProxyCreator】

 	1）、创建Bean的实例

 	2）、populateBean；给bean的各种属性赋值

 	3）、initializeBean：初始化bean；

 			1）、invokeAwareMethods()：处理Aware接口的方法回调

 			2）、applyBeanPostProcessorsBeforeInitialization()：应用后置处理器的postProcessBeforeInitialization（）

 			3）、invokeInitMethods()；执行自定义的初始化方法

 			4）、applyBeanPostProcessorsAfterInitialization()；执行后置处理器的postProcessAfterInitialization（）；

 	4）、BeanPostProcessor(AnnotationAwareAspectJAutoProxyCreator)创建成功；--》aspectJAdvisorsBuilder

 7）、把BeanPostProcessor注册到BeanFactory中；

 	beanFactory.addBeanPostProcessor(postProcessor);

 

注意:以上是创建和注册AnnotationAwareAspectJAutoProxyCreator的过程

 

 			AnnotationAwareAspectJAutoProxyCreator => InstantiationAwareBeanPostProcessor

 

 

 

 

 

 二,   如何创建增强的  Caculator增强bean  的  流程  : 

 

 1,refresh--->finishBeanFactoryInitialization(beanFactory);完成BeanFactory初始化工作；创建剩下的单实例bean

 		1）、遍历获取容器中所有的Bean，依次创建对象getBean(beanName);

 				getBean->doGetBean()->getSingleton()->

 		2）、创建bean

 				【AnnotationAwareAspectJAutoProxyCreator在所有bean创建之前会有一个拦截，InstantiationAwareBeanPostProcessor，会调用postProcessBeforeInstantiation()】

 				2.1）、先从缓存中获取当前bean，如果能获取到，说明bean是之前被创建过的，直接使用，否则再创建；

 					只要创建好的Bean都会被缓存起来

 				2.2）、createBean（）;创建bean；

 					AnnotationAwareAspectJAutoProxyCreator 会在任何bean创建之前先尝试返回bean的实例

 					【BeanPostProcessor是在Bean对象创建完成初始化前后调用的】

 					【InstantiationAwareBeanPostProcessor是在创建Bean实例之前先尝试用后置处理器返回对象的】

 					2.2.1）、resolveBeforeInstantiation(beanName, mbdToUse);解析BeforeInstantiation,如果能返回代理对象就使用，如果不能就继续,后置处理器先尝试返回对象；

 			bean = applyBeanPostProcessorsBeforeInstantiation（）：

 			拿到所有后置处理器，如果是InstantiationAwareBeanPostProcessor;

 			就执行postProcessBeforeInstantiation

 			if (bean != null) {

​					bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);

​			}

 

 					2.2.2）、doCreateBean(beanName, mbdToUse, args);真正的去创建一个bean实例；和单实例bean创建流程一样；

 		

 

​			 			

  三,【AnnotationAwareAspectJAutoProxyCreator】作用: 

  InstantiationAwareBeanPostProcessor 

 ：

 1）、每一个bean创建之前，调用postProcessBeforeInstantiation()；

 		关心MathCalculator和LogAspect的创建

 		1）、判断当前bean是否在advisedBeans中（保存了所有需要增强bean）

 		2）、判断当前bean是否是基础类型的Advice、Pointcut、Advisor、AopInfrastructureBean，

 			或者是否是切面（@Aspect）

 		3）、是否需要跳过

 			1）、获取候选的增强器（切面里面的通知方法）【List<Advisor> candidateAdvisors】

 				每一个封装的通知方法的增强器是 InstantiationModelAwarePointcutAdvisor；

 				判断每一个增强器是否是 AspectJPointcutAdvisor 类型的；返回true

 			2）、永远返回false

 

 2）、创建对象

 postProcessAfterInitialization；

 		return wrapIfNecessary(bean, beanName, cacheKey);//包装如果需要的情况下

 		1）、获取当前bean的所有增强器（通知方法）  Object[]  specificInterceptors

 			1、找到候选的所有的增强器（找哪些通知方法是需要切入当前bean方法的）

 			2、获取到能在bean使用的增强器。

 			3、给增强器排序

 		2）、保存当前bean在advisedBeans中；

 		3）、如果当前bean需要增强，创建当前bean的代理对象；

 			1）、获取所有增强器（通知方法）

 			2）、保存到proxyFactory

 			3）、创建代理对象：Spring自动决定

 				JdkDynamicAopProxy(config);jdk动态代理；

 				ObjenesisCglibAopProxy(config);cglib的动态代理；

 		4）、给容器中返回当前组件使用cglib增强了的代理对象；

 		5）、以后容器中获取到的就是这个组件的代理对象，执行目标方法的时候，代理对象就会执行通知方法的流程；







# Spring源码分析

### 基于配置文件

首先讲讲基于配置文件的spring过程，在bean.xml中配置bean

```java
<bean id="person" class="xxx.xxx.Person">
    <property name="name" value="lixing"></property>
 </bean>
```

然后在运行类中将bean.xml文件加载进来，并且解析上面的代码，就会初始化一个Person实例对象，名字为person，这个过程是怎么做的呢？就是会找到路径下的Person类，利用反射将其实例化，并且赋值给person，然后组成键值对，放到一个Map中，这个Map就是IOC容器。哪里需要这个实例对象，就可以取出来

```java
ApplicationContext app = new ClassPathXmlApplicationContext("bean.xml");
Person person = (Person) app.getBean("person")；
```

### 基于注解

编写一个配置类，声明为@Configuration，说明这是一个配置文件。@Bean将生成的实例对象注入到IOC容器中。默认是将方法名当做key,也可以在@bean中指定

```java
@Configuration
public class MainConfig{
    @Bean
    public Person person(){
        return new Person("lixing")；
    }
}
```

Dao层的类中加入注解@Repository

> `@Component`, `@Service`, `@Controller`, `@Repository`是spring注解，注解后可以被spring框架所扫描并注入到spring容器来进行管理
> `@Component`是通用注解，其他三个注解是这个注解的拓展，并且具有了特定的功能
> `@Repository`注解在持久层中，具有将数据库操作抛出的原生异常翻译转化为spring的持久层异常的功能。
> `@Controller`层是spring-mvc的注解，具有将请求进行转发，重定向的功能。
> `@Service`层是业务逻辑层注解，这个注解只是标注该类处于业务逻辑层。
> 用这些注解对应用进行分层之后，就能将请求处理，义务逻辑处理，数据库操作处理分离出来，为代码解耦，也方便了以后项目的维护和z开发。

配置类中加入注解@ComponentScan(value="路径")进行组件扫描，找到标明@Controller,@Component,@Repository,@Server注解的类。并实例化对象放到IOC容器中。

@Scope扫描规则：Spring是单实例，@Scope("prototype"),

- prototype：多实例。
- singleton：单实例。
- request:主要针对web应用，递交一次请求创建一个实例
- session:同一个session创建一个实例

IOC容器：

- 多实例：仅当bean被使用的时候才创建

- 单实例：创建IOC容器的时候就被创建了。

  

@Lazy 懒加载:主要针对单实例，容器启动的时候不创建对象，仅当第一次使用或者获取bean的时候才初始化

**@Conditional**:实例化的时候进行判断，选择性的给容器中添加bean

- IOC就是对我们bean进行管理：bean注册，实例化，管理
- FactoryBean:可以把我们java实例的bean通过FactoryBean注入到容器中
- BeanFactory:从我们容器中获取实例化后的bean

**@Import**:注册bean

- 手动添加组件到IOC容器
- 使用ImportSelector自定义返回组件
- 使用ImportBeanDefinitionRegistrar返回自定义组件

给容器中注册组件的方式

- @Bean:导入第三方的类或包的组件,
- 包扫描+组件的标注注解：@ComponentScan,@Controller,@Service,@Repository,@Componet.一般针对自己写的类使用
- @Import:快速给容器导入一个组件:
  - 在配置类中加上@Import(value="XXX.class")，容器会自动注册这个组件，bean的id为全类名.
  - ImportSelector:是一个接口，返回需要导入到容器的组件的全类名数组，使用方法@Import(ImportSelector的实现类)
  - ImportBeanDefinitionRegistrar：可以手动将bean添加到容器。把所有需要加入容器的bean加入，使用RootBeanDefinition将bean进行封装。
- 使用Spring提供的FactoryBean进行注册：FactoryBean是一个接口，实现这个接口，有三个方法，getObject()返回对象，并把对象放入容器,getObjectType返回对象类型,isSingleton判断是否单例进行控制
- beanFactory是bean工厂，提供了getBean方法从IOC容器中将bean取出来。



### Bean的生命周期

对于单实例的bean创建过程，先会调用类的无参构造方法，然后初始化方法，将bean放入容器，最后进行销毁。

当容器被关闭时，会销毁所有缓存的单例的bean在BeanFactory.就是把Map给clear清空了

**初始化和销毁1**

bean的生命周期，创建->初始化->销毁

@@Bean(initMethod = "init",destroyMethod = "destroy")指定初始化和销毁方法

对于单实例的bean，可以正常调用初始化和销毁方法

对于多实例的bean，容器只负责初始化，但不会管理bean，容器关闭时不会调用销毁方法

**初始化和销毁2**

1.实现InitializingBean接口的afterPropertiesSet()方法，当beanFactory创建好对象，且把bean所有属性设置好之后，会调用这个方法，相当于初始化。

2.实现DisposableBean的destory()方法，当bean销毁时，会把单例bean进行销毁。

**初始化和销毁3**

可以使用JSR250规定的两个注解实现

- @PostConstruct:在bean创建完成后进行初始化
- @PreDestory:在bean将被移除之前进行通知，在容器销毁之前进行清理工作



**生命周期-BeanPostProcessorsr**

bean的后置处理器，在bean初始化之前调用进行拦截，在bean初始化前后进行一些处理工作，使用BeanPostProcessors如何控制Bean的生命周期

实现BeanPostProcessors的两个接口即可

- postProcessBeforeInitialization()
- postProcessAfterInitialization()

在初始化之前调用postProcessBeforeInitialization，初始化之后调用postProcessAfterInitialization，对初始化方法进行增强。

#### bean的创建过程

refresh()->finishBeanFactoryInitialization(beanFactory)(完成单例bean的初始化)->beanFactory.preInstantiateSingletons()（初始化所有非懒加载的单例bean）->getBean(beanName)

->doGetBean（首先从内存中取，如果内存中有就返回，没有就创建bean)->createBean->doCreateBean

然后创建bean

```java
if (instanceWrapper == null) {
			instanceWrapper = createBeanInstance(beanName, mbd, args);
		}
```

然后开始赋值和初始化

```java
try {
			populateBean(beanName, mbd, instanceWrapper);
			exposedObject = initializeBean(beanName, exposedObject, mbd);
		}
```

初始化时有后置方法对初始化进行增强

```java
Object wrappedBean = bean;
		if (mbd == null || !mbd.isSynthetic()) {
			wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
		}

		try {
			invokeInitMethods(beanName, wrappedBean, mbd);
		}
		catch (Throwable ex) {
			throw new BeanCreationException(
					(mbd != null ? mbd.getResourceDescription() : null),
					beanName, "Invocation of init method failed", ex);
		}
		if (mbd == null || !mbd.isSynthetic()) {
			wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
		}

```



### 后置处理器

在进入spring bean的初始化方法的时候，代码如下：

```java
		Object wrappedBean = bean;
		if (mbd == null || !mbd.isSynthetic()) {
			wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
		}

		try {
			invokeInitMethods(beanName, wrappedBean, mbd);
		}
		catch (Throwable ex) {
			throw new BeanCreationException(
					(mbd != null ? mbd.getResourceDescription() : null),
					beanName, "Invocation of init method failed", ex);
		}
		if (mbd == null || !mbd.isSynthetic()) {
			wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
		}

		return wrappedBean;
```

applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);后置处理器，对初始化方法进行增强

```java
@Override
	public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)
			throws BeansException {

		Object result = existingBean;
		for (BeanPostProcessor processor : getBeanPostProcessors()) {
			Object current = processor.postProcessBeforeInitialization(result, beanName);
			if (current == null) {
				return result;
			}
			result = current;
		}
		return result;
	}
```

他会循环所有BeanPostProcessor，bean在运行时才能知道它的类型。

Spring底层通过实现BeanPostProcessor接口，实现一些后置处理器，包括bean的赋值，注入其他组件，生命周期注解功能等。



### 赋值

@Value赋值

1.使用bean.xml配置文件赋值

2.使用@Value赋值：基本字符赋值，Spring表达式赋值，获取运行环境变量的值

3.使用@Value从*.properties取值，@PropertySource(value="XX*.properties")



### 自动装配

@Autowired @Qualifier @Primary

什么是是自动装配?

   -spring利用依赖注入(DI), 完成对IOC容器中的各个组件的依赖关系赋值

思考与操作?
       1,bean组件加载优先级?
       2,如果容器中存在两个id相同的bean, 会加载哪个bean呢?@Autowired
       3,如何指定装配组件ID进行加载?@Qualifier
       4,容器加载不存在的bean会出现什么问题?
       5,@Primary 注解bean首选如何使用?
       6,@Autowired @Resource @Inject区别?

@Autowired表示默认优先按**类型**去容器中找对应的组件,相当于anno.getBean(TestDao.class)去容器获取id为testDao的bean, 并注入到TestService的bean中;

```java
 TestService{
		@Qualifier("testDao2")
		@Autowired
		 private TestDao testDao;//默认去容器中找id为”testDao”的bean

  }
```

此时可以使用@Autowired和@Qualifier结合来指定注入哪一个bean,

@Primary注解指定bean如何加载呢?指定最高的优先级。

@Primary当需要多个testDao时，默认使用@Primary的bean,其他的冗余。

@Qualifier+@Autowired使用名称去ioc容器中找bean



#### @Autowired



小结:@Resource和Autowired的区别如下:

@Resource和Autowired一样可以装配bean

@Resource缺点: 不能支持@Primary功能

​        						不能支持@Autowired(required = false)的功能



注:@Inject与@Autowired的区别如下:

@Inject和Autowired一样可以装配bean, 并支持@Primary功能, 可用于非spring框架.

@Inject缺点: 但不能支持@Autowired(required = false)的功能,需要引入第三方包javax.inject 

 

Autowired属于spring的, 不能脱离spring,  @Resource和@Inject都是JAVA规范



@Autowired可以放在任何方法上，参数上，构造方法上，当@Autowired标注在方法上的时候，Spring容器创建当前对象时，就会调用方法，完成赋值。



#### Aware注入spring底层组件原理

ApplicationContextAware：用来获取IOC容器，自动注入IOC容器

![image-20200219112959095](/home/lixing/文档/image/image-20200219112959095.png)





总结:

把Spring底层的组件可以注入到自定义的bean中,ApplicationContextAware是利用ApplicationContextAwareProcessor来处理的, 其它XXXAware也类似, 都有相关的Processor来处理, 其实就是后置处理器来处理;

XXXAware---->功能使用了XXXProcessor来处理的, 这就是后置处理器的作用;

  ApplicaitonContextAware--->ApplicationContextProcessor后置处理器来处理的



### AOP

AOP: 面向切面编程[底层就是动态代理]

指程序在运行期间动态的将某段代码切入到指定方法位置进行运行的编程方式.

以日志切面类为例：

也叫通知方法, 分以下几种:

   前置通知: logStart(),在目标方法(div)运行之前运行 (@Before)

   后置通知:logEnd(), 在目标方法(div)运行结束之后运行,无论正常或异常结束 (@After)

   返回通知:logReturn, 在目标方法(div)正常返回之后运行 (@AfterReturning)

   异常通知:logException, 在目标方法(div)出现异常后运行(@AfterThrowing)

   环绕通知:以上没写,动态代理, 手动执行目标方法运行joinPoint.procced(),最底层通知,手动指定执行目标方法(@Around), 执行之前相当于前置通知, 执行之后相当于返回通知。其实就是通过反射执行目标对象的连接点处的方法；

使用JoinPoint可以拿到相关的内容, 比如方法名,  参数

```java
@Aspect
public class LogAspects {

    @Pointcut("execution(public int Demo2.Calculater.*(..))")
    public void pointCut(){}

    @Before("pointCut()")
    public void logStart(JoinPoint joinPoint){
        System.out.println("开始");
        System.out.println(joinPoint.getSignature().getName()+"参数列表"+Arrays.asList(joinPoint.getArgs())
    }
    @After("pointCut()")
    public void logEnd(){
        System.out.println("结束");
    }
}

```

配置文件

```java
@Configuration
@EnableAspectJAutoProxy//开启此注解功能
public class Demo2Config {
    @Bean
    public Calculater calculater(){
        return new Calculater();
    }

    @Bean
    public LogAspects logAspects(){
        return new LogAspects();
    }
}
```

小结：

AOP看起来很麻烦, 只要3步就可以了:

 1,将业务逻辑组件和切面类都加入到容器中, 告诉spring哪个是切面类(@Aspect)

 2,在切面类上的每个通知方法上标注通知注解, 告诉Spring何时运行(写好切入点表达式,参照官方文档)

 3,开启基于注解的AOP模式  @EableXXXX

 

AOP源码：

AOP原理：看给容器中注册了什么组件，这个组件什么时候工作，这个组件的功能是什么？

@EnableAspectJAutoProxy：核心从这个入手,AOP整个功能要启作用,就是靠这个,加入它才有AOP

这个类中导入了@Import(AspectJAutoProxyRegistrar.class) ，

```java
class AspectJAutoProxyRegistrar implements ImportBeanDefinitionRegistrar
```

ImportBeanDefinitionRegistrar接口作用: 能给容器中自定义注册组件.

其实就是利用@EnableAspectJAutoProxy中的AspectJAutoProxyRegistrar(AspectJ自动代理注册器)给我们容器中注册一个AnnotationAwareAspectJAutoProxyCreator组件;

翻译过来其实就叫做 ”注解装配模式的ASPECT切面自动代理创建器”组件



因此我们要重点研究AnnotationAwareAspectJAutoProxyCreator组件(ASPECT自动代理创建器), 研究这个透了, 整个原理也就明白了, 所有的原理就是看容 器注册了什么组件, 这个组件什么时候工作, 及工作时候的功能是什么?  只要把这几个研究清楚了,原理就都清楚了.



<img src="/home/lixing/文档/image/image-20200219204218972.png" alt="image-20200219204218972" style="zoom:200%;" />

SmartInstantiationAwareBeanPostProcessor: bean的后置处理器

BeanFactoryAware 能把beanFacotry bean工厂传进来 

通过分析以上的bean继承关系我们发现,  具有BeanPostProcessor特点, 也有Aware接口的特点, 实现了BeanFactoryAware 接口



#### 一、创建和注册AnnotationAwareAspectJAutoProxyCreator的流程

1）、register()传入配置类，准备创建ioc容器

2）、注册配置类，调用refresh（）刷新创建容器；

3）、registerBeanPostProcessors(beanFactory);注册bean的后置处理器来方便拦截bean的创建(主要是分析创建AnnotationAwareAspectJAutoProxyCreator)；

 1）、 先获取ioc容器已经定义了的需要创建对象的所有BeanPostProcessor

 2）、给容器中加别的BeanPostProcessor

 3）、优先注册实现了PriorityOrdered接口的BeanPostProcessor；

 4）、再给容器中注册实现了Ordered接口的BeanPostProcessor；

 5）、注册没实现优先级接口的BeanPostProcessor；

 6）、注册BeanPostProcessor，实际上就是创建BeanPostProcessor对象，保存在容器中；

 	创建internalAutoProxyCreator的BeanPostProcessor【其实就是AnnotationAwareAspectJAuto Proxy Creator】

 	1）、在doCreateBean()方法中，用beanWrapper包装，然后利用反射机制创建Bean的实例

 	2）、populateBean；给bean的各种属性赋值

 	3）、initializeBean：初始化bean；

 			1）、invokeAwareMethods()：处理Aware接口的方法回调

 			2）、applyBeanPostProcessorsBeforeInitialization()：应用后置处理器的postProcessBefore 

​						Initialization（）

 			3）、invokeInitMethods()；执行自定义的初始化方法

 			4）、applyBeanPostProcessorsAfterInitialization()；执行后置处理器的postProcessAfter 

​						Initialization（）；

 	4）、BeanPostProcessor(AnnotationAwareAspectJAutoProxyCreator)创建成功；--》

​						aspectJAdvisorsBuilder

 7）、把BeanPostProcessor注册到BeanFactory中；

 	beanFactory.addBeanPostProcessor(postProcessor);

 

注意:以上是创建和注册AnnotationAwareAspectJAutoProxyCreator的过程

 AnnotationAwareAspectJAutoProxyCreator 对应=> InstantiationAwareBeanPostProcessor类型



#### 二、如何创建增强的Caculator(自己写的)增强bean的流程

 

 1,refresh--->finishBeanFactoryInitialization(beanFactory);完成BeanFactory初始化工作；创建剩下的单实例bean

 		1）、遍历获取容器中所有的Bean，依次创建对象getBean(beanName);

 				getBean->doGetBean()->getSingleton()->createBean

 		2）、创建bean

 				【AnnotationAwareAspectJAutoProxyCreator在所有bean创建之前会有一个拦截，InstantiationAwareBeanPostProcessor，会调用postProcessBeforeInstantiation()】

 				2.1）、先从缓存中获取当前bean，如果能获取到，说明bean是之前被创建过的，直接使用，否则再创建；

 					只要创建好的Bean都会被缓存起来

 				2.2）、createBean（）;创建bean；

 					AnnotationAwareAspectJAutoProxyCreator 会在任何bean创建之前先尝试返回bean的实例

 					【BeanPostProcessor是在Bean对象创建完成初始化前后调用的】

 					【InstantiationAwareBeanPostProcessor是在创建Bean实例之前先尝试用后置处理器返回对象的】

 					2.2.1）、resolveBeforeInstantiation(beanName, mbdToUse)前置处理器，主要和AOP类相关;解析BeforeInstantiation,如果能返回代理对象就使用，如果不能就继续,后置处理器先尝试返回对象；

 			bean = applyBeanPostProcessorsBeforeInstantiation（）：

 			拿到所有后置处理器，如果是InstantiationAwareBeanPostProcessor;

 			就执行postProcessBeforeInstantiation

 			if (bean != null) {

​					bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);

​			}

 后置处理器是和业务类相关的处理，做动态代理，创建代理的增强的caculator对象

 					2.2.2）、doCreateBean(beanName, mbdToUse, args);真正的去创建一个bean实例；和单实例bean创建流程一样；



#### 享学第七次课

 一，  目标方法执行  （  caculator.div()方法执行切面拦截  ） ；

 		容器中保存了组件的代理对象（cglib增强后的对象），这个对象里面保存了详细信息（比如增强器，目标对象，xxx）；

 		1）、CglibAopProxy.intercept();拦截目标方法的执行

 		2）、根据ProxyFactory对象获取将要执行的目标方法拦截器链；

 			List<Object> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);

 			1）、List<Object> interceptorList保存所有拦截器 5

 				一个默认的ExposeInvocationInterceptor 和 4个增强器；

 			2）、遍历所有的增强器，将其转为Interceptor；

 				registry.getInterceptors(advisor);

 			3）、将增强器转为List<MethodInterceptor>；

 				如果是MethodInterceptor，直接加入到集合中

 				如果不是，使用AdvisorAdapter将增强器转为MethodInterceptor；

 				转换完成返回MethodInterceptor数组；

 

 		3）、如果没有拦截器链，直接执行目标方法;

 			拦截器链（每一个通知方法又被包装为方法拦截器，利用MethodInterceptor机制）

 		4）、如果有拦截器链，把需要执行的目标对象，目标方法，

 			拦截器链等信息传入创建一个 CglibMethodInvocation 对象，

 			并调用 Object retVal =  mi.proceed();

 		5）、拦截器链的触发过程;

 			1)、如果没有拦截器执行执行目标方法，或者拦截器的索引和拦截器数组-1大小一样（指定到了最后一个拦截器）执行目标方法；

 			2)、链式获取每一个拦截器，拦截器执行invoke方法，每一个拦截器等待下一个拦截器执行完成返回以后再来执行；

 				拦截器链的机制，保证通知方法与目标方法的执行顺序；

 		

 	总结：

 		1）、  @EnableAspectJAutoProxy 开启AOP功能

 		2）、 @EnableAspectJAutoProxy 会给容器中注册一个组件 AnnotationAwareAspectJAutoProxyCreator

 		3）、AnnotationAwareAspectJAutoProxyCreator是一个后置处理器；

 		4）、容器的创建流程：

 			1）、registerBeanPostProcessors（）注册后置处理器；创建AnnotationAwareAspectJAutoProxyCreator对象

 			2）、finishBeanFactoryInitialization（）初始化剩下的单实例bean

 				1）、创建业务逻辑组件和切面组件

 				2）、AnnotationAwareAspectJAutoProxyCreator拦截组件的创建过程

 				3）、组件创建完之后，判断组件是否需要增强

 					是：切面的通知方法，包装成增强器（Advisor）;给业务逻辑组件创建一个代理对象（cglib）；

 		5）、执行目标方法：

 			1）、代理对象执行目标方法

 			2）、CglibAopProxy.intercept()；

 				1）、得到目标方法的拦截器链（增强器包装成拦截器MethodInterceptor）

 				2）、利用拦截器的链式机制，依次进入每一个拦截器进行执行；

 				3）、效果：

 					正常执行：前置通知-》目标方法-》后置通知-》返回通知

 					出现异常：前置通知-》目标方法-》后置通知-》异常通知

 

拦截流程图如下：

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsPCHNem.jpg)











 

#### 三、AnnotationAwareAspectJAutoProxyCreator作用:

InstantiationAwareBeanPostProcessor ：

 1）、每一个bean创建之前，调用postProcessBeforeInstantiation()；

 		关心MathCalculator和LogAspect的创建

 		1）、判断当前bean是否在advisedBeans中（保存了所有需要增强bean）

 		2）、判断当前bean是否是基础类型的Advice、Pointcut、Advisor、AopInfrastructureBean，

 			或者是否是切面（@Aspect）

 		3）、是否需要跳过

 			1）、获取候选的增强器（切面里面的通知方法）【List<Advisor> candidateAdvisors】

 				每一个封装的通知方法的增强器是 InstantiationModelAwarePointcutAdvisor；

 				判断每一个增强器是否是 AspectJPointcutAdvisor 类型的；返回true

 			2）、永远返回false

 

 2）、创建对象

 postProcessAfterInitialization；

 		return wrapIfNecessary(bean, beanName, cacheKey);//包装如果需要的情况下

 		1）、获取当前bean的所有增强器（通知方法）  Object[]  specificInterceptors

 			1、找到候选的所有的增强器（找哪些通知方法是需要切入当前bean方法的）

 			2、获取到能在bean使用的增强器。

 			3、给增强器排序

 		2）、保存当前bean在advisedBeans中；

 		3）、如果当前bean需要增强，创建当前bean的代理对象；

 			1）、获取所有增强器（通知方法）

 			2）、保存到proxyFactory

 			3）、创建代理对象：Spring自动决定

 				JdkDynamicAopProxy(config);jdk动态代理；

 				ObjenesisCglibAopProxy(config);cglib的动态代理；

 		4）、给容器中返回当前组件使用cglib增强了的代理对象；

 		5）、以后容器中获取到的就是这个组件的代理对象，执行目标方法的时候，代理对象就会执行通知方法的流程；

<img src="/home/lixing/文档/image/AOP.png" alt="AOP" style="zoom:200%;" />



#### 享学第八次课：

 CAP11 声明式事务 

 

1， 环境搭建：导入数据源、数据库驱动、Spring-jdbc依赖

在pom.xml新增c3p0依赖包(c3p0封装了jdbc 对DataSource接口的实现)

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsSlBcwf.jpg) 

 

在pom.xml新增数据库驱动依赖包

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsGOPasr.jpg) 

 

在pom.xml新增spring-jdbc依赖包（jdbcTemplate）

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsy1YboD.jpg) 

 

 

2，新建Cap10MainConfig,将数据源和操作模板加载到IOC容器中

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsF9lgkP.jpg) 

 

3，新建Order测试表

 

CREATE TABLE `order` (
 `orderid` int(11) DEFAULT NULL,
 `ordertime` datetime DEFAULT NULL,
 `ordermoney` decimal(20,0) DEFAULT NULL,
 `orderstatus` char(1) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8

 

4，新建OrderDao操作数据库类

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsQJqqg1.jpg) 

 

5，新建 OrderService类，将orderDao注入进来

 

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsHlxCcd.jpg) 

 

 

6，将OrderService和OrderDao扫描进来，加载到容器

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsAUxQ8o.jpg) 

 

7，新建测试用例进入测试（ 测试结果：正常向数据库插入了一条记录 ）

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsZRu64A.jpg) 

8，对OrderService引入异常，看是否还能插入数据库？

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsUjio1M.jpg) 

测试结果：报异常， 但数据库正常插入。

 

9，可以给OrderService添加事务，若出现异常，看是否能全部回滚？

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsDP2HXY.jpg) 

测试结果：事务不起作用， 照样可以成功插入

 

10，基于上以分析，其实我们之前在xml配置里， 会配置开启基于注解的事务管理功能

  @EnableTransactionalManagement开启基于注解的事务管理功能，和AOP一样Enablexx

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsWh73Ta.jpg) 

 

再测试，测试结果为：出错啦…………IOC容器没有这个事务管理器bean。

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsTYlsQm.jpg) 

 

 

11，将事务管理器的bean加载到容器中，修改配置类，新增以下注册

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wps8muSMy.jpg) 

再测试，测试结果： 正常回滚，没有报错 

 

12, @EnableTransactionManagement源码分析（与AOP的创建拦截流程一致）：

 1）、@EnableTransactionManagement

 		利用TransactionManagementConfigurationSelector给容器中会导入组件

 		导入两个组件

 		AutoProxyRegistrar

 		ProxyTransactionManagementConfiguration

 2）、AutoProxyRegistrar：

 		给容器中注册一个 InfrastructureAdvisorAutoProxyCreator 组件；基本的动态代理创建器

 		InfrastructureAdvisorAutoProxyCreator：？

 		利用后置处理器机制在对象创建以后，包装对象，返回一个代理对象（增强器），代理对象执行方法利用拦截器链进行调用；

 

 3）、ProxyTransactionManagementConfiguration 做了什么？

 		1、给容器中注册事务增强器；

 			1）、事务增强器要用事务注解的信息，AnnotationTransactionAttributeSource解析事务注解

 			2）、事务拦截器：

 				TransactionInterceptor；保存了事务属性信息，事务管理器；

 				他是一个 MethodInterceptor；

 				在目标方法执行的时候；

 					执行拦截器链；

 					事务拦截器：

 						1）、先获取事务相关的属性

 						2）、再获取PlatformTransactionManager，如果事先没有添加指定任何transactionmanger

 							最终会从容器中按照类型获取一个PlatformTransactionManager；

 						3）、执行目标方法

 							如果异常，获取到事务管理器，利用事务管理回滚操作；

 							如果正常，利用事务管理器，提交事务

 		

##### Spring事务

spring事务：
什么是事务:
事务逻辑上的一组操作,组成这组操作的各个逻辑单元,要么一起成功,要么一起失败.

事务特性（4种）:
原子性 （atomicity）:强调事务的不可分割.
一致性 （consistency）:事务的执行的前后数据的完整性保持一致.
隔离性 （isolation）:一个事务执行的过程中,不应该受到其他事务的干扰
持久性（durability） :事务一旦结束,数据就持久到数据库

如果不考虑隔离性引发安全性问题:
脏读 :一个事务读到了另一个事务的未提交的数据
不可重复读 :一个事务读到了另一个事务已经提交的 update 的数据导致多次查询结果不一致.
虚幻读 :一个事务读到了另一个事务已经提交的 insert 的数据导致多次查询结果不一致.

解决读问题: 设置事务隔离级别（5种）
DEFAULT 这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别.
未提交读（read uncommited） :脏读，不可重复读，虚读都有可能发生
已提交读 （read commited）:避免脏读。但是不可重复读和虚读有可能发生
可重复读 （repeatable read） :避免脏读和不可重复读.但是虚读有可能发生.
串行化的 （serializable） :避免以上所有读问题.
Mysql 默认:可重复读
Oracle 默认:读已提交

![这里写图片描述](image/2.Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1053956-20170313102548791-1506111244.png)


read uncommited：是最低的事务隔离级别，它允许另外一个事务可以看到这个事务未提交的数据。
read commited：保证一个事物提交后才能被另外一个事务读取。另外一个事务不能读取该事物未提交的数据。
repeatable read：这种事务隔离级别可以防止脏读，不可重复读。但是可能会出现幻象读。它除了保证一个事务不能被另外一个事务读取未提交的数据之外还避免了以下情况产生（不可重复读）。
serializable：这是花费最高代价但最可靠的事务隔离级别。事务被处理为顺序执行。除了防止脏读，不可重复读之外，还避免了幻象读（避免三种）。

事务的传播行为
PROPAGION_XXX :事务的传播行为
* 保证同一个事务中
PROPAGATION_REQUIRED 支持当前事务，如果不存在 就新建一个(默认)
PROPAGATION_SUPPORTS 支持当前事务，如果不存在，就不使用事务
PROPAGATION_MANDATORY 支持当前事务，如果不存在，抛出异常
* 保证没有在同一个事务中
PROPAGATION_REQUIRES_NEW 如果有事务存在，挂起当前事务，创建一个新的事务
PROPAGATION_NOT_SUPPORTED 以非事务方式运行，如果有事务存在，挂起当前事务
PROPAGATION_NEVER 以非事务方式运行，如果有事务存在，抛出异常
PROPAGATION_NESTED 如果当前事务存在，则嵌套事务执行




### 享学第九次课：

 CAP12 BeanFactory的两个重要后置处理器 

 	BeanFactory去bean工厂中去获取bean,就是去ioc中拿bean,拿到单例直接返回，拿不到创建，有反射，代理，cglib，增强等方法。

FactoryBean:工厂模式，要生成什么样的bean

 1，扩展原理－BeanFactoryPostProcessor 

BeanFactoryPostProcessor：beanFactory的后置处理器；

作用如下：  	

a),在BeanFactory标准初始化之后调用，来定制和修改BeanFactory的内容；

 b),所有的bean定义信息已经保存加载到beanFactory，但是bean的实例还未创建

 

 注意： 之前也讲过BeanPostProcessor，它是bean后置处理器，bean创建对象初始化前后进行拦截工作的

 

操作步骤：

1〉新建ExtConfig.java配置类

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsHkSfwA.jpg)  

新建JamesBeanFactoryPostProcessor.java处理器类（在com.enjoy.cap12.processor目录下）

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsEy6Pjr.jpg) 

 

 

BeanFacotry是在bean组件创建之前还是之后生成的呢？写一个测试用例

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wps3sCs7h.jpg) 

不难发现，在“Moon constructor”创建之前，当前9个bean已被加载到beanFactory中了。

测试结果结下：

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wps4y96U8.jpg) 

 

 

 

 那么以上BeanFactoryPostProcessor执行原理是怎么样的呢，打断点F5调试一下:

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wps1EXNIZ.jpg) 

跟踪debug栈,不难发现以下步骤如下：

 1)、ioc容器创建对象

 2)、invokeBeanFactoryPostProcessors(beanFactory);

 		如何找到所有的BeanFactoryPostProcessor并执行他们的方法；

 			a）、直接在BeanFactory中找到所有类型是BeanFactoryPostProcessor的组件，并执行他们的方法

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsYAlxwQ.jpg) 

 \* 			b）、在初始化创建其他组件前面执行

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpspc8ikH.jpg) 

 

 

然后再点进去,

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wps4ml77x.jpg) 

 

 

 

 

2，扩展原理 ：BeanDefinitionRegistryPostProcessor ，bean定义相关的处理器

 

postProcessBeanDefinitionRegistry();在所有bean定义信息将要被加载，bean实例还未创建的；

 

操作步骤：

新建JamesBeanDefinitionRegistryPostProcessor

 注意 ：可使用BeanDefinitionBuilder构建器来创建bean定义信息

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsXIsYVo.jpg) 

测试结果如下：

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsyvyTJf.jpg) 

源码分析：从refresh()-->invokeBeanFactoryPostProcessors()-->PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(), 跟进去即发现代码逻辑如下：

 

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsHLzTx6.jpg) 

所以，在任何情况下都会优先执行BeanDefinitionRegistryPostProcessor的处理器，而BeanFactoryPostProcessor的处理器在它后面执行

 

 

 

 3，IOC容器处理流程（其实就是研究一下refresh()下的这些方法） 

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsEXcYlX.jpg) 

Spring容器的refresh()【创建刷新】;

1、prepareRefresh()刷新前的预处理;

​	1）、initPropertySources()初始化一些属性设置;子类自定义个性化的属性设置方法；

​	2）、getEnvironment().validateRequiredProperties();检验属性的合法等

​	3）、earlyApplicationEvents= new LinkedHashSet<ApplicationEvent>();保存容器中的一些早期的事件；

2、obtainFreshBeanFactory();获取BeanFactory；

​	1）、refreshBeanFactory();刷新【创建】BeanFactory；

​			110行：创建了一个this.beanFactory = new DefaultListableBeanFactory();

​			设置id；

​	2）、getBeanFactory();返回刚才GenericApplicationContext创建的BeanFactory对象；

​	3）、将创建的BeanFactory【DefaultListableBeanFactory】返回；

3、prepareBeanFactory(beanFactory);BeanFactory的预准备工作（以上创建了beanFactory,现在对BeanFactory对象进行一些设置属性）；

​	1）、设置BeanFactory的类加载器、支持表达式解析器...

​	2）、添加部分BeanPostProcessor【ApplicationContextAwareProcessor】

​	3）、设置忽略的自动装配的接口EnvironmentAware、EmbeddedValueResolverAware、xxx；

​	4）、注册可以解析的自动装配；我们能直接在任何组件中自动注入：

​			BeanFactory、ResourceLoader、ApplicationEventPublisher、ApplicationContext

​	5）、添加BeanPostProcessor【ApplicationListenerDetector】

​	6）、添加编译时的AspectJ；

​	7）、给BeanFactory中注册一些能用的组件；

​		environment【ConfigurableEnvironment】、

​		systemProperties【Map<String, Object>】、

​		systemEnvironment【Map<String, Object>】

4、

```
// 允许在上下文子类中对bean工厂进行后处理，这个里面是空的，子类通过重写这个方法来定义自己的实现
postProcessBeanFactory(beanFactory);

beanFactory创建和准备工作完成


// 调用在上下文中注册为 bean 的工厂处理器。
invokeBeanFactoryPostProcessors(beanFactory);

// Register bean processors that intercept bean creation.注册拦截bean的处理器。
registerBeanPostProcessors(beanFactory);

// Initialize message source for this context.初始化此上下文的消息源。
initMessageSource();

// Initialize event multicaster for this context.初始化事件派发器。
initApplicationEventMulticaster();

// Initialize other special beans in specific context subclasses.在特定上下文子类中初始化其他特殊 bean。
onRefresh();

// Check for listener beans and register them.检查侦听器 bean 并注册它们。
registerListeners();

// Instantiate all remaining (non-lazy-init) singletons.实例化所有剩余（非懒加载）单例。
finishBeanFactoryInitialization(beanFactory);

// Last step: publish corresponding event.最后一步：发布相应的事件。
finishRefresh();
```

IOC关注以下些方法的源码：
postProcessBeanFactory(beanFactory)：BeanFactory准备工作完成后进行的后置处理工作
invokeBeanFactoryPostProcessors(beanFactory);执行BeanFactoryPostProcessor的方法
registerBeanPostProcessors(beanFactory);注册BeanPostProcessor（Bean的后置处理器）
initMessageSource();初始化MessageSource组件，主要做国际化：消息解析，消息绑定
onRefresh();留给子容器（子类）子类重写在容器刷新的时候可以自定义。
finishBeanFactoryInitialization(beanFactory);初始化所有剩下的单实例bean
finishRefresh();完成BeanFactory的初始化创建工作；IOC容器就创建完成；



finashBeanFactoryInitialization(beanFactory)；给容器中将所有项目的单实例bean（非懒加载）初始化

 beanFactory.preInstantiateSingletons();单实例bean初始化

​	getMergedLocalBeanDefinition(beanName);获取bean的定义信息，依次进行创建和初始化

​	doGetBean(name,null,null,false);

​	Object shareInstance  = getSingleton(beanName);先获取我们map缓存中保存的实例bean,如果这个bean第二	次来拿，就直接从map中取到，其实就是从singletonObject map中获取

​	markBeanAsCreated(beanName)	;标记当前bean被创建。this.alreadyCreated.add(beanName)进行标记

​	mbd.getDependsOn();获取当前bean依赖的其他bean，如果存在，使用getbean从容器中拿出来

​	Object bean = resolveBeforreInstantiation(beanName,mbdToUse);让我们BeanPostProcessor尝试返回一个	代理对象

​	Object beanInstance = doCreateBean(beanName,mbdToUse,args):创建bean实例

​		populateBean(beanName,mbd,instanceWrapper);bean属性赋值

​			if (bp instanceof InstantiationAwareBeanPostProcessor) 后置处理器处理

​				postProcessAfterInstantiation：调用后置处理器方法对bean进行定制处理

​				applyPropertyValues(beanName,mbd,bw,pvs);设值

​		initializeBean(beanName, exposedObject, mbd);bean前后处理器执行地方，AOP动态代理增强入口





BeanFactory:getBean()方法有的话获取单例bean,没有的话创建单例bean,用到单例模式

FactoryBean:实现这个接口，返回对象bean并放到IOC容器中，用到工厂模式。

Advisor：增强器，用到适配器模式

AOP，ProxyFactory:动态代理模式

后置处理器：责任链模式





### IOC

IOC：控制反转，就是把原先我们代码里需要实现的对象的创建，依赖的代码，反转给容器帮忙实现

DI:依赖注入，就是指对象是被动接受依赖类而不是自己主动去找，换句话说就是指对象不是从容器中查找它依赖的类，而是在容器实例化对象的时候主动将它依赖的类注入给它。

在Spring中表示对象之间的关系通常使配置文件，有xml文件，有ymal文件等，统一这些配置文件的标准就是BeanDefinition

如何对不同的配置文件进行解析：策略模式，针对不同的形式有不同策略的BeanFactory实现类。

最顶层的接口是BeanFactory，用来保存各个对象之间的关系,创建容器。BeanFactory:从我们容器中获取实例化后的bean，主要的方法有getBean(),containsBean(),isSingleton()等

![](/home/lixing/文档/image/选区_001.png)

存储配置文件信息的接口BeanDefinition

![](/home/lixing/文档/image/选区_002.png)

解析配置文件的接口BeanDefinitionReader

![](/home/lixing/文档/image/选区_003.png)

IOC容器的初始化过程：定位，加载，注册

![](/home/lixing/文档/image/选区_006.png)



![02.Tom_VIP_20180414_Spring系统概述及IOC实现原理_课堂笔记](/home/lixing/文档/image/课堂笔记.png)









### DI

依赖注入关键类：延时加载，IOC时只是将容器启动的单例bean加入到了IOC容器。

IOC容器：BeanFactory，AbstractBeanFactory

初始化后获得BeanDefinition对象：SimpleInstantiationStrategy

依赖注入：AbstractPropertyAccessor

真正实例化获得：BeanWrapper



入口是BeanFactory中的getBean()

![选区_007](/home/lixing/文档/image/选区_007.png)





![03.Tom_VIP_20180415_Spring核心IOC容器及依赖注入原理_课堂笔记](/home/lixing/文档/image/03.Tom_VIP_20180415_Spring核心IOC容器及依赖注入原理_课堂笔记.png)

getBean取，使用BeanWrapper进行封装，在doGetBean时判断是不是单例，如果是单例，就从缓存中取，





BeanFactory和FactoryBean的区别：

FactoryBean是Spring内部实现的一种规范，由&开头作为beanName,Spring中的所有的容器都是FactoryBean.因为容器本身也由容器进行管理，root来创建，都是单例放在IOC容器中。是容器的实例。

BeanFactory： Bean工厂的顶层规范，只是定义了getBean()方法。是容器的规范。





# SpringMVC

## Servlet3.0与Spring Mvc那些事

 

<<<<<<< HEAD
1，以前来写web的三大组件：以前写servlet filter listener都需要在web.xml进行注册，包括springmvc的前端控制器DispactherServlet也需要在web.xml注册，现在可以通过注解的方式快速搭建我们的web应用

2，servlet3.0需要tomcat7以上版本进行支持

3，创建动态web工程（Dynamic Web Project），看一看原生版的servlet：
=======
### 1，以前来写web的三大组件：

以前写servlet filter listener都需要在web.xml进行注册，包括springmvc的前端控制器DispactherServlet也需要在web.xml注册，现在可以通过注解的方式快速搭建我们的web应用

### 2，servlet3.0需要tomcat7以上版本进行支持

### 3，创建动态web工程

Dynamic Web Project），看一看原生版的servlet：
>>>>>>> e94e0470f821402dab0842cf8d468a7fb47df8bd

  步骤如下

3.1创建工程：

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wps1hBUtn.jpg)  ![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsSHkyyY.jpg)

 

 3.2新建jsp页面

  ![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsGL4dDz.jpg)

 

 3.3打开页面，新增请求地址，请求地址为order

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsUDMVHa.jpg) 

 

3.4那么我们建立一个原生的servlet来处理 order的请求

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsOMTFML.jpg) 

加入tomcat，启动后测试访问地址，结果如下：

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsrbVrRm.jpg) 

可以访问到路径地址。

当然这些注解不是我们讲的重点，原生的servlet开发还是很少的。

  

<<<<<<< HEAD
4，Shared libraries（共享库） and runtimes pluggability（运行时插件）的原理,在后面的框架整合里，用得比较多，来分析下它；
=======
### 4，

Shared libraries（共享库） and runtimes pluggability（运行时插件）的原理,在后面的框架整合里，用得比较多，来分析下它；
>>>>>>> e94e0470f821402dab0842cf8d468a7fb47df8bd

 ServletContainerInitializer初始化web容器： 

在web容器启动时为提供给第三方组件机会做一些初始化的工作，例如注册servlet或者filters等，servlet规范(JSR356)中通过ServletContainerInitializer实现此功能。

每个框架要使用ServletContainerInitializer就必须在对应的jar包的 META-INF/services  目录创建一个名为javax.servlet.ServletContainerInitializer的文件，文件内容指定具体的ServletContainerInitializer实现类，那么，当web容器启动时就会运行这个初始化器做一些组件内的初始化工作。

 

 操作步骤： 

4.1创建META-INF/services目录

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsrKvgWX.jpg) 

4.2创建javax.servlet.ServletContainerInitializer文件

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpscnX60y.jpg) 

 

4.3,新建JamesServletContainerInitializer实现ServletContainerInitializer接口

  ![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsNPbZ59.jpg)

4.4编辑javax.servlet.ServletContainerInitializer文件内容

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsUtfTaL.jpg) 

 

4.5一般伴随着ServletContainerInitializer一起使用的还有HandlesTypes注解，通过HandlesTypes可以将感兴趣的一些类注入到ServletContainerInitializer的onStartup方法作为参数传入。

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsNQlPfm.jpg) 

并新建JamesService接口的所有子类型

  ![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsRWvNkX.jpg)

JamesService接口：

分别新建JamesServiceOther,JamesServiceImpl,AbstractJamesService

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsxYVMpy.jpg) 

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsPpVNu9.jpg) 

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wps5l7PzK.jpg) 

 

 

4.6启动tomcat测试，看打印日志，不难发现，都拿到了，可以根据需要来反射创建对象

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsDJ1TEl.jpg) 

这其实就是基于运行时插件的机制，启动并运行这个ServletContainerInitializer，在整合springmvc的时候会用到4.7使用ServletContext注册web组件（其实就是Servlet,Filter,Listener三大组件），

对于我们自己写的JamesServlet，我们可以使用@WebServlet注解来加入JamesServlet组件，

但若是我们要导入第三方阿里的连接池或filter，以前的web.xml方式就可通过配置加载就可以了，但现在我们使用ServletContext注入进来；

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsKSFb8R.jpg) 

操作步骤：新建以下三个组件

A，新建OrderFilter.java过滤器

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsujBvBo.jpg) 

B，新建OrderListener.java监听类

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpssAlR4U.jpg) 

 

C，新建OrderServlet.java类

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsMZ7eyr.jpg) 

D，使用ServletContext来注册以上三个组件

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsAHxE1X.jpg) 

 

注意：在运行的过程中，是不可以注册组件， 和IOC道理一样，出于安全考虑

<<<<<<< HEAD


1，利用以上机制来整合springmvc;创建一个新的maven工程,springmvc注解版
=======
 ### 5

5，利用以上机制来整合springmvc;创建一个新的maven工程,springmvc注解版
>>>>>>> e94e0470f821402dab0842cf8d468a7fb47df8bd

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsjjH6uu.jpg) ![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wps1JaAY0.jpg)

 

 

5.1，建立完工程后，pom.xml会报错，老铁们，怎么办？？？不要慌，哈哈看下面吧

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsSBj5rx.jpg) 

做个设置即可

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsDr5BV3.jpg) 

再右键工程名，update更新一下maven配置就不会有错啦 啦 ……

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsjrZapA.jpg) 

 

 

5.2，加入必要的jar包依赖

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wps0kzLS6.jpg) 

 

5.3，导入依赖包后，查看maven的一个spring-web.jar包

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsdJ9nmD.jpg) 

 

打开ServletContainerInitializer这个文件看看

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsa9C2P9.jpg) 

 

 

5.4打开SpringServletContainerInitializer源码类

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsWjGIjG.jpg) 

 

5.5打开WebApplicationInitializer源码看看组件及实现（ctrl+t）

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsifTqNc.jpg) 

 

子类AbstractContextLoaderInitializer作用：

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsIWTahJ.jpg) 

 

 

子类AbstractDispatcherServletInitializer的作用：从名字来看可知是DispatcherServlet初始化

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpspCgXKf.jpg) 

 

子类AbstractAnnotationConfigDispatcherServletInitializer：注解方式配置的dispatcherServlet初始化器

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wps9ibMeM.jpg) 

 

root根容器与servlet容器的区别在哪呢？父子容器

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wps3k8CIi.jpg) 

很明显，servlet的容器用来处理@Controller，视图解析，和web相关组件

而root根容器主要针对服务层，和数据源DAO层及事务控制相关处理（图源自spring官网）

https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/web.html#mvc-servlet-context-hierarchy

 

后面我们根据这些来配置操作一下。 

 

<<<<<<< HEAD
6，与springmvc的整合流程。
=======
### 6，与springmvc的整合流程。
>>>>>>> e94e0470f821402dab0842cf8d468a7fb47df8bd

操作步骤：

新建JamesWebInitializer继承AbstractAnnotationConfigDispatcherServletInitializer类

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpswuRwcP.jpg) 

 

新建两个配置类JamesRootConfig和JamesAppConfig，形成父子容器的效果

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsp2tsGl.jpg) 

 

再建JamesAppConfig类

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsqQTpaS.jpg) 

再建OrderController控制类来测试

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsFs5oEo.jpg) 

 

再建OrderService服务层类

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsAC4p8U.jpg) 

 

OrderController来调用一下service组件

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpslaVsCr.jpg) 

 

注意：JamesWebAppInitializer还需要指定配置类（配置文件）位置，修改以下返回

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsgPvx6X.jpg) 

 

重启tomcat，进行测试：

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsfYvEAu.jpg) 

这就使用注解的方式（配置类）来完成配置springmvc的整合

  

<<<<<<< HEAD
7，如何定制与接管springmvc
=======
### 7，如何定制与接管springmvc
>>>>>>> e94e0470f821402dab0842cf8d468a7fb47df8bd

以前是通过配置的方式来完成相应的处理

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpseNKN40.jpg) 

现在使用配置注解，定制我们的springmvc,可看官网描述，加入@EnableWebMvc,来定制配置功能。

我们直接在JamesAppConfig实现WebMvcConfigurer

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsR2hZyx.jpg) 

 

点击进去WebMvcConfigurer， ctrl+t发现WebMvcConfigurerAdapter实现了WebMvcConfigurer接口，但方法都为空，我们只要继承一下这个类即可

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpskHdf33.jpg) 

 

开始继承WebMvcConfigurerAdapter这个类（可以挑选部分方法进行重写）。

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsfYBxxA.jpg) 

 

我们得新建这些目录

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsoE8R16.jpg) 

 

在pages下新建一个名为 ok.jsp的页面

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsvtlewD.jpg) 

页面内容如下：

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsYl0B09.jpg) 

 

 

直接在OrderController控制类加一个解析器的定制页面返回

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wps9SS1uG.jpg) 

 

重启tomcat，测试一下，结果为如下：

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsG50tZc.jpg) 

 

 

 

 

 

静态资源如何配置访问呢？

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsP50XtJ.jpg) 

xml配置文件有个<mvc:default-servlet-handler/>，效果一样。

比如新增一张图片和一个JSP页面

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wps4aluYf.jpg) 

新增index.jsp修改一下：

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpszMh2sM.jpg) 

浏览器测试结果如下，能访问到页面

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsAQ1BXi.jpg) 

 

 

 

接下来我们玩一个稍微复杂点的，拦截器？

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wps1r4dsP.jpg) 

 

新建 JamesInterceptor拦截器，需实现HandlerInterceptor接口

之前在xml里有， <mvc:interceptors>,效果是一样的。

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsaC6SWl.jpg) 

 

把拦截器加到子容器配置类

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wps7ttArS.jpg) 

 

重启tomcat进行测试，输入网些访问ok方法

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsOlbkWo.jpg) 

同时eclipse打印内容如下，拦截成功。

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsNiI5qV.jpg) 

 

<<<<<<< HEAD


=======
### 8，servlet3.0异步请求分析

 

8.1，什么是同步处理，请求发出后，等待服务端响应

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsk9jHoI.jpg) 

8.2同步请求原理，从tomcat中获取连接线程进行处理，但tomcat的线程数有限，会造成线程资源的紧张。

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsuVqf4c.jpg) 

8.3同步机制操作步骤：

a,在servlet工程目录下，修改JamesServlet类，把当前处理的线程也打印出来

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsc5EOJH.jpg) 

 

重启tomcat，得到如下结果

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsw1fppc.jpg) 

从头到尾都是由同一个线程4进行处理的，同一线程处理

很明显，线程从头执行到尾，会造成资源占用不能释放

 

b,异步请求操作步骤：

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsWZC14G.jpg) 

从servlet3.0文档的9.6章节也可以看到，要声明的内容

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsC50FKb.jpg) 

 

重启tomcat,查看运行结果如下，主线程与副线程分别为不同的线程，主线程从开始到结束不等待副线程就返回了：

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpssTwlqG.jpg) 

页面返回结果如下：等待3S后才返回，但线程资源其实早已释放

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsIjc25a.jpg) 

 

 

c,异步请求原理

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsM9PJLF.jpg) 

 

当然怎么样定义servlet的异步处理线程池，不多讲，springmvc已集成了异步处理线程池

 

 

 

9，springmvc的异步请求

我们可以打官网

https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/web.html#mvc-servlet-context-hierarchy

第1.7.1章节，讲述得很清晰

springmvc异步机制是基于servlet3来做的封装处理，通过这两种返回值都可以完成异步

官网例子如下：

<img src="image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpssXgtra.jpg" alt="img"  />或![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsmQDd7E.jpg)

我们接下来实现一下：

操作步骤：

a,新建AsyncOrderController测试类 

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsiD9YM9.jpg) 

控制台打印结果如下：

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsqBSLsE.jpg) 

 

页面运行结果如下：

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsEINz88.jpg) 

 

Callable的原理是什么呢？还是一样，请打开官网哈…………第1.7.1章节

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsqQKoOD.jpg) 

 

思考：控制台打印结果为什么会两次进入拦截器preHandle呢？

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsKqSeu8.jpg) 

很明显可知：请求进入时拦截了一次，将Callable返回结果时，将请求重新派发给容器时又拦截了一次，所以进了两次拦截；

 

如何验证？只要在拦截器打印的地方加上getRequestURI()便知晓。

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsU9f69C.jpg) 

 

重启tomcat，并测试结果如下：分析见箭头的中文描述：

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsCfJYP7.jpg) 

 

### 10，springmvc异步请求及返回实战

 

以上只是原理，但在开发的过程并不是像Callable简单

比如现在我们有以下需求：

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wps0FLSvC.jpg) 

需求描述：以创建订单为例，tomcat启动线程1来完成一个请求，但实际上是订单服务才能创建订单，那么tomcat线程应该把请求转发给订单服务，使用消息中间件来处理，订单服务把处理结果也放到消息中间件，由tomcat的线程N拿到结果后，响应给客户端。

 

我们打开官网第1.7.1章节

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsiBVNb7.jpg) 

 

操作步骤：

很明显我们不会用到MQ等消息中间件，写一个队列为模拟消息中间件

a,新建JamesDefferdQueue消息队列类

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsc6pKRB.jpg) 

 

 

b,在AsyncOrderController新增两方法（其实就是两个线程，线程1和线程N）

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wps0EjIx6.jpg) 

 

测试结果为：

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsOwNHdB.jpg) 

![img](image/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wps0drIT5.jpg) 

通过create (tomcat线程N处理的订单结果)，异步返回给createOrder(tomcat线程1),两结果一致，异步返回了结果。

 

  

>>>>>>> e94e0470f821402dab0842cf8d468a7fb47df8bd


## 手写SpringMVC实现

![](/home/lixing/文档/image/选区_330.png)



Spring中的Bean是线程安全的吗？

答：Spring中的bean是在容器启动时，初始化通过扫描和反射技术创建的，并且会缓存到ioc容器中，Spring本身没有对bean做任何处理，Bean是不是线程安全的，取决于bean的本身，bean本身是我们自己写的代码。

Spring中的bean是如何回收的？

Spring中bean的回收取决于生命周期，有singleton,prototype,session,request,如果是单例singleton，就一直存在直到容器关闭，如果是多例，每次创建完就没有了，如果是session，会话结束就没有了，如果是request，请求结束就没有了。

![选区_008](/home/lixing/文档/image/选区_008.png)

SpringMVC九大组件：

1.HandlerMappings

2.HandlerAdapters：参数适配器

3.HandlerExceptionResolvers：异常拦截器

4.ViewResolvers：视图转换器

5.RequestToViewNameTranslator：视图预处理器

6.LocaleRresolver：本地语言环境

7.ThemeResolver：模板处理器

8.MultipartResolver：多文件上传组件

9.FlashMapManger：



Handler就是做事的，就是一个标注了RequestMaping的方法，HandlerMappings就是将url和具体的方法相对应。

![选区_009](/home/lixing/文档/image/选区_009.png)



Controller如果能保持单例，尽量使用单例。

@RequestParm给具体的参数和url中的参数一一对应，尽量使用，否是有损性能。

Spring MVC没有对url和Method的对应关系进行缓存，建议自己对url和Method的关系进行缓存。







# 享学手写SpringMVC



手写SpringMVC笔记

 

1,新建项目

 

 

![img](image/2.Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsn0jPBU.jpg) ![img](image/2.Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsGs9NL5.jpg)

 

![img](image/2.Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wps501NVg.jpg) ![img](image/2.Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wps2eYO5r.jpg)

此时工程创建完毕.

 

2,新建注解及控制类,服务类及DispatcherServlet类(见源码)

![img](image/2.Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsTW3QfD.jpg) 

内容分别如下:

![img](image/2.Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpskveUpO.jpg) 

 

![img](image/2.Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsxepYzZ.jpg) 

 

![img](image/2.Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsmrE3Ja.jpg) 

![img](image/2.Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsJaX9Tl.jpg) 

 

![img](image/2.Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wps6Xbh4w.jpg) 

声明注解到控制层(此时注解待解析)

![img](image/2.Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsNmypeI.jpg) 

声明service服务类注解EnjoyServiceImpl

![img](image/2.Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsC25yoT.jpg) 

接口类如下

![img](image/2.Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wps1iQJy4.jpg) 

 

创建一个新的DispatherServlet类,用来初始化bean和拦截请求

![img](image/2.Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsWDHVIf.jpg) 

![img](image/2.Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsJ1p8Sq.jpg) 

它的子方法请下载云盘里的源码跟进查看,每一行代码都写了注解.

 

 

3,将DispatcherServlet配置到web.xml(在项目启动时会加载这个DispatcherServlet的init方法)

![img](image/2.Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wps4rwm3B.jpg) 

 

4,DispatcherServlet的doPost方法里对请求路径进行拦截,并根据路径到找对应要执行的方法

![img](image/2.Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsrk2BdN.jpg) 

![img](image/2.Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/wpsafISnY.jpg) 

使用处理器解析后的参数放到args数组, 直接使用method.invoke(instance, args)完成请求调用;

内容较大,文字不好描述, 关于处理器这块,请看视频.

 

 

 

 

 

 

 

 

 

 

