6+2:JVM，多线程与高并发，zookeep，设计模式，mysql，缓存redis。+高并发项目+分布式项目

# Java多线程编程核心技术

## 1.Java多线程技能

### 创建线程的三种方式

```java
package Thread_Xiangxue;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

public class GenerateThread {

    public static class T1 implements Runnable{

        @Override
        public void run() {//无返回值
            System.out.println("实现了Runable接口");
        }
    }
    public static class T2 implements Callable<String>{

        @Override
        public String call() throws Exception {//有返回值的
            System.out.println("实现了Callable接口");
            return "这是返回值";
        }
    }

    public static class T3 extends Thread{
        @Override
        public void run(){
            super.run();
            System.out.println("继承自Thread");
        }
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {

        T1 t1 = new T1();
        new Thread(t1).start();

        T2 t2 = new T2();
        FutureTask<String> futureTask = new FutureTask<>(t2);
        new Thread(futureTask).start();
        System.out.println(futureTask.get());//打印返回值

        T3 t3 = new T3();
        t3.start();
    }
}

```











## 2.对象及变量的并发访问

### synchronized同步方法

- 方法内变量为线程安全
- 两个线程同时访问一个没有同步的方法，如果两个线程同时操作业务对象中的实例变量，则会出现非线程安全的问题。只需要在方法前加上synchronized即可。
- 关键字synchronized取得的锁是**对象锁**，而不是把一段代码或方法上锁。哪个线程先执行到有synchronized的方法，哪个线程就持有该方法所属对象的锁。
- 只有共享的资源的读写访问才需要同步化，如果不是共享资源就不需要同步
- A线程先持有object对象的Lock锁，B线程可以以异步的方式调用Object对象的非synchronized类型方法，但是不可以调用object的synchronized方法。
- synchronized锁重入：当一个线程得到一个对象锁后，再次请求此对象锁时可以再次得到该对象的锁，也就是在一个synchronized方法内部调用本类的其他synchronized方法时，是永远可以得到锁的。
- 可重入锁同样支持在父子类的继承环境中。
- 出现异常，锁自动释放
- 同步不具有继承性，子类继承父类，父类中的同步方法在子类重写，也需要加上synchronized.
- 用同步代码块解决同步方法的弊端：使用synchronized(this),不在synchronized块中的就是异步执行，在synchronized块中的就是同步执行。
- synchronized代码块之间是有同步性的。当一个线程访问一个synchronized代码块时，其他线程不能够访问这个对象的其他synchronized代码块。
- synchronized同步方法：对其他synchronized同步方法或synchronized(this)同步代码块调用呈阻塞状态，同一时间只有一个线程可以执行synchronized同步方法中的代码。
- synchronized(this)同步代码块：对其他synchronized同步方法或synchronized(this)同步代码块调用呈阻塞状态，同一时间只有一个线程可以执行synchronized(this)代码块的代码。
- synchronized(非this对象x)代码块中的程序与同步方法是异步的，不与其他锁this同步方法争抢this锁，避免阻塞，注意synchronized(非this对象)与synchronized方法是异步调用的效果，因为对象监视器不同。
- **synchronized还可以应用在static静态方法上，这时是对该java文件对应的Class类进行加锁。**虚拟机保证了每个类的class对象有且只有一个。synchronized加在非staitc方法上是给对象上锁。而对象可以new出来很多个，只有锁的同一个对象才起作用，在spring中默认只有一个对象。如果一个static方法一个非static方法都加了synchronized，他两个是异步的，因为持有不同的锁。Class锁可以对类的所有对象实例起作用。
- 同步synchronized(Class.class)代码块和synchronized static方法的作用一致。
- 通常不使用string常量作为synchronized代码块的锁对象，因为如果string常量一样的话，两个线程就持有相同的锁了。通常使用new Object()
- 用string常量作为锁对象，如果方法一改变了该常量值，之后的方法调用时就是异步调用了。使用对象，只有对象不变，即使属性变化，运行结果还是同步。



### Volatile

- 关键字volatile的作用是强制从公共堆栈中取得变量的值，而不是从线程私有数据栈中取得变量的值。
- 使用volatile关键字增加了实例变量在多个线程之间的可见性，**但volatile关键字不支持原子性**。
- volatile是线程同步的轻量级实现，性能比synchronized要好，volatile只能修饰变量，而synchronized可以修饰方法以及代码块。
- 多线程访问volatile不会发生阻塞，而synchronized会出现阻塞。
- volatile能保证数据的可见性，但不能保证原子性；而synchronized可以保证原子性，也可以间接保证可见性，因为它会将私有内存和公共内存中的数据做同步。
- volatile解决的是变量在多个线程之间的可见性，而synchronized解决的是多线程之间访问资源的同步性。
- volatile的使用场合是在多个线程中可以感知实例变量被更改了，并且可以获得最新值的引用。但是不能保证原子性，如i++操作就不是一个原子操作，也就是非线程安全的。对于多个线程访问同一个实例变量还是需要同步加锁的。
- 关键字synchronized有volatile同步的功能，它包含两个特征：互斥性和可见性。
- volatile使用场景：只有一个线程写，多个线程读
- 



## 3.线程间的通信

### 等待/通知机制

- wait()的作用是将当前执行的线程进行等待，将当前线程置于预执行队列中。只有在同步方法或者同步块中才可以调用wait()方法。**在执行wait()后，当前线程释放锁**。
- wait()通常放在while循环时，不满足条件就wait(),当被唤醒时也要判断条件是否满足，满足了才会继续执行，负责继续循环然后wait()。
- notify()也要在同步方法或者同步块中调用，即线程需要获得该对象的对象级别锁。如果有多个线程在等待，则由线程规划器随机挑选一个wait状态的线程，对其发出notify。
- wait使线程停止运行，notify使停止的线程继续运行**，notify方法执行后并不立即释放锁**。
- notifyAll方法可以使所有正在等待队列中等待同一共享资源的全部线程从等待状态退出，进入可运行状态。
- 每个锁对象都有两个队列，一个是就绪队列，一个是阻塞队列。
- **当方法wait被执行后，锁被自动释放，但执行完notify方法后，锁不会自动释放。必须执行完notify()方法所在的同步synchromized代码块后才会释放锁**。
- 当线程呈wait状态时，调用线程对象的interrupt方法会出现InterruptedException异常
- wait(long)方法的功能是等待某一时间内是否有线程对锁进行唤醒，如果超过这个时间则自动唤醒。
- 生产者与消费者操作值的实现：多个生产者和多个消费者存在时会出现假死现象，因为有可能生产者唤醒的是生产者，消费者唤醒的是消费者，这样所有的线程都是waiting状态了。是因为连续唤醒了同类导致的。解决方法是使用notifyAll将异类也唤醒。
- 应该尽量使用notifyAll，notify()有可能出现信号丢失的情况。
- 生产者与消费者操作栈的实现
- 使用管道作为线程间的通信：一个线程发送数据到输出管道，两一个线程从输入管道中读取数据。在JDK中有4个类来使线程间可以通信：字节流：PipedInputStream,PipedOutputStream,字符流：PipedReader,PipedWriter
- 等待超时模式实现一个连接池。在同步方法内，判断传入的等待时间t，如果t<0则当连接池为空的时候一直等待，直到取到为止。如果t>0,则计算出需要等待的时间，当连接池为空且等待时间还剩余的话就一直等待，否则有一个条件不满足就试图取一下，然后结束这个线程。
- wait,notify,notifyAll都是Object类中的方法。

<<<<<<< HEAD
>
>
>### sleep()、join（）、yield（）有什么区别？
>
>#### sleep()
>
>sleep() 方法需要指定等待的时间，它可以让当前正在执行的线程在指定的时间内暂停执行，进入阻塞状态，该方法既可以让其他同优先级或者高优先级的线程得到执行的机会，也可以让低优先级的线程得到执行机会。但是 sleep() 方法不会释放“锁标志”，也就是说如果有 synchronized 同步块，其他线程仍然不能访问共享数据。
>
>#### wait()
>
>wait() 方法需要和 notify() 及 notifyAll() 两个方法一起介绍，这三个方法用于协调多个线程对共享数据的存取，所以必须在 synchronized 语句块内使用，也就是说，调用 wait()，notify() 和 notifyAll() 的任务在调用这些方法前必须拥有对象的锁。
>
>注意，它们都是 Object 类的方法，而不是 Thread 类的方法。
>
>wait() 方法与 sleep() 方法的不同之处在于，wait() 方法会释放对象的“锁标志”。当调用某一对象的 wait() 方法后，会使当前线程暂停执行，并将当前线程放入对象等待池中，直到调用了 notify() 方法后，将从对象等待池中移出任意一个线程并放入锁标志等待池中，只有锁标志等待池中的线程可以获取锁标志，它们随时准备争夺锁的拥有权。当调用了某个对象的 notifyAll() 方法，会将对象等待池中的所有线程都移动到该对象的锁标志等待池。
>
>除了使用 notify() 和 notifyAll() 方法，还可以使用带毫秒参数的 wait(long timeout) 方法，效果是在延迟 timeout 毫秒后，被暂停的线程将被恢复到锁标志等待池。
>
>此外，wait()，notify() 及 notifyAll() 只能在 synchronized 语句中使用，但是如果使用的是 ReenTrantLock 实现同步，该如何达到这三个方法的效果呢？解决方法是使用 ReenTrantLock.newCondition() 获取一个 Condition 类对象，然后 Condition 的 await()，signal() 以及 signalAll() 分别对应上面的三个方法。
>
>#### yield()
>
>yield() 方法和 sleep() 方法类似，也不会释放“锁标志”，区别在于，它没有参数，即 yield() 方法只是使当前线程重新回到可执行状态，所以执行 yield() 的线程有可能在进入到可执行状态后马上又被执行，另外 yield() 方法只能使同优先级或者高优先级的线程得到执行机会，这也和 sleep() 方法不同。
>
>#### join()
>
>join() 方法会使当前线程等待调用 join() 方法的线程结束后才能继续执行sleep()与wait()方法都不占用cpu时间及利用率
>
>sleep()与wait()方法都不占用cpu时间及利用率

>=======

### 方法join

- join的作用就是等待线程对象销毁，如主线程等到子线程结束。使所属的线程对象x正常执行run()方法中的任务，而使当前线程z进行无限期的阻塞，等待线程x销毁后再继续执行线程z后面的代码。
- join在内部使用wait方法进行等待，而synchronized关键字使用的是对象监视器原理作为同步。
- 在join中，如果当前线程对象被中断，则当前线程出现异常。
- 方法join(long)中的参数是设定等待时间
- 方法join(long)与sleep(long)的区别：join(long)的功能是内部使用wait(long)方法来实现的，所以具有释放锁的特点。而Thread.sleep方法却不释放锁。
- 一般是join先抢到锁
- 可以把join想象成插队，可以将很多线程串行起来

- yield和sleep方法是不会释放锁的。他们的区别是sleep方法休眠了，cpu不会再选择它执行了，而yield方法还有可能被选中执行。
- wait()和notify方法调用之前都要持有锁，但是wait调用后锁立即释放，但是notify不会立即释放。



### 类ThreadLocal的使用

- 变量值共享使用public static的形式，所有线程公用一个变量。如果想实现每一个线程都有自己的共享变量就要用ThreadLocal来解决。
- ThreadLocal主要解决每个线程绑定自己的值。
- 使用InheritableThreadLocal可以在子线程中取得父线程继承下来的值。
- 使用map实现
- 在连接池中使用



## 4.Lock

### 使用ReentrantLock类

- 使用ReetrantLock对象的lock()方法获取锁，调用unlock()方法释放锁。
- try中加入lock.lock(),在finally中lock.unlock();效果和使用synchronized一样
- **ReentrantLock使用Condition可以实现等待/通知功能。**
- notify/notifyAll方法进行通知时，被通知的线程是由JVM随机选择的，但是ReetrantLock结合Condition类是可以实现选择性通知的。
- 必须在condition.await()方法调用前调用lock.lock()获得同步监视器。同理在condition.signal()方法前也需要lock.lock()。
- **使用多个condition对象可以实现唤醒部分线程。就是condition对象可以唤醒部分指定线程。**
- 在wait中为了防止信号丢失，都是使用notifyAll进行唤醒，但是await中，通常使用signal而不是signalAll进行唤醒。这是因为在wait和notify是在某个实体类上进行等待的，这个实体类有若干量影响它变化，任何一个变化时都需要通知。在await中使用了多个condition，每个condition的signal方法和await方法是一一对应的，所以可以指定唤醒某一个。
- 公平锁：先来先得FIFO，非公平锁：抢占机制
- 方法getHoldCount():查询当前线程保持此锁定的个数，也就是调用lock()方法的个数 
- getQueueLength()：返回正等待获取此锁定的线程的估计数



# 并发编程的艺术

- 上下文切换：任务从保存到再加载的过程就是一次上下文切换
- 减少上下文切换的方法：无锁并发编程，CAS算法，使用最少线程和使用协程
  - 无锁并发编程：多线程竞争锁时会引起上下文切换，避免使用锁。
  - CAS算法：Java的Atomic包使用CAS算法来更新数据，不需要加锁
  - 使用最少线程
  - 协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换
- 使用jstack命令dump查看线程的信息
- 避免死锁的方法：
  - 避免一个线程同时获取多个锁
  - 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源
  - 尝试使用定时锁，使用lock.tryLock(time)来代替使用内部锁机制
  - 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况
- 如果volatile变量修饰符使用恰当的话，它比synchronized的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。
- volatile是如何保证可见性的，有volatile修饰的共享变量：
  - Lock前缀指令会将当前处理器缓存行中的数据写回到系统内存，并使用缓存一致性机制来确保修改的原子性，此操作被称为“缓存锁定”，缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据。
  - 使其他CPU里缓存了该内存地址的数据无效，器使用MESI（修改、独占、共享、无效）控制协议去维护内部缓存和其他处理器缓存的一致性。处理器使用嗅探技术保证它的内部缓存、系统内存和其他处理器的缓存的数据在总线上保持一致。

- 在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态。

- volatile的优化：

  - 追加字节，LinkedTransferQueue类，它使用一个内部类类型来定义队列的头节点（head）和尾节点（tail），而这个内部类只做了一件事情，就是将共享变量追加到64字节。使用追加到64字节的方式来填满高速缓冲区的缓存行，避免头节点和尾节点加载到同一个缓存行，使头、尾节点在修改时不会互相锁定。

- synchronized的实现原理：

  - java中的每个对象都可以作为锁：
    - 对于普通的同步方法，锁是当前实例对象
    - 对于静态同步方法，锁是当前类的Class对象
    - 对于同步方法块，锁是Synchonized括号里配置的对象。
  - JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，任何对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态。
  - Java对象头里的Mark Word里默认存储对象的HashCode、分代年龄和锁标记位

  

  锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，锁可以升级但不能降级，目的是为了提高获得锁和释放锁的效率

- 偏向锁：当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁，。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。

  - 偏向锁的撤销：偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。

![](/home/lixing/文档/image/选区_287.png)



- 轻量级锁：

  - 轻量级加锁：线程在执行同步块之前，JVM会先在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。

  - 轻量级解锁：轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁

    ![](image/1.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/%E9%80%89%E5%8C%BA_288.png)

- 锁的优缺点对比

  | 锁       | 优点                                                         | 缺点                                           | 适用场景                             |
  | -------- | :----------------------------------------------------------- | ---------------------------------------------- | ------------------------------------ |
  | 偏向锁   | 加锁解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级差距 | 如果线程间存在锁竞争，会带来额外的锁撤销的消耗 | 适用于只有一个线程访问同步块场景     |
| 轻量级锁 | 竞争的线程不会阻塞，提高了程序的响应速度(因为进行CAS不需要上下文的切换) | 如果始终得不到锁竞争的线程，就会自旋会消耗CPU  | 追求响应时间，同步块执行速度非常快。 |
  | 重量级锁 | 线程竞争不使用自旋，不会消耗CPU                              | 线程阻塞，响应时间缓慢                         | 追求吞吐量，同步块执行时间较长       |
- CAS:比较并交换(Compare and swap),先输入两个值，一个旧值一个新值，先比较旧值有没有发生变化，如果没有发生变化才交换成新值。

- 假共享：多个CPU同时修改同一个缓存行的不同部分而引起的其中一个CPU的操作无效。

- 处理器如何实现原子操作：使用总线锁保证原子性，使用缓存锁保证原性。当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行时，则处理器会调用总线锁定。

- java如何实现原子操作：在java中通过锁和循环CAS方式来实现

  - 使用循环CAS实现原子操作：循环进行CAS操作直到成功为止
  - 使用锁机制实现原子操作，锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。

- CAS三大问题：

  - ABA问题：但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号
  - 循环时间长开销大。
  - 只能保证一个共享变量的原子操作。因为一个内存地址只能保存一个变量。可以使用一个类封装。

## 3.java内存模型

### java内存模型的基础

- 线程之间通信的方式：共享内存和消息传递
- java的并发采用的是共享内存模型，java线程之间的通信总是隐式进行，整个通信过程对程序员是透明的。
- JMM(java内存模型)定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。主内存应该指的是方法区。JMM通过控制主内存与每个线程的本地内存之间的交互，来为Java程序员提供内存可见性保证。



### 指令重排序

- 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
- 指令级并行的重排序。将多条指令重叠执行。
- 内存系统的重排序。

JMM的编译器重排序规则会禁止特定类型的编译器重排序，对于处理器重排序，JMM的处理器重排序规则会要求java编译器在生成指令序列时，插入特定类型的内存屏障指令来禁止特定类型的处理器重排序。

如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。

重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。

- 如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。
- 编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序
- 不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。



### 顺序一致性内存模型：

- 一个线程中的所有操作必须按照程序的顺序来执行
- 不管程序是否同步，所有线程都只能看到一个单一的操作执行顺序，在顺序一致内存 模型中，每个操作都必须原子执行且立刻对所有线程可见。

但是，在JMM中就没有这个保证。未同步程序在JMM中不但整体的执行顺序是无序的，而且所有线程看到的操作执行顺序也可能不一致。但是正确同步的JMM中，能够保证线程之间的顺序，但是单个线程内还是可以重排序的，但是却不影响结果。这就JMM在具体实现上的基本方针：在不改变正确同步的程序执行结果的前提下，尽可能地优化编译器和处理器。

顺序一致性内存模型和java内存模型的区别：

- 顺序一致性模型保证单线程内的操作会按程序的顺序执行，而JMM不保证单线程内的操作会按程序的顺序执行
- 顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而JMM不保证所有线程能看到一致的操作执行顺序。
- JMM不保证对64位的long型和double型变量的写操作具有原子性，而顺序一致性模型保证对所有的内存读/写操作都具有原子性。在32位处理器上，可能会把一个64位long/double型变量的写操作拆分为两个32位的写操作来执行。

每次处理器和内存之间的数据传递都是通过一系列步骤来完成的，这一系列步骤称之为总线事务（Bus Transaction）。总线事务包括读事务（Read Transaction）和写事务（Write Transaction）。

总线会同步试图并发使用总线的事务。在一个处理器执行总线事务期间，总线会禁止其他的处理器和I/O设备执行内存的读/写。在任意时间点，最多只能有一个处理器可以访问内存。这个特性确保了单个总线事务之中的内存读/写操作具有原子性。

### volatile的特性：

锁的happens-before规则保证释放锁和获取锁的两个线程之间的内存可见性，这意味着对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。

即使是64位的long型和double型变量，只要它是volatile变量，对该变量的读/写就具有原子性。如果是多个volatile操作或类似于volatile++这种复合操作，这些操作整体上不具有原子性。

volatile变量自身具有下列特性：

- 可见性，对一个volatile变量的读，总是能看到任意线程对volatile变量最后的写入
- 原子性，对任意单个volatile变量的读写具有原子性，但像volatile++这样的复合操作不具有原子性。

从内存语义的角度来说，volatile的写-读与锁的释放-获取有相同的内存效果：volatile写和锁的释放有相同的内存语义；volatile读与锁的获取有相同的内存语义

volatile写的内存语义：当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。锁释放的时候也是将本地内存中的数据刷新到主内存中。

volatile写的内存语义：当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。

volatile读的内存语义：当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程将从主内存中读取共享变量。

线程A写一个volatile变量，随后线程B读这个volatile变量，这个过程实质上是线程A通过主内存向线程B发送消息

JMM会限制编译器重排序和处理器重排序，

- 在每个volatile写操作的前面插入一个StoreStore屏障。避免与上面的普通写重排序。
- 在每个volatile写操作的后面插入一个StoreLoad屏障。避免与下面的volatile读操作重排序。
- 在每个volatile读操作的后面插入一个LoadLoad屏障。避免与下面的普通读操作重排序。
- 在每个volatile读操作的后面插入一个LoadStore屏障。避免与下面的普通写操作重排序。

由于volatile仅仅保证对单个volatile变量的读/写具有原子性，而锁的互斥执行的特性可以确保对整个临界区代码的执行具有原子性。在功能上，锁比volatile更强大；在可伸缩性和执行性能上，volatile更有优势。

### 锁的内存语义

锁除了让临界区互斥执行外，还可以让释放锁的线程向获取同一个锁的线程发送消息。

锁的释放内存语义：当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存上。

锁的获取内存语义：当线程获取锁时，JMM会把该线程对应的本地内存置为无效。从而使得被监视器保护的临界区代码必须从主内存中读取共享变量

线程A释放锁，随后线程B获取这个锁，这个过程实质上是线程A通过主内存向线程B发送消息。

根据volatile的happens-before规则，释放锁的线程在写volatile变量之前可见的共享变量，在获取锁的线程读取同一个volatile变量后将立即变得对获取锁的线程可见。

CAS:如果当前状态值等于预期值，则以原子方式将同步状态设置为给定的更新值。此操作具有volatile读和写的内存语义。编译器不会对volatile读与volatile读后面的任意内存操作重排序；编译器不会对volatile写与volatile写前面的任意内存操作重排序，所有编译器不能对CAS与CAS前面和后面的任意内存操作重排序。

锁释放-获取的内存语义的实现至少有下面两种方式。

- 1）利用volatile变量的写-读所具有的内存语义。
- 2）利用CAS所附带的volatile读和volatile写的内存语义

由于Java的CAS同时具有volatile读和volatile写的内存语义，因此Java线程之间的通信现在有了下面4种方式。
1）A线程写volatile变量，随后B线程读这个volatile变量。
2）A线程写volatile变量，随后B线程用CAS更新这个volatile变量。
3）A线程用CAS更新一个volatile变量，随后B线程用CAS更新这个volatile变量。
4）A线程用CAS更新一个volatile变量，随后B线程读这个volatile变量。

### concurrent包的实现

通用化的实现模式：

首先，声明共享变量为volatile。然后，使用CAS的原子条件更新来实现线程之间的同步。同时，配合以volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信。

![](/home/lixing/文档/image/选区_289.png)



### final域的内存语义

对于final域，编译器和处理器要遵守两个重排序规则

- 在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。
- 初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序

写final域的重排序规则可以确保：在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域不具有这个保障。

读final域的重排序规则可以确保：在读一个对象的final域之前，一定会先读包含这个final域的对象的引用。

为什么final引用不能从构造函数内逸出，：在构造函数内部，不能让这个被构造对象的引用为其他线程所见，也就是对象引用不能在构造函数中“逸出”。

为什么final引用不能从构造函数内逸出，：在构造函数内部，不能让这个被构造对象的引用为其他线程所见，也就是对
象引用不能在构造函数中“逸出”。



### happens-before

（程序员，你应该知道你的处理器背着你做了什么）

happens-before是JMM中最核心的概念，通俗的将就是一个操作在另一个操作之前执行，如 A happens-before B。这两个操作可以在同一个线程内，也可以在不同的线程内。happens-before对程序员承诺A的执行结果对B可见，但是它对编译器和处理器的约束却是只要不改变运行结果，怎么优化都可以。

happens-before关系本质上和as-if-serial语义是一回事。

- as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证正确同步的多线程程序的执行结果不被改变
- as-if-serial语义给编写单线程程序的程序员创造了一个幻境：单线程程序是按程序的顺序来执行的。happens-before关系给编写正确同步的多线程程序的程序员创造了一个幻境：正确同步的多线程程序是按happens-before指定的顺序来执行的。



### 双重检查锁定与延迟初始化

双重检查锁定（Double checked locking）是常见的延迟初始化的技术

```java
public class DoubleCheckedLocking{
    private static Instance instance;
    public static Instance getInstance(){
        if(instance == null){//第一次检查
            synchronized(DoubleCheckedLocking.class){//加锁
                if(instance == null){//第二次检查
                    instance = new Instance();//这里会出问题
                }
            }
        }
        return instance;
    }
}
```

如上面代码所示，如果第一次检查instance不为null，那么就不需要执行下面的加锁和初始化操作。因此，可以大幅降低synchronized带来的性能开销。

看似完美的优化，却是错误的，当线程执行到第一次检查时，发现instance不为null,但此时instance引用的对象有可能还没有完成初始化。因为new一个对象可以被分为三步：

- 分配对象的内存空间
- 初始化对象
- 设置Instance指向刚分配的内存地址

在第二步和第三步之间有可能出现重排序，

![](/home/lixing/文档/image/选区_290.png)

如果发生重排序，另一个并发执行的线程B就有可能在第4行判断instance不为null。线程B接下来将访问instance所引用的对象，但此时这个对象可能还没有被A线程初始化.

解决方法：

- 不允许图中2和3重排序：使用volatile修饰instance.

- 允许2和3重排序，但不允许其他线程看到这个重排序：基于类初始化的解决方案，在执行类的初始化期间，JVM会获取一个锁，这个锁可以同步多个线程对同一个类的初始化。

  ```java
  public class InstanceFactory{
      private static class InstanceHolder{
          public static Instance instance = new Instance();
      }
      public static Instance getInstance(){
          return InstanceHolder.instance;//执行类的静态初始化和初始化类中声明的静态字段
      }
  }
  ```

  线程A和线程B同时执行到InstanceHolder.instance，线程A抢到了锁，进行InstanceHolder类的初始化，B则等待。初始化时将state置为已经初始化，并且初始化类中声明的静态变量instance，然后释放锁，B抢到锁，发现state的状态已经被初始化了，然后释放锁并结束。线程C获取初始化锁，发现被初始化过了，然后释放锁并结束。

  

  ![](/home/lixing/文档/image/选区_291.png)

首次执行getInstance()方法的线程将导致InstanceHolder类被初始化。

java初始化一个类或接口的处理过程如下：

- 通过在Class对象上同步（即获取Class对象的初始化锁），来控制类或接口的初始化。这个获取锁的线程会一直等待，直到当前线程能够获取到这个初始化锁。
- 线程A执行类的初始化，同时线程B在初始化锁对应的condition上等待。
- 线程A设置state = Initialized，然后唤醒在condition中等待的所有线程。
- 线程B结束类的初始化处理
- 线程C执行类的初始化处理。

通过对比基于volatile的双重检查锁定的方案和基于类初始化的方案，我们会发现基于类初始化的方案的实现代码更简洁。但基于volatile的双重检查锁定的方案有一个额外的优势：除了可以对静态字段实现延迟初始化外，还可以对实例字段实现延迟初始化.

在大多数时候，正常的初始化要优于延迟初始化。如果确实需要对实例字段使用线程安全的延迟初始化，请使用上面介绍的基于volatile的延迟初始化的方案；如果确实需要对静态字段使用线程安全的延迟初始化，请使用上面介绍的基于类初始化的方案。

处理器内存模型<语言内存模型（JMM）<顺序一致性内存模型

