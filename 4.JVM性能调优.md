 JMM和底层实现原理 

#  并发编程领域的关键问题 

![20200322_e36c2c](image/4JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/20200322_e36c2c.png)

#  现代计算机物理上的内存模型 

Jmm遇到的问题与现代计算机中遇到的问题是差不多的。

物理计算机中的并发问题，物理机遇到的并发问题与虚拟机中的情况有不少相似之处，物理机对并发的处理方案对于虚拟机的实现也有相当大的参考意义。

其中一个重要的复杂性来源是绝大多数的运算任务都不可能只靠处理器“计算”就能完成，处理器至少要与内存交互，如读取运算数据、存储运算结果等，这个I/O操作是很难消除的（无法仅靠寄存器来完成所有运算任务）。早期计算机中cpu和内存的速度是差不多的，但在现代计算机中，cpu的指令速度远超内存的存取速度,由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。

基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也为计算机系统带来更高的复杂度，因为它引入了一个新的问题：缓存一致性（Cache Coherence）。在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存（MainMemory）。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致，举例说明变量在多个CPU之间的共享。如果真的发生这种情况，那同步回到主内存时以谁的缓存数据为准呢？为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI、MESI（Illinois Protocol）、MOSI、Synapse、Firefly及Dragon Protocol等。

现代的处理器使用写缓冲区临时保存向内存写入的数据。写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。同时，通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，减少对内存总线的占用。虽然写缓冲区有这么多好处，但每个处理器上的写缓冲区，仅仅对它所在的处理器可见。这个特性会对内存操作的执行顺序产生重要的影响：处理器对内存的读/写操作的执行顺序，不一定与内存实际发生的读/写操作顺序一致！

处理器A和处理器B按程序的顺序并行执行内存访问，最终可能得到x=y=0的结果。

处理器A和处理器B可以同时把共享变量写入自己的写缓冲区（A1，B1），然后从内存中读取另一个共享变量（A2，B2），最后才把自己写缓存区中保存的脏数据刷新到内存中（A3，B3）。当以这种时序执行时，程序就可以得到x=y=0的结果。
从内存操作实际发生的顺序来看，直到处理器A执行A3来刷新自己的写缓存区，写操作A1才算真正执行了。虽然处理器A执行内存操作的顺序为：A1→A2，但内存操作实际发生的顺序却是A2→A1。

 ![20200322_1759b8](image/4JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/20200322_1759b8.png)

 

#  Java内存模型（JMM） 

即Java Memory Model，简称JMM。JMM定义了Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式。JVM是整个计算机虚拟模型，所以JMM是隶属于JVM的。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。

#  JVM对Java内存模型的实现 

所有原始类型(boolean,byte,short,char,int,long,float,double)的局部变量都直接保存在线程栈当中，对于它们的值各个线程之间都是独立的。对于原始类型的局部变量，一个线程可以传递一个副本给另一个线程，当它们之间是无法共享的。

堆区包含了Java应用创建的所有对象信息，不管对象是哪个线程创建的，其中的对象包括原始类型的封装类（如Byte、Integer、Long等等）。不管对象是属于一个成员变量还是方法中的局部变量，它都会被存储在堆区。

一个局部变量如果是原始类型，那么它会被完全存储到栈区。 一个局部变量也有可能是一个对象的引用，这种情况下，这个本地引用会被存储到栈中，但是对象本身仍然存储在堆区。

对于一个对象的成员方法，这些方法中包含局部变量，仍需要存储在栈区，即使它们所属的对象在堆区。 对于一个对象的成员变量，不管它是原始类型还是包装类型，都会被存储到堆区。Static类型的变量以及类本身相关信息都会随着类本身存储在堆区。

![20200322_1397aa](image/4JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/20200322_1397aa.png)

![20200322_a4b5f3](image/4JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/20200322_a4b5f3.png)



#  Java内存模型带来的问题 

##  可见性  问题 

左边CPU中运行的线程从主存中拷贝共享对象obj到它的CPU缓存，把对象obj的count变量改为2。但这个变更对运行在右边CPU中的线程不可见，因为这个更改还没有flush到主存中：要解决共享对象可见性这个问题，我们可以使用java volatile关键字或者是加锁 

竞争问题：线程A和线程B共享一个对象obj。假设线程A从主存读取Obj.count变量到自己的CPU缓存，同时，线程B也读取了Obj.count变量到它的CPU缓存，并且这两个线程都对Obj.count做了加1操作。此时，Obj.count加1操作被执行了两次，不过都在不同的CPU缓存中。如果这两个加1操作是串行执行的，那么Obj.count变量便会在原始值上加2，最终主存中的Obj.count的值会是3。然而下图中两个加1操作是并行的，不管是线程A还是线程B先flush计算结果到主存，最终主存中的Obj.count只会增加1次变成2，尽管一共有两次加1操作。 要解决上面的问题我们可以使用java synchronized代码块。

##  重排序 

除了共享内存和工作内存带来的问题，还存在重排序的问题：在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。

#  Java内存模型中的重排序 

##  重排序类型 

重排序分3种类型。

1）编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。

2）指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-LevelParallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。

3）内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

##  重排序与依赖性  

###  数据依赖性 

如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。数据依赖分为下列3种类型

![20200322_5d8cd9](image/4JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/20200322_5d8cd9.png) 

上面3种情况，只要重排序两个操作的执行顺序，程序的执行结果就会被改变。

###  控制依赖性 

![img](image/4JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/wpsKkXtSx.jpg) 

flag变量是个标记，用来标识变量a是否已被写入，在use方法中比变量i依赖 if  (flag)的判断，这里就叫控制依赖，如果发生了重排序，结果就不对了。

##  as-if-serial  

不管如何重排序，都必须保证代码在单线程下的运行正确，连单线程下都无法正确，更不用讨论多线程并发的情况，所以就提出了一个as-if-serial的概念， 

 as-if-serial 语义的意思是：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。（强调一下，这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。）但是，如果操作之间不存在数据依赖关系，这些操作依然可能被编译器和处理器重排序。

![img](image/4JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/wpsFxe8qj.jpg) 

1和3之间存在数据依赖关系，同时2和3之间也存在数据依赖关系。因此在最终执行的指令序列中，3不能被重排序到1和2的前面（3排到1和2的前面，程序的结果将会被改变）。但1和2之间没有数据依赖关系，编译器和处理器可以重排序1和2之间的执行顺序。

asif-serial语义使单线程下无需担心重排序的干扰，也无需担心内存可见性问题。

#  并发下重排序带来的问题 

![img](image/4JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/wps2tQNZ4.jpg) 

这里假设有两个线程A和B，A首先执行init ()方法，随后B线程接着执行use ()方法。线程B在执行操作4时，能否看到线程A在操作1对共享变量a的写入呢？答案是：不一定能看到。

由于操作1和操作2没有数据依赖关系，编译器和处理器可以对这两个操作重排序；同样，操作3和操作4没有数据依赖关系，编译器和处理器也可以对这两个操作重排序。让我们先来看看，当操作1和操作2重排序时，可能会产生什么效果？操作1和操作2做了重排序。程序执行时，线程A首先写标记变量flag，随后线程B读这个变量。由于条件判断为真，线程B将读取变量a。此时，变量a还没有被线程A写入，这时就会发生错误！

当操作3和操作4重排序时会产生什么效果？

在程序中，操作3和操作4存在控制依赖关系。当代码中存在控制依赖性时，会影响指令序列执行的并行度。为此，编译器和处理器会采用猜测（Speculation）执行来克服控制相关性对并行度的影响。以处理器的猜测执行为例，执行线程B的处理器可以提前读取并计算a*a，然后把计算结果临时保存到一个名为重排序缓冲（Reorder Buffer，ROB）的硬件缓存中。当操作3的条件判断为真时，就把该计算结果写入变量i中。猜测执行实质上对操作3和4做了重排序，问题在于这时候，a的值还没被线程A赋值。在单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果（这也是as-if-serial语义允许对存在控制依赖的操作做重排序的原因）；但在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。

 

#  解决在并发下的问题  

##  内存屏障  

Java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序，从而让程序按我们预想的流程去执行。

1、保证特定操作的执行顺序。

2、影响某些数据（或则是某条指令的执行结果）的内存可见性。

编译器和CPU能够重排序指令，保证最终相同的结果，尝试优化性能。插入一条Memory Barrier会告诉编译器和CPU：不管什么指令都不能和这条Memory Barrier指令重排序。

Memory Barrier所做的另外一件事是强制刷出各种CPU cache，如一个Write-Barrier（写入屏障）将刷出所有在Barrier之前写入 cache 的数据，因此，任何CPU上的线程都能读取到这些数据的最新版本。

JMM把内存屏障指令分为4类，解释表格，StoreLoad Barriers是一个“全能型”的屏障，它同时具有其他3个屏障的效果。现代的多处理器大多支持该屏障（其他类型的屏障不一定被所有处理器支持）。

##  临界区 

临界区内的代码可以重排序（但JMM不允许临界区内的代码“逸出”到临界区之外，那样会破坏监视器的语义）。JMM会在退出临界区和进入临界区这两个关键时间点做一些特别处理，虽然线程A在临界区内做了重排序，但由于监视器互斥执行的特性，这里的线程B根本无法“观察”到线程A在临界区内的重排序。这种重排序既提高了执行效率，又没有改变程序的执行结果。

#  Happens-Before  

##  定义 

在Java 规范提案中为让大家理解内存可见性的这个概念，提出了happens-before的概念来阐述操作之间的内存可见性。对应Java程序员来说，理解happens-before是理解JMM的关键。JMM这么做的原因是：程序员对于这两个操作是否真的被重排序并不关心，程序员关心的是程序执行时的语义不能被改变（即执行结果不能被改变）。因此，happens-before关系本质上和as-if-serial语义是一回事。·as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证正确同步的多线程程序的执行结果不被改变。

![20200322_d26e19](image/4JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/20200322_d26e19.png)

##  Happens-Before规则 

具体规则参见PPT

![img](image/4JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/wpsr4cwyQ.jpg) 



![20200322_da1b18](image/4JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/20200322_da1b18.png)

#  volatile的内存语义 

内存语义：可以简单理解为 volatile，synchronize，atomic，lock 之类的在 JVM 中的内存方面实现原则

 

![20200322_365513](image/4JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/20200322_365513.png)



![20200322_0248f0](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/20200322_0248f0.png)

##  volatile写的内存语义和volatile读的内存语义 

参见PPT

#  volatile内存语义的实现 

![20200322_b0c2f4](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/20200322_b0c2f4.png)

#  锁的内存语义 

![20200322_dfbce1](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/20200322_dfbce1.png)

#  final的内存语义 

![20200322_033d5a](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/20200322_033d5a.png)

#  volatile的实现原理 

![20200322_aeda15](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/20200322_aeda15.png)

#  synchronized的实现原理 

![20200322_b35807](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/20200322_b35807.png)

#  了解各种锁 

![20200322_3c49f0](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/20200322_3c49f0.png)





# JVM 第一课

#  虚拟机历史 

了解即可，无需关注

#  运行时数据区域 

![20200322_530865](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/20200322_530865.png)***



##  程序计数器 

当前线程执行的字节码的行号指示器，占用空间小，也无法干涉

##  虚拟机栈 

每个线程私有的，线程在运行时，在执行每个方法的时候都会打包成一个栈帧，存储了局部变量表，操作数栈，动态链接，方法出口等信息，然后放入栈。每个时刻正在执行的当前方法就是虚拟机栈顶的栈桢。方法的执行就对应着栈帧在虚拟机栈中入栈和出栈的过程。

栈桢大小缺省为1M，可用参数 –Xss调整大小，例如-Xss256k

##  堆 

几乎所有对象都分配在这里，也是垃圾回收发生的主要区域，可用以下参数调整：

-Xms：堆的最小值；

-Xmx：堆的最大值；

-Xmn：新生代的大小；

-XX:NewSize；新生代最小值；

-XX:MaxNewSize：新生代最大值；

例如- Xmx256m

##  方法区/永久代 

用于存储已经被虚拟机加载的类信息，常量("zdy","123"等)，静态变量(static变量)等数据，可用以下参数调整：

jdk1.7及以前：-XX:PermSize；-XX:MaxPermSize；

jdk1.8以后：-XX:MetaspaceSize； -XX:MaxMetaspaceSize.  元空间

jdk1.8以后大小就只受本机总内存的限制

如：-XX:MaxMetaspaceSize=3M

##  直接内存 

不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域；如果使用了NIO,这块区域会被频繁使用，在java堆内可以用directByteBuffer对象直接引用并操作；

这块内存不受java堆大小限制，但受本机总内存的限制，可以通过-XX:MaxDirectMemorySize来设置（默认与堆内存最大值一样），所以也会出现OOM异常。

![20200322_cc66e6](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/20200322_cc66e6.png)

##  各个版本内存区域的变化 

![img](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/wpsq5fkkS.jpg)![img](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/wpsyHwKw7.jpg) 

![img](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/wpskr3bJm.jpg) 

![20200322_5e8123](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/20200322_5e8123.png)

##  站在线程角度来看 

![img](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/wpsspHEVB.jpg)![img](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/wpsOUI87Q.jpg) 

##  深入辨析堆和栈 

**n**  功能  

Ø 以栈帧的方式存储方法调用的过程，并存储方法调用过程中基本数据类型的变量（int、short、long、byte、float、double、boolean、char等）以及对象的引用变量，其内存分配在栈上，变量出了作用域就会自动释放； 

Ø 而堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中； 

**n**  线程独享还是共享  

Ø 栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存。 

Ø 堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问。 

**n**  空间大小  

栈的内存要远远小于堆内存

##  栈上分配 

虚拟机提供的一种优化技术，基本思想是，对于线程私有的对象，将它打散分配在栈上，而不分配在堆上。好处是对象跟着方法调用自行销毁，不需要进行垃圾回收，可以提高性能。

栈上分配需要的技术基础，逃逸分析。逃逸分析的目的是判断对象的作用域是否会逃逸出方法体。注意，任何可以在多个线程之间共享的对象，一定都属于逃逸对象。

public void test(int x,inty ){

String x = “”;

User u = ….

….. 

}

User类型的对象u就 没有 逃逸出方法test。

public  User test(int x,inty ){

String x = “”;

User u = ….

….. 

return u;

}

User类型的对象u就逃逸出方法test。

![20200322_2bbbeb](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/20200322_2bbbeb.png)

###  如何启用栈上分配 

-server JVM运行的模式之一, server模式才能进行逃逸分析， JVM运行的模式还有mix/client

-Xmx10m和-Xms10m：堆的大小

-XX:+DoEscapeAnalysis：启用逃逸分析(默认打开)

-XX:+PrintGC：打印GC日志

-XX:+EliminateAllocations：标量替换(默认打开)

-XX:-UseTLAB 关闭本地线程分配缓冲

TLAB： ThreadLocalAllocBuffer，具体解释参见下文《虚拟机中的对象---对象的分配----2）》因为new对象在堆上分配空间需要加锁，不然就两个对象分配到同一个地址了。TLAB会事先在堆里面为每个线程分配一块私有内存。

对栈上分配发生影响的参数就是三个，-server、-XX:+DoEscapeAnalysis和-XX:+EliminateAllocations，任何一个发生变化都不会发生栈上分配，因为启用逃逸分析和标量替换默认是打开的，所以，在我们的例子中，JVM的参数只用-server一样可以有栈上替换的效果(以Mark老师机器上JDK1.8为例，其他版本JDK请自行尝试)。

###  栈上分配的效果 

同样的User的对象实例，分配100000000次，启用栈上分配，只需6ms，不启用，需要3S。

#  虚拟机中的对象 



![20200323_c657f3](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/20200323_c657f3.png)

内存初始化指的是将类中的变量设初始值，并不是执行构造方法。

##  对象的分配 

虚拟机遇到一条new指令时：

###  1） 

先执行相应的类加载过程。

###  2） 

接下来虚拟机将为新生对象分配内存。为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。

如果Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“ 指针碰撞 ”。

如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“ 空闲列表 ”。

选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。

除如何划分可用空间之外，还有另外一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。

解决这个问题有两种方案，一种是对分配内存空间的动作进行同步处理——实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性；

另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块私有内存，也就是本地线程分配缓冲（Thread Local Allocation Buffer,TLAB），如果设置了虚拟机参数 -XX:UseTLAB，在线程初始化时，同时也会申请一块指定大小的内存，只给当前线程使用，这样每个线程都单独拥有一个Buffer，如果需要分配内存，就在自己的Buffer上分配，这样就不存在竞争的情况，可以大大提升分配效率，当Buffer容量不够的时候，再重新从Eden区域申请一块继续使用。

TLAB的目的是在为新对象分配内存空间时，让每个Java应用线程能在使用自己专属的分配指针来分配空间，减少同步开销。

TLAB只是让每个线程有私有的分配指针，但底下存对象的内存空间还是给所有线程访问的，只是其它线程无法在这个区域分配而已。当一个TLAB用满（分配指针top撞上分配极限end了），就新申请一个TLAB。

###  3） 

内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值(如int值为0，boolean值为false等等)。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

###  4） 

接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头之中。

###  5） 

在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，对象创建才刚刚开始，所有的字段都还为零值。所以，一般来说，执行new指令之后会接着把对象按照程序员的意愿进行初始化(执行构造函数)，这样一个真正可用的对象才算完全产生出来。

##  对象的内存布局 

在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。

对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。 

对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。

第三部分对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot VM的自动内存管理系统要求对对象的大小必须是8字节的整数倍。当对象其他数据部分没有对齐时，就需要通过对齐填充来补全。

![20200323_c4e414](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/20200323_c4e414.png)

##  对象的访问定位 

建立对象是为了使用对象，我们的Java程序需要通过栈上的reference数据来操作堆上的具体对象。目前主流的访问方式有使用句柄和直接指针两种。

如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。

如果使用直接指针访问， reference中存储的直接就是对象地址。

这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。

使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。

对Sun HotSpot而言，它是使用直接指针访问方式进行对象访问的。

![20200323_896c04](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/20200323_896c04.png) 

#  堆参数设置和内存溢出实战 

##  堆溢出： 

参数 ： -Xms5m -Xmx5m -XX:+PrintGC

出现java.lang.OutOfMemoryError: GC overhead limit exceeded 一般是（某个循环里可能性最大）在不停的分配对象，但是分配的太多，把堆撑爆了。

出现java.lang.OutOfMemoryError: Java heap space一般是分配了巨型对象

##  栈溢出 

参数：-Xss256k

java.lang.StackOverflowError 一般的方法调用是很难出现的，如果出现了要考虑是否有无限递归。

虚拟机栈带给我们的启示：方法的执行因为要打包成栈桢，所以天生要比实现同样功能的循环慢，所以树的遍历算法中：递归和非递归(循环来实现)都有存在的意义。递归代码简洁，非递归代码复杂但是速度较快。





## 第二课

#  垃圾收集器与内存分配策略 

为什么要了解GC和内存分配策略

1、面试需要

2、GC对应用的性能是有影响的；

3、写代码有好处

#  判断对象的存活 

引用计数法：快，方便，实现简单，缺点：对象相互引用时，很难判断对象是否改回收。

##  可达性分析 

（ 面试时重要的知识点，牢记 ）

来判定对象是否存活的。这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。

作为GC Roots的对象包括下面几种：

l 虚拟机栈（栈帧中的本地变量表）中引用的对象。

l 方法区中类静态属性引用的对象。

l 方法区中常量引用的对象。

l 本地方法栈中JNI（即一般说的Native方法）引用的对象。

#  各种引用 

##  强引用 

一般的Object obj = new Object() ，就属于强引用。

##  软引用 SoftReference 

一些有用但是并非必需，用软引用关联的对象，系统将要发生OOM之前，这些对象就会被回收。参见代码：

![img](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/wpsQ54n4w.jpg)

![20200323_54dae6](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/20200323_54dae6.png)

 

运行结果

![img](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/wps70UAal.jpg) 

##  弱引用 WeakReference 

一些有用（程度比软引用更低）但是并非必需，用弱引用关联的对象，只能生存到下一次垃圾回收之前，GC发生时，不管内存够不够，都会被回收。

参看代码：

![img](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/wpsanrPg9.jpg) 

![img](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/wps55o5mX.jpg) 

##  虚引用 PhantomReference 

幽灵引用，最弱，被垃圾回收的时候收到一个通知

 

 注意： 软引用 SoftReference和弱引用 WeakReference，可以用在内存资源紧张的情况下以及创建不是很重要的数据缓存。当系统内存不足的时候，缓存中的内容是可以被释放的。

例如，一个程序用来处理用户提供的图片。如果将所有图片读入内存，这样虽然可以很快的打开图片，但内存空间使用巨大，一些使用较少的图片浪费内存空间，需要手动从内存中移除。如果每次打开图片都从磁盘文件中读取到内存再显示出来，虽然内存占用较少，但一些经常使用的图片每次打开都要访问磁盘，代价巨大。这个时候就可以用软引用构建缓存。

 

 

 

#  标记-清除算法（Mark-Sweep） 

算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。

它的主要不足空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

#  复制算法（Copying） 

将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为了原来的一半。

#  标记-整理算法（Mark-Compact） 

首先标记出所有需要回收的对象，在标记完成后，后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

#  把算法们都用上 

当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。

专门研究表明，新生代中的对象98%是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor[1]。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。

在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。

 请记住下图的垃圾收集器和之间的连线关系。 

![img](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/wpsY9sqtL.png) 

#  垃圾回收器列表 

并行：垃圾收集的多线程的同时进行。

并发：垃圾收集的多线程和应用的多线程同时进行。

#  垃圾回收器工作示意图 

![20200323_9c98ea](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/20200323_9c98ea.png)

![20200323_f2ecd0](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/20200323_f2ecd0.png)

 java -XX:+PrintCommandLineFlags -version：用来查看用了什么垃圾收集器

##  Serial/Serial Old 

最古老的，单线程，独占式，成熟，适合单CPU  服务器

-XX:+UseSerialGC 新生代和老年代都用串行收集器

-XX:+UseParNewGC 新生代使用ParNew，老年代使用Serial Old

-XX:+UseParallelGC 新生代使用ParallerGC，老年代使用Serial Old

 

##  ParNew  

和Serial基本没区别，唯一的区别：多线程，多CPU的，停顿时间比Serial少

-XX:+UseParNewGC 新生代使用ParNew，老年代使用Serial Old

![20200323_98e943](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/20200323_98e943.png) 

##  Parallel Scavenge（ParallerGC）/Parallel Old 

关注吞吐量的垃圾收集器，高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。

所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间），虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。

-XX:+UseParallerOldGC：新生代使用ParallerGC，老年代使用Parallel Old

-XX:MaxGCPauseMills  ：参数允许的值是一个大于0的毫秒数，收集器将尽可能地保证内存回收花费的时间不超过设定值。不过大家不要认为如果把这个参数的值设置得稍小一点就能使得系统的垃圾收集速度变得更快，GC停顿时间缩短是以牺牲吞吐量和新生代空间来换取的：系统把新生代调小一些，收集300MB新生代肯定比收集500MB快吧，这也直接导致垃圾收集发生得更频繁一些，原来10秒收集一次、每次停顿100毫秒，现在变成5秒收集一次、每次停顿70毫秒。停顿时间的确在下降，但吞吐量也降下来了。

-XX:GCTimeRatio参数的值应当是一个大于0且小于100的整数，也就是垃圾收集时间占总时间的比率，相当于是吞吐量的倒数。如果把此参数设置为19，那允许的最大GC时间就占总时间的5%（即1/（1+19）），默认值为99，就是允许最大1%（即1/（1+99））的垃圾收集时间。

-XX:+UseAdaptiveSizePolicy 当这个参数打开之后，就不需要手工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX：SurvivorRatio）、晋升老年代对象年龄（-XX：PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为GC自适应的调节策略。

如果对于收集器运作原来不太了解，手工优化存在困难的时候，使用Parallel Scavenge收集器配合自适应调节策略，把内存管理的调优任务交给虚拟机去完成将是一个不错的选择。只需要把基本的内存数据设置好（如-Xmx设置最大堆），然后使用MaxGCPauseMillis参数（更关注最大停顿时间）或GCTimeRatio（更关注吞吐量）参数给虚拟机设立一个优化目标，那具体细节参数的调节工作就由虚拟机完成了。自适应调节策略也是Parallel Scavenge收集器与ParNew收集器的一个重要区别。

 ![20200323_4f01fa](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/20200323_4f01fa.png)

##  Concurrent Mark Sweep （CMS） 

收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。

从名字（包含“Mark Sweep”）上就可以看出，CMS收集器是基于“标记—清除”算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为4个步骤，包括：

**l**  初始标记 -短暂，仅仅只是标记一下GC Roots能直接关联到的对象，速度很快。

**l**  并发标记 -和用户的应用程序同时进行，进行GC RootsTracing的过程

**l**  重新标记 -短暂，为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。

**l**  并发清除 

由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。需要给用户线程留下运行空间。

-XX:+UseConcMarkSweepGC ，表示新生代使用ParNew，老年代的用CMS

-XX:CMSInitialOccupyFraction:当老年代空间使用超过这个值的时候启动收集。

当出现错误“Concurrent Mode Failure”时，启动Serial Old收集器，所以图上CMS和serial old也连在了一起。

—XX:+UseCMSCompactAtFullCollection:需要进行full gc是开启内存碎片的整理，无法并发。

 标记清除会产生很多碎片，所以需要full gc,

##  G1 

-XX:+UseG1GC

![20200323_0457a3](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/20200323_0457a3.png)

 并行与并发 ：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。并行是多个垃圾收集线程一起工作，并发是垃圾收集线程和用户线程一起运行。

 分代收集 ：与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。

 空间整合 ：与CMS的“标记—清理”算法不同，G1从整体来看是基于“标记—整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。

 内存布局： 在G1之前的其他收集器进行收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局就与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。

n 新生代GC

回收Eden区和survivor区，回收后，所有eden区被清空，存在一个survivor区保存了部分数据。老年代区域会增多，因为部分新生代的对象会晋升到老年代。

n 并发标记周期 

 初始标记： 短暂，仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，产生一个全局停顿，都伴随有一次新生代的GC。

 根区域扫描： 扫描survivor区可以直接到达的老年代区域。

 并发标记阶段： 扫描和查找整个堆的存活对象，并标记。与用户线程同时运行

 重新标记： 会产生全局停顿，对并发标记阶段的结果进行修正。

 独占清理 ：会产生全局停顿，对GC回收比例进行排序，供混合收集阶段使用

 并发清理 ：识别并清理完全空闲的区域，并发进行

n 混合收集 

对含有垃圾比例较高的Region进行回收。

G1当出现内存不足的的情况，也可能进行的FullGC回收。

G1中重要的参数：

-XX:MaxGCPauseMillis 指定目标的最大停顿时间，G1尝试调整新生代和老年代的比例，堆大小，晋升年龄来达到这个目标时间。

-XX:ParallerGCThreads：设置GC的工作线程数量

#  未来的垃圾回收 

ZGC通过技术手段把stw的情况控制在仅有一次，就是第一次的初始标记才会发生，这样也就不难理解为什么GC停顿时间不随着堆增大而上升了，再大我也是通过并发的时间去回收了

关键技术

**1.**  有色指针（Colored Pointers） 

**2.**  加载屏障（Load Barrier） 

#  Stop The World现象  

GC收集器和我们GC调优的目标就是尽可能的减少STW的时间和次数。

#  内存分配与回收策略  

 对象优先在Eden分配 ，如果说Eden内存空间不足，就会发生Minor GC

 大对象直接进入老年代 ，大对象：需要大量连续内存空间的Java对象，比如很长的字符串和大型数组，1、导致内存有空间，还是需要提前进行垃圾回收获取连续空间来放他们，2、会进行大量的内存复制。

-XX:PretenureSizeThreshold 参数 ，大于这个数量直接在老年代分配，缺省为0 ，表示绝不会直接分配在老年代。

 长期存活的对象将进入老年代 ，默认15岁，-XX:MaxTenuringThreshold调整

 动态对象年龄判定， 为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄

 空间分配担保 ：新生代中有大量的对象存活，survivor空间不够，当出现大量对象在MinorGC后仍然存活的情况（最极端的情况就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代.只要老年代的连续空间大于新生代对象的总大小或者历次晋升的平均大小，就进行Minor GC，否则FullGC。

minor gc只发生在新生代，full gc发生在新生代，老年代和永久代都执行 

#  新生代配置 

新生代大小配置参数的优先级：

高：-XX:NewSize/MaxNewSize

中间 -Xmn （NewSize= MaxNewSize）

低：-XX:NewRatio  表示比例，例如=2，表示 新生代：老年代 = 1:2

 

-XX:SurvivorRatio 表示Eden和Survivor的比值，

缺省为8 表示 Eden:FromSurvivor:ToSurvivor= 8:1:1

 

 同样的代码情况下： 

-Xms20M -Xmx20M -XX:+PrintGCDetails –Xmn2m -XX:SurvivorRatio=2

没有垃圾回收

数组都在老年代

 

-Xms20M -Xmx20M -XX:+PrintGCDetails -Xmn7m -XX:SurvivorRatio=2

发生了垃圾回收

新生代存了部分数组，老年代也保存了部分数组，发生了晋升现象

 

-Xms20M -Xmx20M -XX:+PrintGCDetails -Xmn15m -XX:SurvivorRatio=8

新生代可以放下所有的数组

老年代没放

 

-Xms20M -Xmx20M -XX:+PrintGCDetails -XX:NewRatio=2

发生了垃圾回收

出现了空间分配担保，而且发生了FullGC

#  内存泄漏和内存溢出辨析  

内存溢出：实实在在的内存空间不足导致；

内存泄漏：该释放的对象没有释放，多见于自己使用容器保存元素的情况下。例如在栈或数组中拿出数据后忘了置空。

#  JDK为我们提供的工具  

 jps  

列出当前机器上正在运行的虚拟机进程

-p  :仅仅显示VM 标示，不显示jar,class, main参数等信息.

-m:输出主函数传入的参数. 下的hello 就是在执行程序时从命令行输入的参数

-l: 输出应用程序主类完整package名称或jar完整名称.

-v: 列出jvm参数, -Xms20m -Xmx50m是启动程序指定的jvm参数

 

 jstat 

是用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据，在没有GUI图形界面，只提供了纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的首选工具。

假设需要每250毫秒查询一次进程2764垃圾收集状况，一共查询20次，那命令应当是：jstat-gc 2764 250 20

常用参数：

-class (类加载器) 

-compiler (JIT) 

-gc (GC堆状态) 

-gccapacity (各区大小) 

-gccause (最近一次GC统计和原因) 

-gcnew (新区统计)

-gcnewcapacity (新区大小)

-gcold (老区统计)

-gcoldcapacity (老区大小)

-gcpermcapacity (永久区大小)

-gcutil (GC统计汇总)

-printcompilation (HotSpot编译统计)

 

  jinfo  

查看和修改虚拟机的参数

jinfo –sysprops 可以查看由System.getProperties()取得的参数

jinfo –flag 未被显式指定的参数的系统默认值

jinfo –flags（注意s）显示虚拟机的参数

jinfo –flag +[参数] 可以增加参数，但是仅限于由java -XX:+PrintFlagsFinal –version查询出来且![img](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/wps3nzBYm.jpg)

为manageable的参数

jinfo –flag -[参数] 可以去除参数

Thread.**getAllStackTraces**();

 

 jmap 

用于生成堆转储快照（一般称为heapdump或dump文件）。jmap的作用并不仅仅是为了获取dump文件，它还可以查询finalize执行队列、Java堆和永久代的详细信息，如空间使用率、当前用的是哪种收集器等。和jinfo命令一样，jmap有不少功能在Windows平台下都是受限的，除了生成dump文件的-dump选项和用于查看每个类的实例、空间占用统计的-histo选项在所有操作系统都提供之外，其余选项都只能在Linux/Solaris下使用。

jmap -dump:live,format=b,file=heap.bin <pid>

Sun JDK提供jhat（JVM Heap Analysis Tool）命令与jmap搭配使用，来分析jmap生成的堆转储快照。

 jhat 

jhat dump文件名

后屏幕显示“Server is ready.”的提示后，用户在浏览器中键入http://localhost：7000/就可以访问详情

 jstack 

（Stack Trace for Java）命令用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的常见原因。

在代码中可以用java.lang.Thread类的getAllStackTraces（）方法用于获取虚拟机中所有线程的StackTraceElement对象。使用这个方法可以通过简单的几行代码就完成jstack的大部分功能，在实际项目中不妨调用这个方法做个管理员页面，可以随时使用浏览器来查看线程堆栈。

 

 管理远程进程需要在远程程序的启动参数中增加： 

-Djava.rmi.server.hostname=…..

-Dcom.sun.management.jmxremote

-Dcom.sun.management.jmxremote.port=8888

-Dcom.sun.management.jmxremote.authenticate=false

-Dcom.sun.management.jmxremote.ssl=false

 

 visualvm 

插件中心地址

[https://visualvm.github.io](https://visualvm.github.io/archive/uc/8u40/updates.xml.gz)

但是注意版本问题，不同的JDK所带的visualvm是不一样的，下载插件时需要下对应的版本。

 

 浅堆和深堆 

浅堆 :（Shallow Heap）是指一个对象所消耗的内存。例如，在32位系统中，一个对象引用会占据4个字节，一个int类型会占据4个字节，long型变量会占据8个字节，每个对象头需要占用8个字节。

深堆 ：这个对象被GC回收后，可以真实释放的内存大小，也就是只能通过对象被 直接 或 间接 访问到的所有对象的集合。通俗地说，就是指仅被对象所持有的对象的集合。深堆是指对象的保留集中所有的对象的浅堆大小之和。

举例：对象A引用了C和D，对象B引用了C和E。那么对象A的浅堆大小只是A本身，不含C和D，而A的实际大小为A、C、D三者之和。而A的深堆大小为A与D之和，由于对象C还可以通过对象B访问到，因此不在对象A的深堆范围内。

 ![20200324_f0ddfb](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/20200324_f0ddfb.png)





#  Class类文件结构 

##  Java跨平台的基础 

各种不同平台的虚拟机与所有平台都统一使用的程序存储格式——字节码（ByteCode）是构成平台无关性的基石，也是语言无关性的基础。Java虚拟机不和包括Java在内的任何语言绑定，它只与“Class文件”这种特定的二进制文件格式所关联，Class文件中包含了Java虚拟机指令集和符号表以及若干其他辅助信息。

##  Class类的本质 

任何一个Class文件都对应着唯一一个类或接口的定义信息，但反过来说，Class文件实际上它并不一定以磁盘文件的形式存在。

Class文件是一组以8位字节为基础单位的二进制流。

##  Class文件格式 

各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。

Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：无符号数和表。

无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。

表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表。

##  Class文件格式详解 

Class的结构不像XML等描述语言，由于它没有任何分隔符号，所以在其中的数据项，无论是顺序还是数量，都是被严格限定的，哪个字节代表什么含义，长度是多少，先后顺序如何，都不允许改变。

按顺序包括：

###  魔数与Class文件的版本 

每个Class文件的头4个字节称为魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意地改动。文件格式的制定者可以自由地选择魔数值，只要这个魔数值还没有被广泛采用过同时又不会引起混淆即可。

紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号（MinorVersion），第7和第8个字节是主版本号（Major Version）。Java的版本号是从45开始的，JDK 1.1之后的每个JDK大版本发布主版本号向上加1高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件，即使文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的Class文件。

###  常量池 

常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值（constant_pool_count）。与Java中语言习惯不一样的是，这个容量计数是从1而不是0开始的

常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。

字面量比较接近于Java语言层面的常量概念，如文本字符串、声明为final的常量值等。

而符号引用则属于编译原理方面的概念，包括了下面三类常量：

类和接口的全限定名（Fully Qualified Name）、字段的名称和描述符（Descriptor）、方法的名称和描述符

###  访问标志 

用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final等

###  类索引、父类索引与接口索引集合 

这三项数据来确定这个类的继承关系。类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。由于Java语言不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此除了java.lang.Object外，所有Java类的父类索引都不为0。接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按implements语句（如果这个类本身是一个接口，则应当是extends语句）后的接口顺序从左到右排列在接口索引集合中

###  字段表集合 

描述接口或者类中声明的变量。字段（field）包括类级变量以及实例级变量。

而字段叫什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。

字段表集合中不会列出从超类或者父接口中继承而来的字段，但有可能列出原本Java代码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。

###  方法表集合 

描述了方法的定义，但是方法里的Java代码，经过编译器编译成字节码指令后，存放在属性表集合中的方法属性表集合中一个名为“Code”的属性里面。

与字段表集合相类似的，如果父类方法在子类中没有被重写（Override），方法表集合中就不会出现来自父类的方法信息。但同样的，有可能会出现由编译器自动添加的方法，最典型的便是类构造器“＜clinit＞”方法和实例构造器“＜init＞”

###  属性表集合 

存储Class文件、字段表、方法表都自己的属性表集合，以用于描述某些场景专有的信息。如方法的代码就存储在Code属性表中。

#  字节码指令 

Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为操作码，Opcode）以及跟随其后的零至多个代表此操作所需参数（称为操作数，Operands）而构成。

由于限制了Java虚拟机操作码的长度为一个字节（即0～255），这意味着指令集的操作码总数不可能超过256条。

大多数的指令都包含了其操作所对应的数据类型信息。例如：

iload指令用于从局部变量表中加载int型的数据到操作数栈中，而fload指令加载的则是float类型的数据。

大部分的指令都没有支持整数类型byte、char和short，甚至没有任何指令支持boolean类型。大多数对于boolean、byte、short和char类型数据的操作，实际上都是使用相应的int类型作为运算类型

 阅读字节码作为了解  Java  虚拟机的基础技能，请熟练掌握。请熟悉并掌握常见指令即可。 

##  加载和存储指令 

用于将数据在栈帧中的局部变量表和操作数栈之间来回传输，这类指令包括如下内容。

将一个局部变量加载到操作栈：iload、iload_＜n＞、lload、lload_＜n＞、fload、fload_＜n＞、dload、dload_＜n＞、aload、aload_＜n＞。

将一个数值从操作数栈存储到局部变量表：istore、istore_＜n＞、lstore、lstore_＜n＞、fstore、fstore_＜n＞、dstore、dstore_＜n＞、astore、astore_＜n＞。

将一个常量加载到操作数栈：bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_m1、iconst_＜i＞、lconst_＜l＞、fconst_＜f＞、dconst_＜d＞。

扩充局部变量表的访问索引的指令：wide。

##  运算或算术指令 

用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。

加法指令：iadd、ladd、fadd、dadd。

减法指令：isub、lsub、fsub、dsub。

乘法指令：imul、lmul、fmul、dmul等等

##  类型转换指令 

可以将两种不同的数值类型进行相互转换，

Java虚拟机直接支持以下数值类型的宽化类型转换（即小范围类型向大范围类型的安全转换）：

int类型到long、float或者double类型。

long类型到float、double类型。

float类型到double类型。

处理窄化类型转换（Narrowing Numeric Conversions）时，必须显式地使用转换指令来完成，这些转换指令包括：i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l和d2f。

##  创建类实例的指令： 

new。

##  创建数组的指令： 

newarray、anewarray、multianewarray。

##  访问字段指令： 

getfield、putfield、getstatic、putstatic。

 

##  数组存取相关指令 

把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、daload、aaload。

将一个操作数栈的值存储到数组元素中的指令：bastore、castore、sastore、iastore、fastore、dastore、aastore。

取数组长度的指令：arraylength。

##  检查类实例类型的指令： 

instanceof、checkcast。

##  操作数栈管理指令 

如同操作一个普通数据结构中的堆栈那样，Java虚拟机提供了一些用于直接操作操作数栈的指令，包括：将操作数栈的栈顶一个或两个元素出栈：pop、pop2。

复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2。

将栈最顶端的两个数值互换：swap。

## 　 控制转移指令 

控制转移指令可以让Java虚拟机有条件或无条件地从指定的位置指令而不是控制转移指令的下一条指令继续执行程序，从概念模型上理解，可以认为控制转移指令就是在有条件或无条件地修改PC寄存器的值。控制转移指令如下。

条件分支：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq和if_acmpne。

复合条件分支：tableswitch、lookupswitch。

无条件分支：goto、goto_w、jsr、jsr_w、ret。

##  方法调用指令 

invokevirtual指令用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），这也是Java语言中最常见的方法分派方式。

invokeinterface指令用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用。

invokespecial指令用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法。

invokestatic指令用于调用类方法（static方法）。

invokedynamic指令用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法，前面4条调用指令的分派逻辑都固化在Java虚拟机内部，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。

方法调用指令与数据类型无关。

##  方法返回指令 

是根据返回值的类型区分的，包括ireturn（当返回值是boolean、byte、char、short和int类型时使用）、lreturn、freturn、dreturn和areturn，另外还有一条return指令供声明为void的方法、实例初始化方法以及类和接口的类初始化方法使用。

##  异常处理指令 

在Java程序中显式抛出异常的操作（throw语句）都由athrow指令来实现

##  同步指令 

有monitorenter和monitorexit两条指令来支持synchronized关键字的语义

#  类加载机制 

![20200324_63f0d0](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/20200324_63f0d0.png)***

##  概述 

类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）7个阶段。其中验证、准备、解析3个部分统称为连接（Linking）

于初始化阶段，虚拟机规范则是严格规定了有且只有5种情况必须立即对类进行“初始化”（类的初始化不是指对象的实例化那个构造函数）（而加载、验证、准备自然需要在此之前开始）：

1）遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。

2）使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。

3）当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。

声明数组的形式是不会触发类的初始化的。关于类中的final常量直接编译到main类中了，调用该常量时不会触发类的初始化

4）当虚拟机启动时，用户需要指定一个要执行的主类（包含main（）方法的那个类），虚拟机会先初始化这个主类。

5）当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。

 

##  注意： 

对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。

常量HELLOWORLD，但其实在编译阶段通过常量传播优化，已经将此常量的值“hello world”存储到了NotInitialization类的常量池中，以后NotInitialization对常量ConstClass.HELLOWORLD的引用实际都被转化为NotInitialization类对自身常量池的引用了。

也就是说，实际上NotInitialization的Class文件之中并没有ConstClass类的符号引用入口，这两个类在编译成Class之后就不存在任何联系了。

 

##  加载阶段 ****

class文件来源：本地，网络，数据库，其他文件，运行时动态代理生成

虚拟机需要完成以下3件事情：

1）通过一个类的全限定名来获取定义此类的二进制字节流。

2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。

3）在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

##  验证 

是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。但从整体上看，验证阶段大致上会完成下面4个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。

##  准备阶段 

是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这个阶段中有两个容易产生混淆的概念需要强调一下，首先，这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。其次，这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量的定义为：

public static int value=123；

那变量value在准备阶段过后的初始值为0而不是123，因为这时候尚未开始执行任何Java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器＜clinit＞（）方法之中，所以把value赋值为123的动作将在初始化阶段才会执行。表7-1列出了Java中所有基本数据类型的零值。

假设上面类变量value的定义变为：public static final int value=123；

编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123。

##  解析阶段 

是虚拟机将常量池内的符号引用替换为直接引用的过程

##  类初始化阶段 

是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：初始化阶段是执行类构造器＜clinit＞（）方法的过程。＜clinit＞（）方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的。

＜clinit＞（）方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成＜clinit＞（）方法。

虚拟机会保证一个类的＜clinit＞（）方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的＜clinit＞（）方法，其他线程都需要阻塞等待，直到活动线程执行＜clinit＞（）方法完毕。如果在一个类的＜clinit＞（）方法中有耗时很长的操作，就可能造成多个进程阻塞。

##  类加载器 

如何自定义类加载器，看代码



![20200324_625bd6](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/20200324_625bd6.png)

```java
 *
 *类说明：我们要处理的业务类
 */
public class DemoUser {
	
	private int id = 1;
	private String name = "mark";
	
	@Override
	public String toString() {
		return "DemoUser [id=" + id + ", name=" + name + "]";
	}
	

}
```

```java
package com.xiangxue.ch03.deencrpt;

import java.io.*;

/**
 *@author Mark老师   享学课堂 https://enjoy.ke.qq.com 
 *
 *类说明：加密和解密的服务类
 */
public class XorEncrpt{

	//异或操作,可以进行加密和解密
    private void xor(InputStream in, OutputStream out)  throws Exception{
        int ch;
        while (-1 != (ch = in.read())){
            ch = ch^ 0xff;
            out.write(ch);
        }
    }

    //加密方法
    public void encrypt(File src, File des) throws Exception {
        InputStream in = new FileInputStream(src);
        OutputStream out = new FileOutputStream(des);

        xor(in,out);

        in.close();
        out.close();
    }

    //解密方法
    //加密后的class文件
    public byte[] decrypt(File src) throws Exception {
        InputStream in = new FileInputStream(src);
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        xor(in,bos);
        byte[] data = bos.toByteArray();;
        return data;
    }
    
    public static void main(String[] args) throws Exception {
        File src = new File("D:\\XiangXue\\vipLesson\\JVM\\code\\src\\"
        		+ "vip-jvm\\bin\\com\\xiangxue\\ch03\\deencrpt\\DemoUserSrc.class");
        File dest = new File("D:\\XiangXue\\vipLesson\\JVM\\code\\src"
        		+ "\\vip-jvm\\bin\\com\\xiangxue\\ch03\\deencrpt\\DemoUser.class");
        XorEncrpt demoEncryptUtil = new XorEncrpt();
        demoEncryptUtil.encrypt(src,dest);
        System.out.println("加密完成！");
    }


}
```

```java
*类说明：自定义的类加载器
 */
public class CustomClassLoader extends ClassLoader{

    private final String name;
    private String basePath;
    private final static String FILE_EXT = ".class";

    public CustomClassLoader(String name) {
        super();
        this.name = name;
    }

    public void setBasePath(String basePath) {
        this.basePath = basePath;
    }

    //实际解密
    private byte[] loadClassData(String name){
    	int x = 0 ;
        byte[] data = null;
        XorEncrpt demoEncryptUtil = new XorEncrpt();
        // use x;
        int y = 1;
        try {
        	String tempName = name.replaceAll("\\.","\\\\");
            data = demoEncryptUtil.decrypt(new File(basePath+tempName+FILE_EXT));
        } catch (Exception e) {
            e.printStackTrace();
        }
        return data;
    }

    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        byte[] data = this.loadClassData(name);
        return this.defineClass(name,data,0,data.length);
    }
}
```

```java
public class DemoRun {

    public static void main(String[] args) throws Exception {
        CustomClassLoader demoCustomClassLoader 
        	= new CustomClassLoader("My ClassLoader");
        demoCustomClassLoader.setBasePath("D:\\XiangXue\\vipLesson\\JVM\\code"
        		+ "\\src\\vip-jvm\\bin\\");
        Class<?> clazz = 
        		demoCustomClassLoader.findClass("com.xiangxue.ch03."
        				+ "deencrpt.DemoUser");
        System.out.println(clazz.getClassLoader());
        Object o = clazz.newInstance();
        System.out.println(o);
        //new User(xxx,yyyy,ddd);//
    }
}
```



##  系统的类加载器 

对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。

这里所指的“相等”，包括代表类的Class对象的equals（）方法、isAssignableFrom（）方法、isInstance（）方法的返回结果，也包括使用instanceof关键字做对象所属关系判定等情况。

在自定义ClassLoader的子类时候，我们常见的会有两种做法，一种是重写 loadClass 方法，另一种是重写 findClass 方法。其实这两种方法本质上差不多，毕竟loadClass也会调用findClass，但是从逻辑上讲我们最好不要直接修改loadClass的内部逻辑。我建议的做法是只在findClass里重写自定义类的加载方法。
loadClass这个方法是实现双亲委托模型逻辑的地方，擅自修改这个方法会导致模型被破坏，容易造成问题。因此我们最好是在双亲委托模型框架内进行小范围的改动，不破坏原有的稳定结构。同时，也避免了自己重写loadClass方法的过程中必须写双亲委托的重复代码，从代码的复用性来看，不直接修改这个方法始终是比较好的选择。

![20200324_cfdd08](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/20200324_cfdd08.png)

##  双亲委派模型 

从Java虚拟机的角度来讲，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用C++语言实现，是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader。

启动类加载器（Bootstrap ClassLoader）：这个类将器负责将存放在＜JAVA_HOME＞\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，那直接使用null代替即可。

扩展类加载器（Extension ClassLoader）：这个加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载＜JAVA_HOME＞\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。

应用程序类加载器（Application ClassLoader）：这个类加载器由sun.misc.Launcher $App-ClassLoader实现。由于这个类加载器是ClassLoader中的getSystemClassLoader（）方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

我们的应用程序都是由这3种类加载器互相配合进行加载的，如果有必要，还可以加入自己定义的类加载器。

双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是都使用组合（Composition）关系来复用父加载器的代码。

使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为java.lang.Object的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。

![20200324_ba7c45](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/20200324_ba7c45.png)

 

##  Tomcat类加载机制 

Tomcat本身也是一个java项目，因此其也需要被JDK的类加载机制加载，也就必然存在引导类加载器、扩展类加载器和应用(系统)类加载器。

Common ClassLoader作为Catalina ClassLoader和Shared ClassLoader的parent，而Shared ClassLoader又可能存在多个children类加载器WebApp ClassLoader，一个WebApp ClassLoader实际上就对应一个Web应用，那Web应用就有可能存在Jsp页面，这些Jsp页面最终会转成class类被加载，因此也需要一个Jsp的类加载器。

需要注意的是，在代码层面Catalina ClassLoader、Shared ClassLoader、Common ClassLoader对应的实体类实际上都是URLClassLoader或者SecureClassLoader，一般我们只是根据加载内容的不同和加载父子顺序的关系，在逻辑上划分为这三个类加载器；而WebApp ClassLoader和JasperLoader都是存在对应的类加载器类的。

当tomcat启动时，会创建几种类加载器：

 1 Bootstrap 引导类加载器  加载JVM启动所需的类，以及标准扩展类（位于jre/lib/ext下）

 2 System 系统类加载器  加载tomcat启动的类，比如bootstrap.jar，通常在catalina.bat或者catalina.sh中指定。位于CATALINA_HOME/bin下。

 3 Common 通用类加载器  加载tomcat使用以及应用通用的一些类，位于CATALINA_HOME/lib下，比如servlet-api.jar

 4 webapp 应用类加载器 每个应用在部署后，都会创建一个唯一的类加载器。该类加载器会加载位于 WEB-INF/lib下的jar文件中的class 和 WEB-INF/classes下的class文件。 所以即使类的名字一样，由于是两个应用，类加载器不同，保证了类的隔离性。![20200324_eade1a](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/20200324_eade1a.png)

![20200324_9af431](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/20200324_9af431.png)



#  栈桢 

![20200324_109798](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/20200324_109798.png)

##  栈桢详解 

局部变量表
操作数栈
动态连接
方法返回地址

 

#  方法调用详解 

##  解析 

调用目标在程序代码写好、编译器进行编译时就必须确定下来。这类方法的调用称为解析。

在Java语言中符合“编译期可知，运行期不可变”这个要求的方法，主要包括静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问，这两种方法各自的特点决定了它们都不可能通过继承或别的方式重写其他版本，因此它们都适合在类加载阶段进行解析。

 ![20200324_f3eae0](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/20200324_f3eae0.png)

##  静态分派 

多见于方法的重载。

![img](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/wpssrPzJg.jpg) 

“Human”称为变量的静态类型（Static Type），或者叫做的外观类型（Apparent Type），后面的“Man”则称为变量的实际类型（Actual Type），静态类型和实际类型在程序中都可以发生一些变化，区别是静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译期可知的；而实际类型变化的结果在运行期才可确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么。

代码中定义了两个静态类型相同但实际类型不同的变量，但虚拟机（准确地说是编译器）在重载时是通过参数的静态类型而不是实际类型作为判定依据的。并且静态类型是编译期可知的，因此，在编译阶段，Javac编译器会根据参数的静态类型决定使用哪个重载版本，所以选择了sayHello（Human）作为调用目标。所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。静态分派的典型应用是方法重载。静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的。

解析和静态分派都是在编译阶段就知道调用了哪个方法，静态分派（方法的重载）

##  动态分派 

静态类型同样都是Human的两个变量man和woman在调用sayHello（）方法时执行了不同的行为，并且变量man在两次调用中执行了不同的方法。导致这个现象的原因很明显，是这两个变量的实际类型不同。

在实现上，最常用的手段就是为类在方法区中建立一个虚方法表。虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表里面的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。如果子类中重写了这个方法，子类方法表中的地址将会替换为指向子类实现版本的入口地址。PPT图中，Son重写了来自Father的全部方法，因此Son的方法表没有指向Father类型数据的箭头。但是Son和Father都没有重写来自Object的方法，所以它们的方法表中所有从Object继承来的方法都指向了Object的数据类型。

面向对象的多态就是动态分派。

 

#  基于栈的字节码解释执行引擎 

 基于寄存器的指令集，和硬件比较紧密，运行速度快

基于栈的指令集，可移植。





### 编写高效优雅的java程序常见原则

1.构造器参数太多怎么办？

用builder模式:对象的创建模式，

```java
package com.xiangxue.ch04.builder01;

public class FoodBuilder {

    //required
    private final String foodName;
    private final int reilang;

    //optional
    private  int danbz;
    private  int dianfen;
    private  int zf;
    private  int tang;
    private   int wss;
    
    public static class Builder{
        //required
        private final String foodName;
        private final int reilang;

        //optional
        private  int danbz;
        private  int dianfen;
        private  int zf;
        private  int tang;
        private   int wss;
        
		public Builder(String foodName, int reilang) {
			super();
			this.foodName = foodName;
			this.reilang = reilang;
		}
		
		public Builder danbz(int val) {
			this.danbz = val;
			return this;
		}
        
		//.......
		
		public FoodBuilder build() {
			return new FoodBuilder(this);
		}
    }
    
    private FoodBuilder(Builder builder) {
    	foodName = builder.foodName;
    	reilang = builder.reilang;
    	danbz = builder.danbz;
    	//.....
    	
    }
    
    public static void main(String[] args) {
    	FoodBuilder foodBuilder 
    	= new FoodBuilder.Builder("food2", 1000).danbz(100)
    	//.....
    	.build();

	}



}
```



2.不需要实例化的类应该构造器私有。

例如Arrays类，private Arrays(){};

3.不要创建不必要的对象

能够使用基本类型的时候就使用基本类型，基本类型对应的引用类型会出现自动装箱和自动拆箱，就会new出引用类型对象。java为每种基本类型都提供了对应的封装类型，分别为：Byte、Short、Integer、Long、Float、Double、Character、Boolean。引用类型是一种对象类型,它的值是指向内存空间的引用，就是地址。

使用static类型，避免创建多次

4.避免使用终结方法（finalize()方法)

5.使用类和成员的可访问性最小化

6.使可变性最小化

7.优先使用复合胜于继承

8.接口优于抽象类。

9.可变参数要谨慎使用

![20200325_1295b0](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/20200325_1295b0.png)

![20200325_28fe02](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/20200325_28fe02.png)



10.返回零长度的数组或集合，不要返回Null

要求调用的要单独处理为null的情况，所以就返回一个空集合，return Collections.EMPTY_LIST;

11.优先使用标准的异常。

12.用枚举代替int常量

```java
package com.xiangxue.ch04.enmu12;

public enum DepotEnum {
	UNPAY(0,"未支付"),PAID(1,"已支付"),TIMOUT(-1,"超时");
	
	private int status;
	private String desc;
	private String dbInfo;//其他属性
	
	private DepotEnum(int status, String desc) {
		this.status = status;
		this.desc = desc;
	}

	public int getStatus() {
		return status;
	}

	public String getDesc() {
		return desc;
	}

	public String getDbInfo() {
		return dbInfo;
	}
	
	public int calcStatus(int params) {
		return status+params;
	}
	
	public static void main(String[] args) {
		for(DepotEnum e:DepotEnum.values()) {
			System.out.println(e+":"+e.calcStatus(14));
		}
	}
	
	

	
	
}
```



![20200325_52d419](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/20200325_52d419.png)



```java
package com.xiangxue.ch04.enmu12;

/**
 *@author Mark老师   享学课堂 https://enjoy.ke.qq.com 
 *
 *类说明：枚举和行为绑定
 */
public class ActiveEnum {
	
	public enum NormalActive{
		PLUS,MINUS,MULTI,DIVIDS,DIFFER;
		
		double oper(double x,double y) {
			switch(this) {
			case PLUS:return x+y;
			case MINUS:return x-y;
			case MULTI:return x*y;
			case DIVIDS:return x/y;
			}
			throw new UnsupportedOperationException();
		}		
	}
	
	public enum BetterActive{
		PLUS {
			@Override
			double oper(double x, double y) {
				return x+y;
			}
		},MINUS {
			@Override
			double oper(double x, double y) {
				return x-y;
			}
		};
		
		abstract double oper(double x,double y);
		
//		double oper(double x,double y) {
//			switch(this) {
//			case PLUS:return x+y;
//			case MINUS:return x-y;
//			case MULTI:return x*y;
//			case DIVIDS:return x/y;
//			
//			//default:
//			}
//			throw new UnsupportedOperationException();
//		}		
	}
	
	
	
	public static void main(String[] args) {
		System.out.println(NormalActive.PLUS.oper(0.1, 0.2));
	}

}
```



13.将局部变量的作用域最小化

在第一次使用的地方进行声明。

都是要自行初始化，初始化条件不满足，就不要声明。

14.精确计算，避免使用float和double

使用long或者BigDecimal

15.当心字符串连接的性能

16控制方法的大小



## 深入了解性能优化

总原则：避免过早优化；进行系统性能测试；寻找系统瓶颈，分而治之，逐步优化

### 前端优化手段

#### 浏览器

- 减少请求数：合并CSS,Js,图片
- 使用客户端缓冲：静态资源文件缓存在浏览器，cache-control和Expires
- 启用压缩:在服务器压缩，然后传到浏览器再解压缩。会给浏览器和服务器带来性能压力。
- 资源文件加载顺序：css放在最前面，js放在最下面。
- 减少cookie传输：请求静态资源就不需要cookie



#### CDN加速：内容分发网络，也就是缓存

#### 反向代理缓存：ngnix

#### Web组件分离

### 应用服务器性能优化

1.缓存

![20200325_3e2750](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/20200325_3e2750.png)



> 一致性hash:*consistent hashing* 是一种 *hash* 算法，简单的说，在移除 */* 添加一个 *cache* 时，它能够尽可能小的改变已存在 *key* 映射关系，尽可能的满足单调性的要求。
>
> 3.1 环形hash 空间
> 考虑通常的 hash 算法都是将 value 映射到一个 32 为的 key 值，也即是 0~2^32-1 次方的数值空间；我们可以将这个空间想象成一个首（ 0 ）尾（ 2^32-1 ）相接的圆环，如下面图 1 所示的那样。
>
> ![circle space](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/circle.JPG)
>
> ### *3.2* 把对象映射到*hash* 空间
>
> 接下来考虑 *4* 个对象 *object1~object4* ，通过 *hash* 函数计算出的 *hash* 值 *key* 在环上的分布如图 *2* 所示。
>
> *hash(object1) = key1;*
>
> *… …*
>
> *hash(object4) = key4;*
>
> ![object](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/object.JPG)
>
> 3.3 把cache 映射到hash 空间
> Consistent hashing 的基本思想就是将对象和 cache 都映射到同一个 hash 数值空间中，并且使用相同的 hash 算法。
>
> 假设当前有 A,B 和 C 共 3 台 cache ，那么其映射结果将如图 3 所示，他们在 hash 空间中，以对应的 hash 值排列。
>
> hash(cache A) = key A;
>
> … …
>
> hash(cache C) = key C;
> 
> 
>
> ![cache](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/cache.JPG)
>
> 
>
> 说到这里，顺便提一下 cache 的 hash 计算，一般的方法可以使用 cache 机器的 IP 地址或者机器名作为 hash 输入。
>
> 3.4 把对象映射到cache
> 现在 cache 和对象都已经通过同一个 hash 算法映射到 hash 数值空间中了，接下来要考虑的就是如何将对象映射到 cache 上面了。
>
> 在这个环形空间中，如果沿着顺时针方向从对象的 key 值出发，直到遇见一个 cache ，那么就将该对象存储在这个 cache 上，因为对象和 cache 的 hash 值是固定的，因此这个 cache 必然是唯一和确定的。这样不就找到了对象和 cache 的映射方法了吗？！
>
> 依然继续上面的例子（参见图 3 ），那么根据上面的方法，对象 object1 将被存储到 cache A 上； object2 和 object3 对应到 cache C ； object4 对应到 cache B ；
>
> 3.5 考察cache 的变动
> 前面讲过，通过 hash 然后求余的方法带来的最大问题就在于不能满足单调性，当 cache 有所变动时， cache 会失效，进而对后台服务器造成巨大的冲击，现在就来分析分析 consistent hashing 算法。
>
> 3.5.1 移除 cache
>
> 考虑假设 cache B 挂掉了，根据上面讲到的映射方法，这时受影响的将仅是那些沿 cache B 逆时针遍历直到下一个 cache （ cache C ）之间的对象，也即是本来映射到 cache B 上的那些对象。
>
> 因此这里仅需要变动对象 object4 ，将其重新映射到 cache C 上即可；参见图 4 。
>
> ![remove](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/remove.JPG)
>
> 3.5.2 添加 cache
>
> 再考虑添加一台新的 cache D 的情况，假设在这个环形 hash 空间中， cache D 被映射在对象 object2 和 object3 之间。这时受影响的将仅是那些沿 cache D 逆时针遍历直到下一个 cache （ cache B ）之间的对象（它们是也本来映射到 cache C 上对象的一部分），将这些对象重新映射到 cache D 上即可。
>
> 因此这里仅需要变动对象 object2 ，将其重新映射到 cache D 上；参见图 5 。
> ![add](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/add.JPG)
>
> 4 虚拟节点
> 考量 Hash 算法的另一个指标是平衡性 (Balance) ，定义如下：
>
> 平衡性
>
> 　　平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。
>
> hash 算法并不是保证绝对的平衡，如果 cache 较少的话，对象并不能被均匀的映射到 cache 上，比如在上面的例子中，仅部署 cache A 和 cache C 的情况下，在 4 个对象中， cache A 仅存储了 object1 ，而 cache C 则存储了 object2 、 object3 和 object4 ；分布是很不均衡的。
>
> 为了解决这种情况， consistent hashing 引入了“虚拟节点”的概念，它可以如下定义：
>
> “虚拟节点”（ virtual node ）是实际节点在 hash 空间的复制品（ replica ），一实际个节点对应了若干个“虚拟节点”，这个对应个数也成为“复制个数”，“虚拟节点”在 hash 空间中以 hash 值排列。
>
> 仍以仅部署 cache A 和 cache C 的情况为例，在图 4 中我们已经看到， cache 分布并不均匀。现在我们引入虚拟节点，并设置“复制个数”为 2 ，这就意味着一共会存在 4 个“虚拟节点”， cache A1, cache A2 代表了 cache A ； cache C1, cache C2 代表了 cache C ；假设一种比较理想的情况，参见图 6 。
> ![virtual nodes](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/virtual.JPG)
>
> 此时，对象到“虚拟节点”的映射关系为：
>
> objec1->cache A2 ； objec2->cache A1 ； objec3->cache C1 ； objec4->cache C2 ；
>
> 因此对象 object1 和 object2 都被映射到了 cache A 上，而 object3 和 object4 映射到了 cache C 上；平衡性有了很大提高。
>
> 引入“虚拟节点”后，映射关系就从 { 对象 -> 节点 } 转换到了 { 对象 -> 虚拟节点 } 。查询物体所在 cache 时的映射关系如图 7 所示。
> ![map](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/map.JPG)
>
> “虚拟节点”的 hash 计算可以采用对应节点的 IP 地址加数字后缀的方式。例如假设 cache A 的 IP 地址为 202.168.14.241 。
>
> 引入“虚拟节点”前，计算 cache A 的 hash 值：
>
> Hash(“202.168.14.241”);
>
> 引入“虚拟节点”后，计算“虚拟节”点 cache A1 和 cache A2 的 hash 值：
>
> Hash(“202.168.14.241#1”);  // cache A1
>
> Hash(“202.168.14.241#2”);  // cache A2
>
> 
>
> 一致性hash的缺点：数据分配不均，解决方法就是虚拟的节点。
>
> 





缓存的基本原则：如果频繁修改数据，尽量不要缓存，读写比2:1以上才有缓存的价值

缓存的一定是热点数据，用缓存应用就要容忍一定时间的数据不一致。

缓存预热：事先把热点数据加载好。

缓存击穿：黑客攻击，大量不存在的id请求落在了mysql上，1.使用布隆过滤器，2.把不存在的数据也缓存起来，value为null.就避免了去mysql查询。

2.集群

3.异步

![20200325_e4f25a](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/20200325_e4f25a.png)

同步和异步关注的是结果消息的通信机制

阻塞和非阻塞关注的是等待结果返回给调用方的状态

bio:同步阻塞

nio:同步非阻塞

aio:异步



4.程序

![20200325_fe18d0](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/20200325_fe18d0.png)

![20200325_4e4142](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/20200325_4e4142.png)

![20200325_0778e3](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/20200325_0778e3.png)

![20200325_3314d8](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/20200325_3314d8.png)

![20200325_c03c23](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/20200325_c03c23.png)

![20200325_ec465c](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/20200325_ec465c.png)

GC参数：-XX:+PrintGCDetails

-XX:+HeapDumpOnOutOfMemoryError -XX:HeadDumpPath;表示当出现oom时打印异常时堆栈情况，并输出到指定的目录。



![20200325_d293e2](image/4.JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/20200325_d293e2.png)

